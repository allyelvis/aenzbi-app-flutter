’valuealphaopacityredgreenblue	withAlphawithOpacitywithRed	withGreenwithBlue_linearizeColorComponentcomputeLuminancelerp
alphaBlendgetAlphaFromOpacity==hashCodetoStringclearsrcdstsrcOverdstOversrcIndstInsrcOutdstOutsrcATopdstATopxorplusmodulatescreenoverlaydarkenlighten
colorDodge	colorBurn	hardLight	softLight
difference	exclusionmultiplyhue
saturationcolor
luminositynonelowmediumhighbuttroundsquaremiterbevelfillstrokehardEdge	antiAliasantiAliasWithSaveLayer_data_kIsAntiAliasIndex_kColorIndex_kBlendModeIndex_kStyleIndex_kStrokeWidthIndex_kStrokeCapIndex_kStrokeJoinIndex_kStrokeMiterLimitIndex_kFilterQualityIndex_kMaskFilterIndex_kMaskFilterBlurStyleIndex_kMaskFilterSigmaIndex_kInvertColorIndex_kDitherIndex_kIsAntiAliasOffset_kColorOffset_kBlendModeOffset_kStyleOffset_kStrokeWidthOffset_kStrokeCapOffset_kStrokeJoinOffset_kStrokeMiterLimitOffset_kFilterQualityOffset_kMaskFilterOffset_kMaskFilterBlurStyleOffset_kMaskFilterSigmaOffset_kInvertColorOffset_kDitherOffset_kDataByteCount_objects_ensureObjectsInitialized_kShaderIndex_kColorFilterIndex_kImageFilterIndex_kObjectCountisAntiAlias_kColorDefault_kBlendModeDefault	blendModestylestrokeWidth	strokeCap
strokeJoin_kStrokeMiterLimitDefaultstrokeMiterLimit
maskFilterfilterQualityshadercolorFilterimageFilterinvertColors_ditherenableDitheringsRGBextendedSRGBrawRgbarawStraightRgbarawUnmodifiedrawExtendedRgba128pngrgba8888bgra8888rgbaFloat32_imageonCreate	onDispose_debugStackwidthheight	_disposeddisposedebugDisposed
toByteData
colorSpacedebugGetOpenHandleStackTracesclone	isCloneOf_toByteData_dispose_handlesdurationimage
frameCountrepetitionCountgetNextFrame_cachedFrameCount_frameCount_cachedRepetitionCount_repetitionCount_getNextFramenonZeroevenOdd	intersectunionreverseDifferencefillTypemoveTorelativeMoveTolineTorelativeLineToquadraticBezierTorelativeQuadraticBezierTocubicTorelativeCubicToconicTorelativeConicToarcTo
arcToPointrelativeArcToPointaddRectaddOvaladdArc
addPolygonaddRRectaddPathextendWithPathcloseresetcontainsshift	transform	getBoundscombinecomputeMetrics_constructor_clone_getFillType_setFillType_arcTo_arcToPoint_relativeArcToPoint_addRect_addOval_addArc_addPolygon	_addRRect_addPath_addPathWithMatrix_extendWithPath_extendWithPathAndMatrix	_contains_shift
_transform
_getBounds_oppositionvectorangle	_iteratoriterator_pathMetric_pathMeasurecurrentmoveNextlengthisClosedcontourIndex_measuregetTangentForOffsetextractPath_length
_getPosTan_extractPath	_isClosed_nextContour_nativeNextContourcurrentContourIndexnormalsolidouterinner_style_sigma	_TypeNone	_TypeBlur_color
_blendMode_matrix_type
_kTypeMode_kTypeMatrix_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGamma_toNativeImageFilter_toNativeColorFilter_shortDescriptioncreator	_initMode_initMatrix_initLinearToSrgbGamma_initSrgbToLinearGammadatanativeFiltersigmaXsigmaYtileMode_modeStringradiusXradiusYinnerFilterouterFilter	_initBlur_initDilate
_initErode_initColorFilter_initComposed_debugDisposedclamprepeatedmirrordecal_initLinear_initRadial_initConical
_initSweep_validateColorStops_initWithImage
_debugName	fromAsset_shaderRegistry_reinitializeShader_uniformFloatCount_samplerCount_initFromAssetfragmentShader_kEmptyFloat32List_floatssetFloatsetImageSampler_setImageSampler_validateSamplers	trianglestriangleStriptriangleFan_initpointslinespolygonsave	saveLayerrestorerestoreToCountgetSaveCount	translatescalerotateskewgetTransformclipRect	clipRRectclipPathgetLocalClipBoundsgetDestinationClipBounds	drawColordrawLine	drawPaintdrawRect	drawRRect
drawDRRectdrawOval
drawCircledrawArcdrawPath	drawImagedrawImageRectdrawImageNinedrawPicturedrawParagraph
drawPointsdrawRawPointsdrawVertices	drawAtlasdrawRawAtlas
drawShadow	_recorder_saveLayerWithoutBounds
_saveLayer_scale_getTransform	_clipRect
_clipRRect	_clipPath_getLocalClipBounds_getDestinationClipBounds
_drawColor	_drawLine
_drawPaint	_drawRect
_drawRRect_drawDRRect	_drawOval_drawCircle_drawArc	_drawPath
_drawImage_drawImageRect_drawImageNine_drawPicture_drawPoints_drawVertices
_drawAtlas_drawShadowtoImagetoImageSyncapproximateBytesUsed_toImage_toImageSyncisRecordingendRecording_endRecording_canvas_kBytesPerShadow	_kXOffset	_kYOffset_kBlurOffsetoffset
blurRadiusconvertRadiusToSigma	blurSigmatoPaintlerpList_encodeShadowsfromUint8ListfromFilePath_initFromFileencodedbytesPerPixelinstantiateCodec_initEncoded_initRaw_width	_getWidth_height
_getHeight_bytesPerPixel_getBytesPerPixel_instantiateCodecmessagestackS_rectIsValid_rrectIsValid_offsetIsValid_matrix4IsValid_radiusIsValid_scaleAlphaColor	BlendModeFilterQuality	StrokeCap
StrokeJoinPaintingStyleClipPaint
ColorSpaceImageByteFormatPixelFormatImageEventCallbackImage_ImageImageDecoderCallback	FrameInfoCodec_NativeCodecinstantiateImageCodecinstantiateImageCodecFromBufferinstantiateImageCodecWithSize_getDefaultImageSizeTargetImageSizeCallbackTargetImageSizedecodeImageFromList_decodeImageFromListAsyncdecodeImageFromPixelsPathFillTypePathOperationEngineLayer_NativeEngineLayerPath_NativePathTangentPathMetricsPathMetricIterator
PathMetric_PathMeasure	BlurStyle
MaskFilterColorFilter_ColorFilterImageFilter_MatrixImageFilter_GaussianBlurImageFilter_DilateImageFilter_ErodeImageFilter_ComposeImageFilter_ImageFilterShaderTileMode_encodeColorList_encodePointList_encodeTwoPointsGradientImageShaderFragmentProgramFragmentShader
VertexModeVertices	PointModeClipOpCanvas_NativeCanvasPictureEventCallbackPicture_NativePicturePictureRecorder_NativePictureRecorderShadowImmutableBufferImageDescriptor_NativeImageDescriptor	_Callback_Callbacker	_futurizePictureRasterizationExceptiondartuiboolRecthasNaNRRectOffsetdxisNaNdyFloat64ListlengtheverydoublevalueisFiniteRadiusxy	withAlphaalpharoundclampintfromRGBOfromARGBmathpowHSVColormaterialColorstransparentCurveselasticInOutAnimationController	_clampInt_lerpInttoIntredgreenblueclampDoubleoverrideObject	identicalruntimeTypehashCodeStringtoRadixStringpadLeftsrcdstclear	saveLayerrestore	blendModesrcOverdstInsrcOutsrcIndstOutdstATopdstOversrcATopplusmultiplyscreenoverlaymodulate	hardLight
colorDodge	colorBurncolor	exclusion
difference
luminosityhue	softLight
saturationblurBackdropFilternonelowmediumhighfilterQualitymatrix	drawImagedrawImageRectdrawImageNine	drawAtlas	strokeCapAsquarestrokeWidthbuttdrawPath
drawPoints
strokeJoinstrokeMiterLimitstyle
drawCirclehardEdge	antiAliasantiAliasWithSaveLayerisAntiAliaspragmaByteDataListfilledgetInt32_kFakeHostEndiansetInt32indexvaluesfillstroke
getFloat32
setFloat32miterbevel	_TypeNone	_TypeBlur_style_sigmadebugDisposed_validateSamplers	Exception
_debugNamecreator_toNativeColorFilter_toNativeImageFilter
DeprecatedfromEnvironmenttoStringStringBufferwritetoStringAsFixed
toByteDataextendedSRGBrawExtendedRgba128
colorSpacevoidwidgets
StackTracecurrent_handlesaddcallMemoryAllocations	_disposedcontainsremoveisEmptydispose
StateErrorformatrawRgbaFuturesRGBUnsupportedErrormaphandle_debugStacktoList__imageNativeFieldWrapperClass1NativeInt32PointerVoidsymbolisLeaf	Uint8Listcallbackencodedbuffer
asByteDataHandleSetgetNextFramecloneDurationimage	CompletersyncdecodeErrorcompleteErrorcompletewidthheightdurationmillisecondsdurationMillisecondsfuturefromUint8ListtargetWidthtargetHeightallowUpscalinggetTargetSizeintrinsicWidthintrinsicHeightinstantiateCodecthenrawrowBytespixelFormatcodec	frameInfofillTypecombinereverseDifferencexor	intersectSceneBuilderclipPath_clonenonZerozero
fromCircle_opextractPathIterablefromDoublelefttoprightbottomBoolradiusrotationlargeArc	clockwiseFloat32List_getValue32matrix4fromLTRBforceClosedgetTangentForOffsetcossinatan2computeMetricslineTomoveToIterableBaseIterator
RangeError_nextContourcurrentContourIndexisClosedcloseaddRectstartWithMoveTonextContour
maskFilter
drawShadowhashcolorFilterfromColorFiltermodelinearToSrgbGammasrgbToLinearGamma_type_listEquals_matrix_color
_blendModehashAll
_kTypeMode_kTypeMatrixfromList_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGammaImageFilteredpushBackdropFilterpushImageFiltersigmaXsigmaYtileModeradiusXradiusYMatrix4	diagonal3ArgumentErrordatainnerFilterinnerouterFilteroutermirrorrepeateddecaldilateerodecomposed_shortDescriptionshaderpaintingGradientLinearGradientRadialGradientBoxDecorationlinearradial	Int32ListiNoSuchMethodError
colorStopsfocalfocalRadiuspi
startAngleendAngle
isNotEmptyUripath
encodeFulltarget	microtask
_fromAssetWeakReferenceMap_initFromAsset	debugNamefragmentShader_uniformFloatCount_samplerCountdrawVertices	trianglestriangleStriptriangleFannew
Uint16ListcolorstextureCoordinatesindicesdrawRawPointsclipRectSceneendRecordingCustomPainterpaintsydoAntiAliasarcTo	ParagraphlayoutParagraphStyleParagraphBuilder	TextAlignParagraphConstraintspointslinespolygonRSTransformscosssintxtyisRecording_canvascullRectlargest_objects_dataclipOpUint32stack_NativeParagraph_needsLayout_paint
addPicturedrawPicture	onDisposeUint64	_recorderonCreate	TextStylenormaloffset
blurRadiusscalelerp_lerpDoubleminshadowIndex_kColorDefaultconvertRadiusToSigma_init_length_initFromFile_initEncodedTttoImageSyncwritelnNativeFieldWrapperClass1CodecEngineLayerPathIterableBaseIteratorImageFilterShaderCanvasPicturePictureRecorderImageDescriptor	ExceptionH˜:©óÍÁ]»ËLùIu      	dart:coreÀl´ ÀLÂ›N <€†€¤€µ€¶€Î€ï-Fz­®û‚E‚•‚æƒ6ƒ„ƒÕ„„„d„Š„‹„ª„ê„ù„û„ü……`…o…q…r…—…ñ† †††/†p†Î†İ†ß†à‡‡]‡l‡n‡o‡›‡Û‡İ‡Şˆˆˆfˆ¶‰‰-‰1‰a‰e‰q‰™‰ÖŠŠFŠNŠRŠ£Šò‹B‹n‹r‹~‹ËŒŒŒŒ-Œ1Œ„ŒÊŒØEKs™Àåë;‰·½Pu¬­íó@PuœÂÈ‘‘‘\‘i‘‘À‘â’’2’3’ˆ’’³’Ú“ “M“}“ƒ“Æ“Ì””R”ˆ”¾”ô•6•7•e•k•“•™•Á•ç––3–F–G–€–†–Õ–÷—&—'—Z—`—±—Ó—ù—ú˜1˜^˜_˜˜˜Æ˜Ç˜ÿ™,™-™v™¬™²™êšš5š9š:šƒšËšÑ›	›/›]››’›“›ãœœœNœgœ™œœœç#[v¦ª«ü)/g²¶·õŸ2ŸRŸrŸxŸ¹Ÿ½Ÿ¾ 	  c  ‡ Å ã¡#¡^¡›¡×¢¢¢¢<¢B¢Š¢Í¢Ó££j£©£ï£õ¤B¤Œ¤×¥#¥q¥Á¦¦_¦Œ¦’¦á§§6§K§b§w§†§®§¶§Ã§Ú§ü¨¨*¨n¨®¨ò©4©?©G©M©Q©R©•©Û©áª-ªtª¿««Y«™«Á¬ ¬¬¬F¬l¬£¬À¬Î­­^­¦­¯­Ì­ş®,®L®i®{®Æ¯¯b¯k¯q¯u¯v¯Ã¯É¯ô°'°b°f°g°s°–°¸°Ë°Ñ°ı±±±1±R±V±W±c±‰±Š±–±ä±æ±ç²²²k²µ²Ô²Ø³)³v³Å´´c´®´ò´öµFµ‘µâ¶.¶|¶É··[·ª·ğ¸¸¸]¸ª¸ô¹F¹“¹äº%º)ºPºTº¢ºã»4»»Ò¼!¼p¼‹¼¼¼¡¼ì¼ı½½]½p½¶½·½û¾¾=¾C¾ ¾©¾ª¾é¾ï¿>¿M¿S¿¿”¿ï¿ö¿÷À @6À @<À @‡À @˜À @À @àÀ @æÀ AAÀ AHÀ AIÀ A†À AŒÀ AÚÀ B+À BHÀ BNÀ BœÀ BÉÀ BÏÀ C.À C9À C:À CxÀ C~À C§À C­À CûÀ DÀ D`À DfÀ DµÀ DàÀ DëÀ DìÀ E4À EÀ EÎÀ EÜÀ EâÀ F!À F'À FtÀ F¼À FÌÀ FÒÀ GÀ G$À GÀ GŠÀ G‹À GØÀ H&À HpÀ HvÀ H°À H¶À IÀ IUÀ I[À I§À I­À J
À JÀ JÀ JcÀ J¶À KÀ KÀ KKÀ KQÀ KÀ KïÀ KõÀ LBÀ LHÀ L¦À L°À L±À MÀ MSÀ MÀ M£À MŞÀ MäÀ N6À N‚À NˆÀ NÕÀ NÛÀ O9À OCÀ ODÀ O“À O³À O¹À PÀ PÀ P]À P©À PİÀ PãÀ Q.À Q?À QEÀ Q¤À Q¯À Q°À QÿÀ RÀ R À RnÀ RtÀ RÄÀ SÀ S?À SEÀ SÀ S¡À S§À TÀ TÀ TÀ TbÀ T–À TœÀ TéÀ TïÀ UJÀ UQÀ URÀ U‘À U—À UæÀ V2À VXÀ V^À V¬À V²À WÀ WQÀ W¢À WñÀ X;À XAÀ XÀ X¥À X¦À XğÀ XöÀ YEÀ Y”À YšÀ YëÀ ZÀ ZÀ ZkÀ ZqÀ ZÑÀ Z×À ZçÀ ZíÀ [/À [wÀ [“À [İÀ [ôÀ \ À \À \IÀ \JÀ \•À \»À \ÁÀ ]À ]ZÀ ]‰À ]À ]àÀ ^,À ^RÀ ^XÀ ^¨À ^÷À _HÀ _NÀ _À _¿À _ÅÀ `#À `)À `9À `?À `À ` À `èÀ aÀ aNÀ aeÀ aˆÀ a‰À aÒÀ bÀ bÀ bXÀ b¦À b÷À cÀ cÀ chÀ cµÀ cäÀ cêÀ dIÀ dOÀ d_À deÀ dÀ dåÀ e5À e`À ekÀ elÀ eºÀ eÙÀ eßÀ f(À f9À f?À fÀ f§À f¨À f÷À gÀ gÀ geÀ gvÀ g|À gÛÀ gæÀ gçÀ h"À h(À htÀ hÁÀ hğÀ höÀ iXÀ ifÀ igÀ iºÀ iÀÀ jÀ jYÀ jˆÀ jÀ jïÀ jüÀ jıÀ kFÀ kpÀ kvÀ kÆÀ lÀ l]À lŠÀ lÀ lÜÀ m)À mXÀ m^À m¿À mÅÀ mÕÀ mÛÀ nÀ n[À nªÀ nÖÀ nãÀ näÀ o2À oJÀ oPÀ o’À o˜À oùÀ oÿÀ pÀ pÀ pNÀ p[À p\À p¥À p«À púÀ qÀ qÀ q`À qqÀ qwÀ q¯À qµÀ rÀ r%À r&À rrÀ r€À r†À rÕÀ rìÀ ròÀ s;À sLÀ sRÀ sŠÀ sÀ sñÀ sşÀ sÿÀ tMÀ tfÀ tlÀ t»À u
À uÀ u\À u©À uñÀ u÷À vFÀ vjÀ vpÀ vĞÀ vùÀ vúÀ wKÀ wdÀ wjÀ w³À w¹À xÀ xRÀ xxÀ x~À xÙÀ xßÀ xïÀ xõÀ yEÀ ynÀ y½À yîÀ yõÀ yöÀ zGÀ z`À zfÀ z¯À zÿÀ {,À {2À {À {“À {£À {©À {ëÀ |:À |PÀ |^À |_À |°À |ÉÀ |ÏÀ }À }À }gÀ }·À }ìÀ }òÀ ~OÀ ~UÀ ~eÀ ~kÀ ~¡À ~ïÀ =À FÀ GÀ ˜À ±À ·À € À €PÀ €}À €ƒÀ €åÀ €ëÀ €ûÀ À PÀ fÀ ±À ÊÀ ØÀ ÚÀ ÛÀ ‚3À ‚nÀ ‚rÀ ‚ÏÀ ƒÀ ƒÀ ƒoÀ ƒÃÀ „À „mÀ „qÀ „¿À „úÀ „şÀ …WÀ …[À …¨À …ğÀ †À †À †!À †%À †pÀ †©À †¿À †ÜÀ †÷À ‡À ‡5À ‡PÀ ‡eÀ ‡»À ‡ãÀ ‡äÀ ˆ(À ˆ.À ˆtÀ ˆ¹À ˆÁÀ ˆÂÀ ˆúÀ ‰ À ‰BÀ ‰qÀ ‰xÀ ‰yÀ ‰ÃÀ ‰ëÀ ‰ñÀ Š<À Š‰À ŠÒÀ ‹À ‹#À ‹SÀ ‹cÀ ‹iÀ ‹¸À ‹ìÀ ŒÀ ŒÀ ŒÀ Œ\À ŒiÀ ŒoÀ Œ½À ŒúÀ  À 'À -À À ÏÀ À  À MÀ UÀ WÀ XÀ |À €À À ’À ÇÀ 
À FÀ WÀ —À À îÀ RÀ XÀ ¦À ØÀ àÀ áÀ ‘À ‘"À ‘lÀ ‘¼À ’,À ’2À ’‚À ’§À ’°À ’±À ’ôÀ “9À “^À “dÀ “³À ”$À ”*À ”zÀ ”ŸÀ ”¥À ”óÀ •À •À •À • À •JÀ •NÀ •›À •ßÀ •ãÀ •ñÀ •õÀ –AÀ –MÀ –ˆÀ –ÅÀ –×À —À —À —|À —‚À —ÊÀ ˜À ˜&À ˜,À ˜<À ˜BÀ ˜À ˜¡À ˜òÀ ™+À ™4À ™5À ™jÀ ™pÀ ™×À ™İÀ š%À šuÀ šÀ š‡À š—À šÀ šëÀ šüÀ ›À ›À ›TÀ ›†À ›ŒÀ ›óÀ ›ùÀ œAÀ œ‘À œÀ œ£À œ³À œ¹À À À !À #À $À ^À bÀ yÀ µÀ ÊÀ À #À $À jÀ °À ×À ßÀ àÀ Ÿ$À ŸjÀ Ÿ±À ŸïÀ ŸùÀ ŸûÀ ŸüÀ  +À  7À  MÀ  SÀ  À  ïÀ  õÀ ¡AÀ ¡WÀ ¡¤À ¡ıÀ ¢RÀ ¢kÀ ¢sÀ ¢tÀ ¢ À ¢¦À ¢ÿÀ £0À £6À £vÀ £|À £ÔÀ ¤/À ¤5À ¤EÀ ¤KÀ ¤§À ¤ËÀ ¤×À ¤ØÀ ¤÷À ¤ıÀ ¥IÀ ¥OÀ ¥¢À ¥¨À ¥ïÀ ¥õÀ ¦JÀ ¦iÀ ¦ÀÀ ¦ÆÀ ¦ÖÀ ¦ÜÀ §$À §oÀ § À §ıÀ ¨
À ¨À ¨WÀ ¨]À ¨°À ©À ©+À ©1À ©ƒÀ ©ĞÀ ª"À ªtÀ ªzÀ ªÊÀ «À «hÀ «¸À «şÀ ¬À ¬À ¬À ¬hÀ ¬‚À ¬„À ¬…À ¬ÇÀ ¬ËÀ ­À ­0À ­>À ­†À ­œÀ ­¨À ­ÃÀ ­ÙÀ ­ßÀ ­ãÀ ­äÀ ®À ®À ®cÀ ®®À ®ıÀ ¯KÀ ¯šÀ ¯ŸÀ ¯ïÀ °@À °QÀ °VÀ °À °ŸÀ °ÀÀ °ÜÀ ±À ±À ±<À ±aÀ ±ŠÀ ±¯À ±ÚÀ ²À ²-À ²]À ²ŠÀ ²´À ²èÀ ³À ³DÀ ³kÀ ³lÀ ³®À ³äÀ ´"À ´XÀ ´šÀ ´ØÀ µÀ µdÀ µªÀ µêÀ ¶<À ¶†À ¶ÈÀ · À ·AÀ ·jÀ ·kÀ ·¯À ·ĞÀ ·ìÀ ¸À ¸À ¸6À ¸yÀ ¸}À ¸~À ¸¤À ¸ÏÀ ¸úÀ ¹NÀ ¹OÀ ¹•À ¹£À ¹©À ¹ÁÀ ¹ÚÀ º!À º%À ºEÀ º•À º¿À ºæÀ »*À ».À »/À »gÀ »—À »˜À »ÑÀ »×À »÷À »ıÀ ¼À ¼À ¼YÀ ¼ŠÀ ¼ÒÀ ¼ØÀ ½ À ½5À ½IÀ ½’À ½¾À ½ÂÀ ½İÀ ¾À ¾QÀ ¾UÀ ¾VÀ ¾À ¾ÏÀ ¾ĞÀ ¿À ¿"À ¿dÀ ¿µÀ ÀÀ À'À À-À ÀzÀ À›À À¡À ÀÈÀ ÀÎÀ ÀŞÀ ÀäÀ Á3À ÁgÀ Á±À ÁÇÀ ÁãÀ Â0À ÂkÀ ÂoÀ Â’À ÂÌÀ ÃÀ ÃÀ ÃÀ ÃWÀ Ã]À Ã…À Ã¡À ÃóÀ Ã÷À ÄÀ Ä?À Ä}À ÄÀ Ä‚À Ä¼À ÅÀ ÅHÀ ÅNÀ Å‹À Å¦À ÅêÀ ÅîÀ ÆÀ Æ2À ÆxÀ Æ|À Æ}À Æ¾À ÆîÀ ÆôÀ Ç&À ÇBÀ Ç”À Ç˜À Ç»À ÇàÀ È"À È&À È'À ÈhÀ ÈnÀ È¿À É
À ÉÀ ÉJÀ ÉPÀ ÉnÀ ÉtÀ ÉİÀ ÉãÀ ÊJÀ ÊPÀ Ê·À Ê½À Ë	À ËZÀ ËfÀ ËlÀ Ë|À Ë‚À ËÑÀ ËıÀ ÌFÀ Ì…À Ì£À Ì÷À ÌûÀ Í À ÍEÀ ÍˆÀ ÍŒÀ ÍÀ ÍÅÀ ÍüÀ ÍıÀ ÎHÀ Î–À ÎáÀ Ï.À Ï|À Ï‚À ÏÇÀ ÏÍÀ ĞÀ Ğ?À ĞEÀ Ğ®À Ğ´À ÑÀ Ñ#À ÑŒÀ Ñ’À ÑŞÀ Ò/À Ò;À ÒAÀ ÒQÀ ÒWÀ Ò¡À Ò¼À ÓÀ Ó%À ÓnÀ ÓrÀ Ó™À Ó×À Ô"À Ô&À Ô'À ÔwÀ ÔµÀ Ô»À ÔßÀ ÔşÀ ÕBÀ ÕcÀ ÕxÀ Õ™À Õ¹À ÖÀ Ö[À ÖfÀ ÖlÀ Ö}À ÖÀ Ö§À ÖÀÀ ×À ×ZÀ ×¢À ×¯À ×üÀ Ø.À Ø€À ØÙÀ Ù*À Ù0À Ù4À Ù5À Ù‡À ÙÛÀ Ú'À Ú-À ÚUÀ Ú¢À ÚÆÀ Û À Û$À ÛOÀ ÛtÀ ÛºÀ Û¾À Û¿À ÛùÀ ÛÿÀ Ü5À Ü;À ÜKÀ ÜQÀ ÜÀ ÜÅÀ Ü÷À İ?À İVÀ İ†À İŠÀ İ¨À İ¸À İÆÀ İõÀ Ş,À Ş5À ŞHÀ ŞRÀ ŞbÀ Ş‡À Ş±À ßÀ ßÀ ß#À ß6À ß@À ßxÀ ß|À ß}À ßÄÀ ßÖÀ ßÜÀ àÀ àÀ àXÀ àyÀ àĞÀ àòÀ àöÀ áÀ ádÀ á„À á¢À áĞÀ áØÀ áåÀ â+À â1À â5À â6À âqÀ âwÀ â¾À âØÀ âŞÀ âìÀ ãÀ ã3À ãEÀ ã_À ã¯À ãºÀ ãÂÀ ãÌÀ ãÒÀ ãâÀ ãèÀ ä#À äDÀ ä›À ä½À äÁÀ äéÀ åÀ å À åNÀ åVÀ åcÀ å¤À åúÀ æ%À æiÀ æqÀ æwÀ æ{À æ|À æ»À æÁÀ çÀ çWÀ çˆÀ ç¢À çéÀ çíÀ èÀ èXÀ è\À è]À èrÀ è´À è¸À èÔÀ éÀ éÀ éÀ éoÀ éuÀ éÆÀ êÀ êKÀ êZÀ êªÀ ê÷À ë&À ë^À ë–À ëšÀ ëÀÀ ëÁÀ ëÍÀ ëãÀ ìÀ ì;À ìAÀ ìqÀ ìŒÀ ì¨À ìÑÀ ìïÀ íÀ íKÀ íZÀ í}À í…À í®À íÓÀ íÛÀ îÀ îDÀ î™À î£À î²À îØÀ îàÀ îøÀ îşÀ ïÀ ïNÀ ïfÀ ïlÀ ïœÀ ïÄÀ ïÜÀ ïâÀ ğÀ ğ?À ğWÀ ğ]À ğ|À ğ¹À ğÑÀ ğ×À ğõÀ ñ0À ñHÀ ñNÀ ñ}À ñ¾À ñÖÀ ñÜÀ ñöÀ ò)À òAÀ òGÀ òfÀ ò£À ò»À òÁÀ òÙÀ óÀ óÀ ó+À ó_À óeÀ ó|À óšÀ óÀ ó À ó¡À óìÀ óğÀ ô3À ô}À ôÈÀ ôúÀ ôşÀ õ1À õ5À õmÀ õÀ õ›À õ¡À õîÀ öÀ ö À öSÀ ö[À ö¨À ööÀ ÷.À ÷gÀ ÷wÀ ÷yÀ ÷zÀ ÷¼À ÷ÔÀ ø"À øoÀ ø·À ùÀ ùÀ ù/À ù5À ù“À ùÀ ùŸÀ ù¿À ùÅÀ úÀ ú1À ú2À úOÀ úUÀ ú¥À úàÀ úñÀ úòÀ ûÀ ûÀ ûjÀ û—À ûÀ û²À û¸À ûÆÀ ûäÀ üÀ ü
À üRÀ üpÀ üÆÀ ıÀ ı)À ıCÀ ı]À ıwÀ ı‘À ıœÀ ı¤À ı®À ıÄÀ ıÅÀ ı×À ıİÀ ş-À ş{À şÇÀ ÿÀ ÿ]À ÿcÀ ÿ´À ÿÀÀ ÿÆÀ ÿÖÀ ÿÜÀ ;À €À ‡À ‰À ŠÀ ÉÀ ÜÀ*ÀzÀ­À¹ÀºÀ	ÀXÀ‹À—À˜ÀèÀ/À~À¹ÀÈÀÊÀËÀ÷À0À1ÀgÀkÀ«À¯ÀıÀÀÀhÀ·ÀşÀFÀ”À¢À¦ÀòÀAÀˆÀŒÀšÀÀÀ[ÀÀĞÀŞÀ	À	 À	HÀ	[À	eÀ	„À	À	¢À	£À	ÄÀ	àÀ	÷À	øÀ
6À
<À
‡À
ÉÀ
êÀÀÀQÀWÀ¢ÀåÀÀ.À/ÀJÀKÀÀ¢À£ÀåÀùÀúÀÀaÀ’À˜ÀéÀÀ
ÀUÀ ÀïÀÀ"À=ÀjÀ–À¬ÀãÀøÀÀ3À9À=À>À‚ÀˆÀÖÀìÀÀÀ+ÀGÀZÀdÀÒÀÖÀ×ÀÀÀ^ÀnÀtÀ¹ÀÀOÀUÀ¢À»ÀÀZÀ¤ÀğÀEÀrÀ À¤À¥ÀáÀçÀ3À‚À®À´ÀÀQÀ„ÀĞÀıÀÀNÀmÀ{À›À©ÀÑÀàÀ.À4À8À9ÀŠÀ¬À²ÀòÀ(ÀFÀVÀªÀ½ÀÇÀÚÀŞÀßÀÀÀeÀ´ÀÀQÀÀëÀ7ÀUÀ[À©ÀÒÀØÀ ÀqÀ‡ÀÀÃÀÉÀ×ÀòÀÀ*À0ÀhÀ§ÀÆÀ À !À 3À SÀ £À ñÀ!À!MÀ!XÀ!yÀ!À!‡À!©À!İÀ"(À"SÀ"–À"ÚÀ#À#0À#6À#rÀ#¢À#¨À#ÅÀ#ßÀ#åÀ$À$%À$@À$HÀ$NÀ$jÀ$À$“À$®À$´À$×À%À%À% À%KÀ%SÀ%]À%cÀ%¨À%öÀ&À&,À&AÀ&YÀ&„À&ÕÀ'#À'eÀ'nÀ'tÀ'“À'¾À'ÂÀ'ÃÀ(À(UÀ([À(¨À(òÀ)BÀ)‘À)ÛÀ*(À*aÀ*bÀ*nÀ*˜À*šÀ*›À*µÀ*êÀ+3À+NÀ+SÀ+¡À+ÃÀ+ßÀ+íÀ+îÀ,=À,WÀ,XÀ,¨À,ÃÀ,ÄÀ-À-OÀ-À-½À-ÇÀ-ÏÀ-ÓÀ-ÔÀ.À.fÀ.²À.³À.ÍÀ.àÀ.øÀ/À/À/iÀ/À/ËÀ0À0
À0 À00À04À05À0€À0¥À0çÀ1À1À1-À1.À1tÀ1“À1”À1 À1ĞÀ1ÒÀ1ÓÀ2À2AÀ2BÀ2vÀ2zÀ2¶À2ĞÀ2ÔÀ3À3gÀ3µÀ3ûÀ4FÀ4oÀ4sÀ4¬À4°À4¼À4ÈÀ5À5CÀ5aÀ5®À5ùÀ6À6bÀ6À6¢À6¨À6°À6´À6ÊÀ6ÎÀ6ÚÀ6çÀ7!À7bÀ7¢À7áÀ8-À8GÀ8–À8ŞÀ8ÿÀ9À9À9À9iÀ9…À9‹À9ÉÀ9åÀ:#À:$À:SÀ:YÀ:¦À:ÁÀ:ÂÀ:ëÀ:ñÀ;9À;?À;‹À; À;¢À;£À;ÃÀ;ÇÀ<À<)À<-À<eÀ<‚À<™À<¿À<ÕÀ<ÖÀ=À=À=?À=dÀ=À=€À=¨À=®À=òÀ=øÀ>IÀ>OÀ>À>ÀÀ>äÀ>åÀ?5À?XÀ?^À?©À?ÎÀ?àÀ?âÀ?ãÀ@/À@4À@}À@˜À@À@ÖÀ@ôÀAÀA	ÀA#ÀA$ÀA0ÀAkÀAlÀAÀÀAàÀAáÀB ÀBÀBÀBWÀBXÀB±ÀBÖÀB×ÀBãÀCÀCVÀC¾ÀCÙÀCüÀD]ÀDgÀD ÀD¯ÀD×ÀEÀEUÀEaÀEiÀEqÀEŠÀE¨ÀE®ÀEËÀEÏÀEĞÀFÀF]ÀF­ÀF®ÀFºÀFüÀGÀGÀGÀG=ÀGAÀGÀGàÀH.ÀHQÀHUÀH§ÀHõÀIÀIPÀIuÀIÆÀJÀJXÀJ¨ÀJ»ÀJ¿ÀK
ÀKTÀK¤ÀKóÀL?ÀLÀLßÀM'ÀMcÀMgÀM±ÀMûÀNKÀN‡ÀN‹ÀNØÀNäÀO	ÀOÀO1ÀOFÀOdÀOoÀO»ÀOåÀOñÀPÀP/ÀPSÀPXÀPZÀP[ÀP~ÀP‚ÀPÑÀQ!ÀQoÀQ’ÀQ–ÀQêÀR8ÀRqÀRuÀRÇÀSÀS#ÀS'ÀSrÀS¼ÀTÀT[ÀT§ÀTøÀUGÀUÀUËÀUÏÀVÀVcÀV³ÀVïÀVóÀW@ÀWLÀWPÀWuÀWyÀWÉÀXÀX_ÀX‡ÀX¶ÀXÒÀXæÀXûÀYÀYÀYFÀYRÀY‘ÀY®ÀYòÀZÀZ$ÀZkÀZ•ÀZŸÀZ§ÀZïÀZöÀZûÀZıÀZşÀ[!À[%À[pÀ[tÀ[ÁÀ\À\OÀ\SÀ\œÀ\ëÀ]À]À]SÀ] À]ìÀ^-À^|À^ÌÀ_À_lÀ_£À_§À_ñÀ`;À`oÀ`sÀ`ÀÀ`ÌÀ`ĞÀ`õÀ`ùÀaIÀa”ÀaßÀbÀb4ÀbPÀbzÀb…Àb¯ÀbûÀcÀc^ÀcÀcŞÀdÀd+ÀdRÀdYÀdgÀd}ÀdÀdƒÀd„ÀdÔÀdöÀdøÀdùÀeHÀeqÀeuÀeƒÀe‡ÀeÑÀeòÀf.ÀfDÀf[Àf^Àf_Àf¤Àf¨Àf¶ÀfºÀgÀgDÀglÀg„Àg°Àg¶ÀhÀhÀhPÀh|ÀhªÀh«ÀhÙÀhßÀi.Ài~ÀiÌÀjÀjDÀjJÀj€Àj”Àj•ÀjÄÀjÊÀkÀkiÀk¶ÀlÀl.Àl4ÀljÀlÀl€ÀlŒÀlÈÀlÊÀlËÀmÀmÀmgÀmµÀmüÀnFÀnsÀnuÀnvÀnÔÀoÀoGÀodÀofÀogÀo¤Ào¨ÀoöÀpAÀpYÀp]Àp©ÀpúÀq9Àq=ÀqˆÀqÒÀr"ÀrqÀr½ÀsÀs]Às¥ÀsáÀsåÀt/ÀtyÀtÉÀuÀu!Àu5ÀuBÀuPÀufÀu‰ÀušÀu®ÀuÃÀuáÀuæÀvÀv7Àv;ÀvYÀvÀv“Àv”Àv¼ÀváÀwÀw/ÀwEÀw]ÀwyÀw–ÀwŸÀw Àw½ÀxÀx-Àx7Àx€Àx¬Àx¶Àx¾Àx¿ÀxĞÀxëÀyÀy5Ày?Ày]Ày¡Ày¼ÀyØÀyãÀz	Àz%ÀzEÀzFÀzrÀz~Àz„Àz†Àz‡ÀzÔÀzäÀzèÀ{À{3À{}À{ƒÀ{ÔÀ|#À|rÀ|À|£À|ÛÀ|æÀ|çÀ})À}/À}€À}ÑÀ}×À~À~À~À~À~BÀ~FÀ~TÀ~XÀ~§À~ÍÀ~âÀÀÀjÀµÀöÀüÀ€À€À€aÀ€{À€‰À€ØÀ€şÀÀRÀ ÀºÀÀÀĞÀ‚À‚À‚_À‚eÀ‚³À‚şÀƒ3Àƒ<Àƒ‡ÀƒÀÀƒÆÀ„À„hÀ„nÀ„~À„»À„ÂÀ„öÀ„üÀ…JÀ…•À…ÖÀ…ÜÀ…ìÀ…òÀ†;À†TÀ†iÀ†kÀ†lÀ†½À†ÚÀ‡*À‡MÀ‡SÀ‡£À‡ìÀˆ=Àˆ†Àˆ Àˆ¦ÀˆõÀ‰AÀ‰{À‰À‰ÌÀ‰ñÀŠÀŠÀŠÀŠ^ÀŠ¨ÀŠÄÀŠŞÀŠßÀŠëÀ‹3À‹NÀ‹PÀ‹QÀ‹ƒÀ‹‡À‹ÌÀ‹ĞÀŒÀŒRÀŒfÀŒjÀŒ°ÀŒÛÀŒßÀÀaÀ‰ÀÀÑÀ
À À@ÀAÀiÀoÀ¼ÀÀ.ÀbÀ’À©À­À®ÀìÀòÀ7ÀTÀxÀyÀ®ÀÑÀÒÀ‘À‘GÀ‘HÀ‘À‘œÀ‘¿À‘ÀÀ’À’9À’fÀ’gÀ’ªÀ’êÀ’ùÀ’ÿÀ“pÀ“åÀ”+À”,À”oÀ”¶À”ûÀ•À•VÀ•WÀ•œÀ•ãÀ•òÀ•øÀ–eÀ–ÖÀ—(À—)À—nÀ—µÀ—úÀ˜À˜iÀ˜jÀ˜°À˜ôÀ™9À™€À™¥À™«ÀšÀš‰ÀšÏÀšĞÀ›À›ZÀ›ŸÀ›æÀœ,ÀœTÀœ¢Àœ£ÀœæÀÀÀQÀuÀ{ÀÂÀÀIÀÀÔÀŸÀŸFÀŸLÀŸ‘ÀŸÇÀ À À hÀ ­À ³À¡À¡KÀ¡À¡¶À¡¼À¢À¢PÀ¢œÀ¢¢À¢ÅÀ¢æÀ£À£À£7À£=À£>À£À£ÒÀ£ØÀ¤À¤À¤aÀ¤¯À¤òÀ¥<À¥BÀ¥…À¥ÓÀ¦ À¦7À¦RÀ¦lÀ¦À¦¨À¦ÃÀ¦ŞÀ¦äÀ¦åÀ§,À§CÀ§^À§_À§¡À§ÏÀ§ÕÀ¨'À¨uÀ¨À¨‘À¨ÙÀ©À©UÀ©–À©ÜÀª ÀªdÀªpÀªvÀªâÀ«RÀ«XÀ«ÈÀ¬<À¬|À¬}À¬ÏÀ¬İÀ¬ãÀ­2À­WÀ­]À­¤À­ØÀ­ÙÀ®À®^À®nÀ®ŒÀ®À®ÓÀ®ÙÀ¯&À¯tÀ¯ŸÀ¯áÀ¯âÀ°(À°gÀ°¤À°ªÀ°÷À±HÀ±sÀ±¼À±½À²À²CÀ²SÀ²TÀ²™À²İÀ²øÀ³À³	À³YÀ³¦À³ÅÀ³ËÀ´À´À´^À´}À´~À´¾À´íÀµ
ÀµÀµKÀµ{Àµ¢Àµ£ÀµØÀµŞÀ¶.À¶{À¶ÆÀ·À·À·\À·«À·ıÀ¸JÀ¸”À¸âÀ¸ğÀ¹5À¹IÀ¹JÀ¹–À¹©À¹¯À¹ÿÀºMÀº‡ÀºĞÀºüÀ»MÀ»`À»fÀ»İÀ»áÀ»âÀ¼1À¼bÀ¼hÀ¼´À¼üÀ½KÀ½šÀ½äÀ¾À¾"À¾mÀ¾ºÀ¿À¿7À¿=À¿À¿ÚÀÀ*ÀÀmÀÀºÀÁÀÁVÀÁ¦ÀÁõÀÁûÀÂIÀÂ˜ÀÂÌÀÂÒÀÃ#ÀÃnÀÃ¨ÀÃªÀÃ«ÀÃõÀÄÀÄAÀÄBÀÄÀÄÕÀÄèÀÄéÀÅ"ÀÅBÀÅCÀÅŠÀÅ°ÀÅ±ÀÅ½ÀÆÀÆÀÆNÀÆOÀÆ£ÀÆÂÀÆÃÀÇÀÇIÀÇJÀÇVÀÇ´ÀÇàÀÇáÀÇíÀÈSÀÈ‰ÀÈŠÀÈ–ÀÈôÀÉ ÀÉ!ÀÉ-ÀÉ“ÀÉÉÀÉÊÀÉÖÀÊOÀÊÀÊŸÀÊ«ÀË,ÀËWÀËŠÀË‹ÀË—ÀÌÀÌqÀÌrÀÌ~ÀÍÀÍhÀÍiÀÍuÀÍìÀÎ;ÀÎ<ÀÎHÀÎÇÀÏÀÏÀÏ+ÀÏ}ÀÏÀÏüÀĞ ÀĞÀĞ„ÀÑ
ÀÑÀÑÀÑ:ÀÑ[ÀÑvÀÑ‘ÀÑ¬ÀÑ³ÀÑ×ÀÑûÀÒUÀÒYÀÒZÀÒàÀÓmÀÓnÀÓzÀÓ•ÀÓ¯ÀÓĞÀÓëÀÔÀÔ!ÀÔ(ÀÔQÀÔuÀÔáÀÔåÀÔæÀÕtÀÕ™ÀÕ¯ÀÕÅÀÕÛÀÕñÀÖÀÖÀÖ4ÀÖ5ÀÖAÀÖ]ÀÖ}ÀÖ¹ÀÖ½ÀÖ¾À×-À×}À×~À×ŠÀ×¦À×ÆÀØÀØÀØÀØvÀØÆÀØÇÀØÓÀÙÀÙ4ÀÙ‡ÀÙ‹ÀÙŒÀÚ
ÀÚÀÚ€ÀÚŒÀÚÁÀÚóÀÚ÷ÀÚøÀÛJÀÛ‡ÀÛˆÀÛ”ÀÛ³ÀÛÕÀÛùÀÛıÀÛşÀÜHÀÜvÀÜwÀÜƒÀÜÆÀÜêÀİÀİ-Àİ{ÀİˆÀİÃÀİÉÀİÍÀİÎÀŞ.ÀŞpÀŞqÀŞãÀßCÀßDÀßPÀßšÀß¾ÀßÙÀàÀàUÀàbÀà¤ÀàªÀà®Àà¯ÀáÀá_Àá`ÀáØÀâ>Àâ?ÀâKÀâ˜Àâ±Àâ²Àâ¾ÀãÀã$Àã%Àã1ÀãQÀãtÀãÀã¢Àã£ÀäÀä2Àä3Àä?Àä]ÀäÀä¯Àä×ÀäèÀäìÀäíÀåDÀå€ÀåÀåÀåµÀåÛÀæ	Àæ(Àæ9Àæ=Àæ>Àæ‘ÀæĞÀæÑÀæİÀæòÀçÀç[Àç_Àç`Àç¥ÀçÊÀçËÀè,ÀèvÀèwÀèƒÀè¾ÀèëÀèïÀèñÀèòÀé4Àé8ÀéFÀé¤Àé´ÀéåÀéëÀêÀê>Àê?Àê„ÀêŠÀêßÀëÀëHÀëÀë”Àë•Àë´ÀëºÀìÀìQÀìjÀìkÀì˜ÀìÀìïÀíAÀí]ÀítÀíuÀí¥Àí«ÀíûÀîJÀîfÀîlÀîºÀï	ÀïXÀï¦Àï·ÀïüÀğ5Àğ7Àğ8Àğ€Àğ„ÀğÕÀñ!ÀñgÀñkÀñ±ÀñµÀòÀòPÀònÀòrÀò¼ÀóÀó-ÀómÀóœÀóòÀóóÀôÀôÀô(ÀôZÀô\Àô]Àô¬ÀôÆÀõÀõ,Àõ-ÀõHÀõkÀõlÀõxÀõ“ÀõÆÀõçÀõÿÀöbÀö¾À÷2À÷;À÷AÀ÷[À÷_À÷`À÷lÀ÷€À÷§À÷×À÷êÀ÷ğÀøÀøÀøÀø Àø!Àø`ÀødÀø¬Àø÷ÀùEÀùiÀùmÀù»Àú
ÀúVÀú¦ÀúôÀûÀûÀû3ÀûqÀû³ÀûæÀûçÀüÀü#ÀülÀü¶ÀüÿÀıÀıÀı<ÀıBÀıÀıÖÀş&ÀşEÀş\Àş]ÀşˆÀşÀşŞÀÿ%ÀÿsÀÿÂÀÿûÀ À OÀ ŸÀ îÀ'ÀAÀBÀaÀbÀ²ÀÙÀßÀ.À{À“À™ÀÎÀÔÀÀLÀÀ‘À’ÀÛÀáÀ#ÀgÀµÀÀÀÀ#À‹ÀÀÀÉÀşÀ#À'À(À}À¿ÀÀÀäÀZÀ|À€ÀÀâÀÀÀTÀ„ÀÒÀ	À	PÀ	lÀ	À	ŒÀ	¢À	ÈÀ	íÀ	öÀ	üÀ
 À
À
\À
¢À
£À
âÀ	ÀÀ­ÀğÀÀÀÀvÀäÀåÀ	ÀÀ£À§À¨ÀÀ3À4À_ÀdÀ¹ÀãÀûÀ'À7ÀTÀZÀkÀoÀpÀÊÀğÀñÀ=ÀCÀ„À¤À¦À§ÀÜÀÀ)ÀaÀbÀ¯ÀòÀüÀıÀKÀ—ÀÅÀÎÀÏÀÀmÀ°À¹ÀºÀ
ÀÀ!À#À$ÀqÀÁÀÓÀ×À(À;À†ÀŒÀÀÀÆÀÀÀlÀºÀ
ÀÀ!ÀpÀvÀœÀ¢À²À¸ÀÀÀ/À@ÀEÀFÀ`ÀwÀxÀ¾À	À3ÀiÀjÀvÀ™À¸ÀÚÀıÀÀÀÀAÀBÀNÀŸÀ¡À¢ÀóÀBÀÀÜÀÀÀZÀgÀ’ÀßÀ0ÀtÀzÀËÀÀFÀÀ™À¹ÀÑÀíÀîÀ8ÀÀ”ÀšÀçÀ À À HÀ {À ®À áÀ!À!À!iÀ!µÀ!»À!ÉÀ"	À" À"7À"NÀ"eÀ"oÀ"yÀ"À"‘À"—À"¸À"¾À"ÌÀ#
À#&À#BÀ#^À#zÀ#„À#À#”À$À$!À$/À$lÀ$À$²À$ÕÀ$øÀ%À%À%À%›À%¡À%¯À%ğÀ&À&<À&bÀ&ˆÀ&’À&œÀ&ÌÀ&ãÀ&şÀ'À'6À'7À'ƒÀ'“À'»À'ÒÀ'íÀ(À(.À(/À(}À(˜À(ÀÀ(×À(òÀ)
À)3À)4À)KÀ)jÀ)‰À)œÀ)À)ÍÀ*À*FÀ*À*ØÀ*ÙÀ*ñÀ*ıÀ+JÀ+KÀ+tÀ+‰À+ À+ÔÀ+ëÀ+õÀ,À,6À,dÀ,‚À,™À,£À,îÀ-À-<À-qÀ-•À-ÊÀ-ÙÀ.À.!À.%À.&À.2À.UÀ.À.•À.›À.»À.ÛÀ/À/4À/_À/cÀ/dÀ/pÀ/…À/¯À0À0À0À0#À0DÀ0YÀ0pÀ0©À0ÂÀ0ñÀ1À1GÀ1kÀ1À1¬À1ÑÀ1×À1ÛÀ1ÜÀ1èÀ1şÀ2À2*À2cÀ2|À2«À2ÏÀ3À3%À3WÀ3fÀ4À4À4À4À4À4MÀ4QÀ4¡À4ìÀ5>À5TÀ5À5±À5éÀ5ıÀ6>À6BÀ6CÀ6gÀ6¡À6µÀ6îÀ6òÀ7!À7fÀ7zÀ7˜À7œÀ7À7ÌÀ8À8%À8CÀ8GÀ8HÀ8–À8¼À8ÙÀ8ÚÀ9À9:À9;À9 À9ÕÀ9ÖÀ:)À:ZÀ:[À:¿À:éÀ:êÀ;NÀ;xÀ;zÀ;{À;®À;²À;ÀÀ;ÄÀ<À<`À<¯À<×À=#À=NÀ=kÀ=½À=êÀ=ëÀ>'À>–À>ïÀ>óÀ>ôÀ?AÀ?‡À?ÖÀ@À@À@À@bÀ@´ÀAÀADÀAHÀAIÀAÀA“ÀAáÀB+ÀB]ÀB©ÀBÉÀCÀCÀCoÀCsÀCtÀC¾ÀCÄÀDÀDJÀDoÀDËÀEÀEÀEÀEiÀE¶ÀEİÀEŞÀF'ÀF_ÀFÀFÀF‚ÀF´ÀFÿÀG ÀGÀG?ÀG@ÀGaÀG¥ÀG±ÀGèÀGéÀGõÀH8ÀH9ÀHEÀH‰ÀHŠÀH–ÀH¹ÀHåÀHùÀHÿÀI&ÀIVÀIˆÀIŒÀIÀI™ÀIáÀIãÀIäÀJÀJ€ÀJÀJ˜ÀJ¯ÀJÊÀJËÀJßÀK!ÀK-ÀKdÀKeÀK€ÀK˜ÀKÃÀKğÀL!ÀLLÀLRÀLVÀLWÀLcÀL­ÀL®ÀLºÀMÀMÀMÀM5ÀMaÀMuÀM{ÀM¨ÀMÊÀMìÀNÀNÀNÀN$ÀNWÀNYÀNZÀNŒÀNÔÀNÕÀNíÀOÀOÀOJÀOVÀOÀOÀOšÀOÚÀOÛÀOçÀP(ÀP)ÀP5ÀPXÀP„ÀP˜ÀPÀPÅÀPéÀQÀQÀQÀQÀQTÀQVÀQWÀQˆÀQÏÀQĞÀQèÀR ÀRÀRDÀRPÀR‡ÀRˆÀR”ÀRÓÀRÔÀRàÀS ÀS!ÀS-ÀSPÀS|ÀSÀS–ÀS¼ÀSàÀTÀT	ÀT
ÀTÀTKÀTMÀTNÀTÀTÒÀTÓÀTôÀUÀUÀU0ÀUvÀU‚ÀU¹ÀUºÀUÆÀV0ÀV1ÀV=ÀV“ÀV”ÀV ÀVÃÀVïÀWÀW	ÀW1ÀW]ÀWŠÀWÀWÀW›ÀWØÀWÚÀWÛÀXÀXÀXnÀXÁÀYÀY@ÀY|ÀY±ÀYÊÀYŞÀZ"ÀZ&ÀZ'ÀZtÀZºÀZëÀ[À[À[IÀ[MÀ[NÀ[’À[äÀ\À\,À\@À\pÀ\tÀ\uÀ\¹À\¿À]À]WÀ]ˆÀ]¡À]ÅÀ^À^	À^À^WÀ^[À^\À^À^ÁÀ^ÚÀ^îÀ_4À_XÀ_\À_]À_À_ÄÀ_İÀ_ñÀ`GÀ`À`ÖÀ`ÚÀ`ÛÀaÀa;Àa<ÀaªÀañÀaòÀb[Àb˜Àb™ÀcÀc=Àc>Àc˜ÀcİÀcŞÀd=ÀdzÀd{ÀdëÀe>Àe?ÀeÀe³ÀeĞÀeÒÀeÓÀfÀfNÀfƒÀfÍÀféÀgÀgÀgÀg3Àg4Àg]ÀgcÀg´ÀgÏÀgçÀg÷ÀhÀh+Àh5ÀhJÀhNÀhOÀhŸÀhÂÀhÈÀiÀi_Ài¨ÀiòÀiøÀj=ÀjPÀj`ÀjÀjœÀj¯Àj¹Àj½Àj¿ÀjÀÀkÀk.Àk2ÀkÀkÍÀlÀljÀlnÀlÃÀmÀmpÀmÈÀnÀnDÀnHÀn¢ÀnÇÀnËÀnÙÀnİÀo!ÀokÀo»ÀoåÀp/ÀpwÀpÀpëÀq9ÀqSÀqÀqÀqøÀqşÀrJÀrÀr–ÀrîÀsÀsÀswÀsÚÀt<ÀtEÀtFÀt—ÀtÀtõÀuSÀuÀu…ÀußÀv<ÀvBÀv¨ÀwÀwsÀwÀw€ÀwÓÀwÙÀx1Àx‰ÀxßÀxúÀy ÀyZÀy°ÀyÅÀyËÀz/Àz“ÀzöÀ{ À{À{AÀ{GÀ{¡À{üÀ|À|À|kÀ|‹À|‘À|ôÀ}WÀ}¹À}ÂÀ}ÄÀ}ÅÀ}öÀ~À~PÀ~yÀ~šÀ~À~¯À~±À~²À~æÀÀHÀqÀÀ²ÀÖÀùÀ€À€7À€;À€LÀ€NÀ€OÀ€ŒÀ€®À€ĞÀ€ıÀÀ/ÀHÀaÀrÀtÀuÀ½ÀÁÀ‚À‚&À‚*À‚8À‚<À‚²À‚¶À‚ÛÀƒÀƒÀƒeÀƒ¶À„ À„OÀ„ À„ñÀ…AÀ…cÀ…iÀ…¸À…îÀ…ôÀ†WÀ†ºÀ‡À‡„À‡ŠÀ‡ÕÀˆÀˆ6Àˆ<Àˆ‰ÀˆÜÀ‰À‰/À‰@À‰OÀ‰iÀ‰‡À‰¯À‰ÉÀ‰îÀŠÀŠMÀŠ`ÀŠÀŠÑÀ‹À‹vÀ‹ŠÀ‹åÀ‹éÀ‹êÀŒ5ÀŒUÀŒ[ÀŒªÀŒûÀEÀ”ÀåÀ6À†À¨À®ÀüÀ2À8À›ÀşÀbÀÈÀÎÀ‘À‘eÀ‘€À‘†À‘ÓÀ’&À’fÀ’lÀ’¸À“À“PÀ“À“íÀ”À”%À”8À”KÀ”eÀ”ƒÀ”«À”ÅÀ”ØÀ”õÀ•À•XÀ•kÀ•˜À•ÕÀ–=À–>À–£À–ÿÀ—CÀ—YÀ—ÃÀ—ĞÀ˜9À˜OÀ˜ÛÀ˜áÀ˜åÀ˜æÀ™6À™TÀ™ZÀ™¥À™óÀš.Àš4ÀšƒÀšÔÀ›À›mÀ›¾ÀœÀœ_ÀœÀœ‡Àœ×ÀÀÀ€ÀâÀEÀªÀ°ÀÿÀŸOÀŸrÀŸxÀŸÅÀ À XÀ jÀ }À —À µÀ İÀ úÀ¡À¡7À¡^À¡„À¡ÀÀ¡ÓÀ¢ À¢=À¢¥À¢¹À£.À£2À£3À£pÀ£À£‘À¤ À¤ƒÀ¤„À¥À¥ À¥6À¥LÀ¥aÀ¥yÀ¥˜À¥¬À¥ÉÀ¥ÊÀ¦jÀ¦ˆÀ¦À¦²À¦ÌÀ¦ßÀ¦òÀ§
À§"À§AÀ§UÀ§rÀ§sÀ§ùÀ¨À¨+À¨AÀ¨YÀ¨xÀ¨ŒÀ¨¥À¨¼À¨ØÀ¨ÙÀ¨üÀ©2À©PÀ©pÀ©ÈÀ©ĞÀ©İÀªÀªiÀªqÀªwÀª{Àª}Àª~Àª¼ÀªäÀ«
À«À«LÀ«›À«áÀ¬À¬À¬iÀ¬¸À¬ÆÀ¬ÌÀ­À­YÀ­†À­ŒÀ­ÒÀ®"À®oÀ®ŒÀ®¨À®öÀ¯À¯À¯AÀ¯QÀ¯qÀ¯¯À¯µÀ¯ÉÀ°<À°UÀ°sÀ°yÀ°}À°~À°ŠÀ°À°²À°ÂÀ°ÆÀ°ÇÀ±À±'À±(À±¤À²À²À²`À²…À²ÍÀ²éÀ²ëÀ²ìÀ³6À³KÀ³OÀ³yÀ³ÉÀ´À´#À´SÀ´gÀ´›À´¸À´×À´İÀ´íÀµ
ÀµÀµ'Àµ+Àµ,ÀµBÀµCÀµˆÀµÀµ×À¶À¶iÀ¶À¶½À·À·KÀ·•À·ÂÀ¸
À¸TÀ¸oÀ¸¤À¸ªÀ¸ÜÀ¹*À¹wÀ¹À¹•À¹™À¹šÀ¹ÓÀº$ÀºrÀºÂÀºÎÀ»À»MÀ»NÀ»ƒÀ»ÎÀ¼À¼HÀ¼šÀ¼¸À¼ÆÀ¼ÌÀ¼ÍÀ½À½ À½.À½4À½5À½qÀ½À½¿À½ÅÀ½ÉÀ½ÊÀ½æÀ¾À¾À¾"À¾<À¾=À¾À¾¡À¾¢À¾şÀ¿1À¿2À¿fÀ¿ºÀ¿¼À¿½À¿ğÀ¿ôÀÀ)ÀÀqÀÀÁÀÁÀÁ5ÀÁ9ÀÁ†ÀÁÓÀÂ!ÀÂjÀÂ£ÀÂÎÀÃ7ÀÃSÀÃbÀÃ„ÀÃ¡ÀÃ¨ÀÃ¬ÀÃ­ÀÃÉÀÃÊÀÄ
ÀÄ6ÀÄ7ÀÄkÀÄqÀÄ¿ÀÅÀÅXÀÅ¦ÀÅöÀÆ ÀÆ&ÀÆmÀÆsÀÆÀÆÀÆ¿ÀÆŞÀÆùÀÇÀÇ	ÀÇWÀÇaÀÇgÀÇuÀÇÆÀÇñÀÈ"ÀÈSÀÈYÀÈŒÀÈ×ÀÉ"ÀÉmÀÉ¸ÀÉ¾ÀÉåÀÊÀÊÀÊ!ÀÊ'ÀÊtÀÊÉÀÊÚÀÊàÀË*ÀËUÀËªÀËÆÀËÊÀËËÀÌÀÌÀÌ_ÀÌ¢ÀÌ¨ÀÌõÀÍÀÍGÀÍ›ÀÍÆÀÍÊÀÍËÀÎÀÎÀÎbÀÎ®ÀÎéÀÎõÀÏÀÏÀÏ?ÀÏOÀÏSÀÏTÀÏ¹ÀĞÀĞ ÀĞ‹ÀĞÈÀĞÉÀÑ%ÀÑJÀÑKÀÑÀÑºÀÑ¼ÀÑ½ÀÒÀÒÀÒ5ÀÒrÀÒ„ÀÒÌÀÒÙÀÒÚÀÓ(ÀÓ9ÀÓ:ÀÓ‹ÀÓ ÀÓ¦ÀÓñÀÔ/ÀÔpÀÔÀÔÀÔ‚ÀÔºÀÔ¾ÀÕÀÕSÀÕÀÕêÀÖ:ÀÖ`ÀÖdÀÖ±ÀÖÿÀ×NÀ×^À×bÀ×®À×ıÀØLÀØ™ÀØæÀÙ6ÀÙ…ÀÙÒÀÙíÀÙñÀÚ>ÀÚˆÀÚÕÀÚ÷ÀÚûÀÛJÀÛÀÛÜÀÜ-ÀÜ~ÀÜÎÀÜñÀİ(ÀİoÀİuÀİÃÀŞÀŞ^ÀŞ©ÀŞØÀŞŞÀß+ÀßTÀßZÀß«ÀßùÀàHÀà…Àà£Àà©ÀàøÀáGÀáMÀáŸÀáÈÀáÎÀâÀâoÀâÀÀãÀãZÀã¥ÀãğÀä ÀäÀäTÀä~Àä„ÀäÂÀäÈÀåÀåeÀå¶ÀæÀæ)Àæ5ÀæJÀæhÀæÀæ§Àæ¿ÀæÆÀçÀçPÀçVÀç­ÀèÀè
Àè%ÀèeÀè—Àè¶ÀéÀéIÀé”Àé¡Àé«Àé³Àé¹ÀéÿÀêOÀê|ÀêŠÀê¾ÀêßÀêíÀë$ÀëIÀëWÀëXÀëÈÀì
ÀìÀìÀìÀìfÀì•Àì›ÀìéÀí6Àí„ÀíÏÀíşÀîÀîQÀî›ÀîçÀï6ÀïIÀïOÀï ÀïïÀğ6Àğ‡ÀğØÀñ'Àñ^ÀñdÀñ³ÀòÀòSÀòœÀòÕÀòÛÀó+Àó|ÀóÍÀôÀôgÀô³ÀõÀõ1Àõ7Àõ…ÀõÕÀö$ÀöRÀöXÀö–Àö¦Àö»ÀöØÀöïÀ÷À÷-À÷4À÷YÀ÷ÉÀ÷ÏÀøÀø]ÀøcÀøºÀùÀùÀù2ÀùrÀù¨ÀùÇÀúÀú_ÀúªÀú·ÀúÁÀúÉÀúÏÀû#ÀûeÀûkÀûoÀûpÀûÒÀüÀü,Àü`ÀüÀüÎÀıÀıÀıRÀıuÀıˆÀı Àı°ÀıÈÀıÛÀıåÀıõÀıùÀıúÀşEÀşjÀş¯ÀşËÀşÌÀşæÀÿ0Àÿ6Àÿ„ÀÿšÀÿµÀÿÉÀÿÙÀÿõÀ À À ƒÀ ‡À ‰À ŠÀ ØÀ ÜÀÀ\ÀmÀÀ•ÀãÀ-ÀfÀlÀ¹ÀÀÀ(À)ÀcÀiÀ¯ÀµÀ÷ÀÀÀÀMÀSÀ•À«À¶À¸À¹ÀÀÀÀ2À@ÀxÀ†À‡ÀÀÀÍÀÏÀĞÀÀ	ÀPÀ”ÀÕÀÙÀ"ÀrÀ»ÀØÀÜÀ,ÀuÀªÀ®ÀûÀ	:À	RÀ	•À	³À	¹À
À
JÀ
šÀ
éÀ6ÀyÀÀÆÀÜÀ,À-ÀuÀ{À§À­À½ÀÃÀÀIÀXÀYÀªÀûÀJÀ“À¢À¨ÀôÀEÀ“ÀÛÀ)ÀsÀyÀÆÀÌÀğÀöÀDÀÀàÀ0ÀUÀ[À©ÀòÀCÀ‘ÀßÀ/ÀwÀ¤ÀªÀôÀÀÀ!ÀNÀvÀÀÍÀöÀ-ÀfÀ€ÀšÀ¢À¬À²ÀÀOÀÀ»ÀÁÀÏÀüÀ?ÀgÀ~À¾ÀõÀ.ÀHÀPÀZÀ`À±À÷ÀAÀGÀUÀ‚À™ÀíÀ&À@ÀWÀ¸ÀñÀÀÀÀ#ÀnÀ·ÀÀ@ÀFÀjÀpÀ¯ÀµÀÀQÀ¢ÀíÀ<ÀŠÀÕÀ  À qÀ ÂÀ İÀ ãÀ óÀ ùÀ!IÀ!kÀ!³À!ÉÀ!öÀ!÷À"7À"VÀ"\À"›À"¡À"êÀ#.À#@À#AÀ#À#êÀ$<À$BÀ$À$‡À$ÕÀ%%À%GÀ%iÀ%jÀ%­À%òÀ&9À&nÀ&tÀ&™À&¯À&°À' À'PÀ'xÀ'yÀ'ÈÀ(À(#À()À(oÀ(À(¨À(©À(şÀ)À)À)oÀ)»À*
À*3À*VÀ*WÀ*§À*âÀ+	À+
À+]À+³À+ÏÀ+ÕÀ,'À,uÀ,ÅÀ,òÀ-À-À-_À-vÀ-|À-ÒÀ-ØÀ.À."À.tÀ.¼À.åÀ.ëÀ/5À/IÀ/¤À/¥À/óÀ0À0À0oÀ0uÀ0¹À0¿À1À1YÀ1©À1ãÀ1äÀ22À2FÀ2LÀ2¢À2¨À2ìÀ2òÀ3DÀ3ŒÀ3µÀ3ìÀ3íÀ4>À4À4ãÀ4ôÀ4úÀ5NÀ5¡À5óÀ6BÀ6‘À6äÀ77À7†À7×À7óÀ7ùÀ81À8ƒÀ8×À9&À9hÀ9nÀ9¼À9ãÀ9éÀ9÷À:À:7À:pÀ:­À:ÌÀ;À;BÀ;QÀ;YÀ;cÀ;iÀ;ºÀ<À<aÀ<µÀ<ÅÀ<ËÀ=À=^À=’À=˜À=èÀ>7À>ƒÀ>›À>°À>ÍÀ>ÎÀ?À?qÀ?ÄÀ?ÊÀ@À@lÀ@¼ÀAÀA^ÀA²ÀBÀBÀBÀBMÀBpÀBqÀB´ÀC ÀCÀCQÀCRÀC¡ÀCéÀCïÀD=ÀDCÀD®ÀEÀEQÀERÀEÀE‡ÀEÌÀEçÀFÀFÀFWÀF’ÀF˜ÀGÀGrÀG›ÀGœÀGíÀH/ÀH5ÀH¡ÀIÀI=ÀI>ÀIÀIŞÀJÀJ
ÀJOÀJ‰ÀJŠÀJ×ÀK(ÀKKÀKQÀK¼ÀL+ÀLTÀLUÀL ÀLòÀMAÀMdÀMjÀM×ÀNHÀNÀN‚ÀN¾ÀNÄÀOÀOQÀO›ÀOïÀP@ÀPÀP¼ÀPÂÀQ1ÀQ¤ÀQªÀRÀR`ÀRaÀR–ÀRœÀRåÀS.ÀSZÀSƒÀS„ÀSÒÀT)ÀTdÀTeÀT´ÀU ÀUÀUUÀUnÀUtÀUÀÀV	ÀVÀV`ÀVaÀV¨ÀV®ÀVüÀWJÀW—ÀWäÀX'ÀX-ÀX{ÀXÈÀYÀY]ÀYnÀYµÀY¶ÀYıÀZÀZ;ÀZ<ÀZˆÀZ˜ÀZÀZéÀZöÀZüÀ[HÀ[•À[ÓÀ[ÙÀ\(À\tÀ\zÀ\ËÀ]À]eÀ]kÀ]µÀ^À^NÀ^ˆÀ^‰À^ÎÀ^ÔÀ_À_!À_gÀ_±À_·À_ÇÀ_ÍÀ`À`6À`€À`À`ÆÀ`ÌÀaÀaiÀaoÀaµÀaÿÀbÀbÀbÀbiÀb‡ÀbÓÀbÔÀcÀc$ÀcpÀcÀc‡ÀcĞÀd!Àd8Àd>Àd‡ÀdÕÀe!ÀeiÀe¹ÀfÀfOÀfÀfëÀg5ÀgoÀguÀgœÀg¢Àg²ÀhÀhOÀhvÀhÈÀiÀiÀiWÀi]Ài®ÀjÀjZÀj®ÀjæÀjìÀk<ÀkÀkÜÀl.Àl~ÀlÒÀmÀm$ÀmuÀmÅÀnÀnqÀn¡ÀnõÀoCÀo‡ÀoÀoàÀp/ÀpzÀpÈÀqÀq#ÀqwÀqÈÀrÀrÀrhÀrƒÀr‰Àr—Àr¬ÀrÕÀrèÀrÿÀsÀsÀs;ÀsqÀswÀsĞÀsîÀtÀtÀt'ÀtVÀtwÀt®ÀtâÀuÀu+ÀuGÀu„Àu¢ÀuÀÀvÀv4ÀvbÀvsÀvˆÀv¼ÀvÿÀw&Àw0Àw6ÀwEÀwMÀwWÀw]Àw¶Àw¼ÀwÊÀwßÀx#Àx6ÀxMÀx`ÀxyÀxÀx‡ÀxµÀxëÀxñÀyJÀyhÀy‰ÀyÀy¡ÀyĞÀyñÀz(Àz\Àz†Àz±ÀzÍÀ{
À{(À{FÀ{ŒÀ{ºÀ{èÀ{ùÀ|À|BÀ|…À|›À|ÏÀ}À}/À}9À}?À}NÀ}VÀ}`À}fÀ}¯À}úÀ~-À~3À~CÀ~IÀ~—À~®À~ÌÀ~ûÀÀDÀkÀŒÀ«À¬ÀğÀöÀ€GÀ€ À€óÀGÀ™ÀëÀ‚"À‚(À‚xÀ‚ÀÀ‚ÆÀƒÀƒWÀƒ‚ÀƒˆÀƒÖÀ„ À„&À„rÀ„¿À…À…À…pÀ…À…‡À…•À…ªÀ…ÓÀ…æÀ…ıÀ†À†À†9À†oÀ†uÀ†ÎÀ†ìÀ‡À‡À‡%À‡TÀ‡¤À‡óÀˆDÀˆ`Àˆ¥ÀˆïÀ‰'À‰RÀ‰ˆÀ‰±À‰ØÀŠÀŠ0ÀŠ6ÀŠÀŠêÀ‹DÀ‹†À‹²À‹ŞÀŒÀŒ\ÀŒhÀŒ‰ÀŒçÀŒñÀŒ÷ÀÀÀÀÀwÀ}À‹À ÀäÀ÷ÀÀ!À:ÀBÀHÀvÀ¬À²ÀÀ)ÀJÀPÀbÀ‘ÀáÀ0ÀÀÀâÀ‘,À‘jÀ‘¢À‘ÍÀ’À’,À’SÀ’ƒÀ’«À’±À“À“cÀ“¾À”À”fÀ”¬À”ÕÀ”ïÀ•*À•FÀ•bÀ•¦À•ÒÀ•şÀ–À–DÀ–{À–°À–åÀ–ëÀ—EÀ—ŸÀ—÷À˜>À˜mÀ˜yÀ˜šÀ™À™À™À™'À™/À™9À™?À™OÀ™UÀ™¢À™·À™ØÀšÀš.ÀšUÀšÀš£ÀšÅÀšÆÀ›À›À›iÀ›~À›„À›ªÀœÀœÀœÀœRÀœ“Àœ³ÀÀÀJÀiÀˆÀäÀèÀéÀSÀÈÀÉÀŸ%ÀŸÀŸÆÀŸëÀŸìÀŸøÀ FÀ ^À _À kÀ ™À ³À ïÀ üÀ¡ À¡…À¡‹À¡À¡À¡òÀ¢LÀ¢MÀ¢ÂÀ£EÀ£FÀ£RÀ££À£¾À£¿À£ËÀ¤*À¤UÀ¤VÀ¤bÀ¤¹À¤ØÀ¤ÙÀ¤åÀ¥HÀ¥yÀ¥zÀ¥†À¥ÅÀ¥ÆÀ¦%À¦SÀ¦TÀ¦`À¦¸À¦àÀ¦áÀ¦íÀ§KÀ§wÀ§xÀ§„À§¬À§ÌÀ¨
À¨À¨)À¨-À¨.À¨{À¨¬À¨­À¨¹À¨ØÀ©	À©%À©9À©=À©>À©À©ÂÀ©ÃÀ©ÏÀª+ÀªKÀª£Àª§Àª¨À«'À«–À«—À«£À«ŞÀ¬ À¬2À¬6À¬7À¬ŠÀ¬ËÀ¬ÌÀ¬ØÀ­À­AÀ­EÀ­FÀ­ŸÀ­ŞÀ­ßÀ­ëÀ®	À®8À®YÀ®ŸÀ®£À®¤À®úÀ¯3À¯4À¯@À¯dÀ¯“À¯ºÀ° À°À°À°aÀ° À°¡À°­À°âÀ±À±À±À±wÀ±­À±®À±ºÀ±ïÀ²À²/À²wÀ²{À²|À²ğÀ³hÀ³iÀ³uÀ³•À³ÂÀ³ÆÀ³ÇÀ´À´iÀ´jÀ´vÀ´ À´ÀÀµÀµÀµÀµ“À¶À¶À¶"À¶OÀ¶qÀ¶³À¶·À¶¸À·À·uÀ·vÀ·‚À·½À·ßÀ¸À¸YÀ¸]À¸^À¸ÄÀ¹8À¹9À¹EÀ¹oÀ¹À¹éÀ¹íÀ¹îÀºbÀºäÀºåÀºñÀ»+À»JÀ»ŒÀ»À»‘À»ÿÀ¼pÀ¼qÀ¼}À¼ÜÀ¼üÀ½xÀ½|À½}À¾À¾ À¾3À¾EÀ¾YÀ¾nÀ¾‡À¾ À¾¶À¾ÙÀ¾ôÀ¾õÀ¿À¿+À¿lÀ¿pÀ¿qÀ¿ÔÀÀ2ÀÀ3ÀÀ?ÀÀ{ÀÀÀÀÁÀÁCÀÁ\ÀÁªÀÁ°ÀÁ´ÀÁµÀÂ2ÀÂ¼ÀÂ½ÀÂÉÀÃÀÃ0ÀÃOÀÃnÀÃ¥ÀÃØÀÄ
ÀÄ>ÀÄsÀÄ¦ÀÄØÀÅÀÅAÀÅzÀÅ°ÀÅõÀÆÀÆ\ÀÆbÀÆfÀÆgÀÇÀÇ;ÀÇOÀÇeÀÇzÀÇ‘ÀÇ©ÀÇ¿ÀÇÔÀÇëÀÈÀÈ&ÀÈ@ÀÈ_ÀÈ`ÀÈlÀÈ´ÀÈÖÀÈøÀÉÀÉNÀÉ„ÀÉ¹ÀÉğÀÊ(ÀÊ[ÀÊÀÊÁÀÊöÀË/ÀËeÀËªÀËÃÀÌÀÌÀÌÀÌÀÌÍÀÌğÀÍÀÍÀÍ5ÀÍOÀÍjÀÍ€ÀÍ•ÀÍ¬ÀÍÄÀÍçÀÎÀÎ ÀÎ!ÀÎ-ÀÎSÀÎwÀÎ¤ÀÎ¨ÀÎ©ÀÎÿÀÏ5ÀÏ6ÀÏBÀÏ}ÀÏÉÀÏõÀĞÀĞDÀĞ|ÀĞ€ÀĞÀĞÀĞØÀÑ1ÀÑ5ÀÑ6ÀÑBÀÑÀÑ±ÀÑüÀÒÀÒIÀÒMÀÒNÀÒ³ÀÓ$ÀÓ%ÀÓ1ÀÓ|ÀÓ¡ÀÓìÀÓğÀÓñÀÔ_ÀÔÑÀÔÒÀÔŞÀÔüÀÕ+ÀÕNÀÕtÀÕ›ÀÕ¼ÀÕÜÀÕşÀÖAÀÖBÀÖjÀÖ”ÀÖßÀÖåÀ×2À×šÀ× À×¡À×èÀØ'ÀØ(ÀØRÀØrÀØ—ÀØ¼ÀØáÀÙÀÙ9ÀÙ[ÀÙ‘ÀÙÇÀÙûÀÚ/ÀÚUÀÚzÀÚ¡ÀÚÉÀÚÏÀÚĞÀÛ9ÀÛzÀÛ²ÀÛ³ÀÛÙÀÜ8ÀÜ~ÀÜ…ÀÜ†ÀÜŸÀÜíÀÜóÀÜ÷ÀÜøÀİÀİ%ÀİTÀİ{Àİ¢ÀİÌÀİğÀŞÀŞDÀŞEÀŞmÀŞšÀŞèÀŞîÀßÀßjÀßpÀß¬Àà%Àà+ÀàcÀàdÀàŠÀàßÀá)Àá0Àá1ÀáJÀá˜ÀáÀá¢Àá£Àâ7ÀâVÀâyÀâ“Àâ±ÀâÅÀâæÀâÿÀãÀã-ÀãKÀãLÀãXÀã°ÀäÀäÀäÀäsÀäÙÀäÛÀäÜÀå
ÀåIÀåJÀå’Àå–ÀåÊÀåÎÀæÀæWÀæ™Àæ²ÀæñÀæ÷ÀçBÀç„Àç¥ÀçÎÀçÏÀèÀèÀèaÀè¤ÀèÅÀèïÀèğÀéÀé ÀéoÀé¾ÀêÀê7Àê8ÀêzÀê€Àê·ÀëÀëUÀëÀë¤ÀëôÀìBÀìoÀìuÀìÅÀíÀí'Àí-Àí|Àí‘Àí½Àí¾ÀîÀî1ÀîCÀîDÀîŠÀîÀîŞÀîôÀïÀïÀïXÀï^Àï¯ÀïáÀğÀğÀğÀğTÀğÀğºÀğÀÀğöÀñÀñÀñÀñJÀñbÀñ‡Àñ»ÀñÁÀñ×Àò'ÀòDÀò^ÀòoÀò®Àò¸ÀòÂÀòÉÀòÍÀòÎÀó,ÀóÀó‚ÀóÀó»ÀóÓÀóøÀô,Àô2Àô3ÀôXÀô€Àô¶ÀôºÀô»ÀõÀõaÀõbÀõnÀõÀõ™Àõ©ÀõÁÀõÔÀõŞÀöÀöÀöÀöÀöaÀö†ÀöÊÀöæÀöçÀ÷À÷À÷À÷)À÷=À÷MÀ÷iÀ÷|À÷†À÷öÀ÷úÀ÷ûÀøÀøeÀøÀøÀø‘ÀøØÀøÜÀù!ÀùfÀù‡ÀùÈÀúÀú+ÀúaÀúbÀúÀú£ÀúçÀû.ÀûeÀûªÀûæÀûşÀûÿÀü.Àü4ÀüÀüÏÀıÀı.Àı0Àı1Àı‘ÀıÀÀıÁÀşÀş%Àş&Àş2Àş]Àş^ÀşjÀş…Àş ÀşäÀşêÀÿ!Àÿ=Àÿ\ÀÿpÀÿÃÀ 
À /À CÀ GÀ HÀ ¡À ÛÀ ÜÀ öÀ øÀ ùÀÀÀNÀ]ÀwÀ}ÀÈÀÀ-À3ÀtÀzÀÉÀâÀóÀ!À@À[À°À±ÀáÀÀ/ÀZÀÀ¨ÀÒÀÓÀÀ	À[À~À“À”ÀÓÀÙÀ'ÀsÀµÀÌÀÍÀÀ:À;ÀmÀsÀ¦À¬ÀÙÀLÀ‚À¶ÀºÀ»À÷ÀıÀ	0À	lÀ	mÀ	ºÀ	ÀÀ	ıÀ
LÀ
sÀ
yÀ
½ÀÀUÀwÀ‹ÀÀ´À÷ÀûÀüÀNÀ\À|ÀÀ£ÀÂÀéÀğÀôÀõÀ%À+ÀtÀ¹ÀİÀãÀ	ÀVÀ ÀëÀ7À…ÀÕÀ"ÀfÀlÀ»ÀÛÀğÀ(À=ÀTÀiÀxÀ™À¡À®ÀÅÀàÀïÀÀ9ÀpÀ²À½ÀÅÀËÀÏÀĞÀ	ÀÀWÀ]À€ÀÎÀğÀÀ	ÀÀ5ÀaÀœÀÌÀûÀÀ8À_ÀeÀœÀ½ÀÃÀÖÀÚÀÛÀçÀ
À,À?ÀEÀ`À€À¢ÀÍÀÑÀÒÀŞÀÀÀiÀ»À×ÀÀ,ÀFÀLÀMÀŠÀÀÀÁÀÛÀ(ÀZÀÀÀÉÀÀÀHÀuÀvÀ­ÀÚÀÛÀ*ÀdÀŠÀÀ‘À©À­À®ÀºÀıÀÿÀ ÀGÀKÀšÀ°ÀîÀÀÀ`ÀuÀ¶ÀûÀ-ÀZÀxÀ|À}À·À½ÀöÀ4ÀyÀÂÀ À 9À À ¼À íÀ!)À!DÀ!^À!ŠÀ!’À!»À!ÃÀ!ÇÀ!ÈÀ!ùÀ!ÿÀ"8À"uÀ"°À"áÀ#À#1À#KÀ#…À#À#¶À#¾À#ÂÀ#ÃÀ$À$[À$\À$¹À%À%À%cÀ%¯À%°À%äÀ&À&À&À&0À&1À&ZÀ&`À&±À&ÌÀ&äÀ&ôÀ'À'(À'2À'GÀ'KÀ'LÀ'œÀ'¿À'ÅÀ(À(\À(©À(öÀ)DÀ)bÀ)uÀ)…À)¤À)ÁÀ)ÔÀ)ŞÀ)îÀ)òÀ)óÀ*>À*cÀ*¯À*ËÀ*ÍÀ*ÎÀ+À+À+lÀ+„À+¥À+ŞÀ+äÀ,4À,†À, À,¦À,ôÀ-GÀ-ˆÀ-ÅÀ-äÀ.À.À.3À.FÀ.lÀ.À.À.ÛÀ/À/hÀ/šÀ/ÒÀ/òÀ/öÀ/÷À0!À0'À0bÀ0sÀ0tÀ0ŸÀ0¥À0àÀ0òÀ0óÀ1%À1+À1bÀ1{À1|À1ÌÀ1ïÀ1õÀ2@À2eÀ2wÀ2xÀ2ÆÀ2âÀ2èÀ33À3€À3‘À3—À3åÀ4À4VÀ4XÀ4YÀ4¹À4×À4ØÀ5À5À5gÀ5¹À5ÓÀ5ÙÀ6'À6zÀ6»À6øÀ7À74À7LÀ7eÀ7xÀ7À7¥À7¹À7ÏÀ8À8,À8zÀ8~À8À8áÀ94À95À9À:,À:-À:<À:=À:–À:²À:³À:¿À:êÀ:ëÀ:ûÀ:üÀ;VÀ;sÀ;tÀ;€À;®À;¯À;ÆÀ;ÇÀ<(À<LÀ<MÀ<YÀ<œÀ<À<©À<õÀ=À=À=À=mÀ= À=ºÀ=ÀÀ=õÀ>À>À>À>NÀ>iÀ>†À>ÄÀ?À?&À?dÀ?…À?»À?ÁÀ?âÀ@À@À@/À@jÀ@|À@€À@À@ìÀABÀADÀAEÀAzÀAªÀA«ÀAãÀAçÀB1ÀB>ÀBÀB‚ÀBÑÀBæÀBéÀC6ÀCSÀCVÀC¢ÀC¥ÀC·ÀCºÀCÅÀCùÀCüÀD7ÀDtÀDyÀD|ÀD›ÀDËÀDĞÀD×ÀDÚÀE/ÀE…ÀE±ÀE´ÀF
ÀF>ÀFtÀF»ÀFÿÀG<ÀGRÀG~ÀG“ÀG§ÀGÔÀGãÀH#ÀH+ÀH8ÀHUÀH[ÀHaÀHsÀHŠÀH¦ÀHªÀHÅÀHÇÀHÈÀIÀIeÀIiÀI¹ÀJ	ÀJ>ÀJyÀJ¾ÀJ¿ÀJôÀKÀKÀK_ÀKzÀK{ÀK‡ÀKÀK÷ÀLÀL(ÀLoÀL˜ÀLÀL¼ÀLÀÀLÂ       ,‡ŞªŒĞ„ë/// An immutable 32 bit color value in ARGB format.
///
/// Consider the light teal of the Flutter logo. It is fully opaque, with a red
/// channel value of 0x42 (66), a green channel value of 0xA5 (165), and a blue
/// channel value of 0xF5 (245). In the common "hash syntax" for color values,
/// it would be described as `#42A5F5`.
///
/// Here are some ways it could be constructed:
///
/// ```dart
/// Color c1 = const Color(0xFF42A5F5);
/// Color c2 = const Color.fromARGB(0xFF, 0x42, 0xA5, 0xF5);
/// Color c3 = const Color.fromARGB(255, 66, 165, 245);
/// Color c4 = const Color.fromRGBO(66, 165, 245, 1.0);
/// ```
///
/// If you are having a problem with `Color` wherein it seems your color is just
/// not painting, check to make sure you are specifying the full 8 hexadecimal
/// digits. If you only specify six, then the leading two digits are assumed to
/// be zero, which means fully-transparent:
///
/// ```dart
/// Color c1 = const Color(0xFFFFFF); // fully transparent white (invisible)
/// Color c2 = const Color(0xFFFFFFFF); // fully opaque white (visible)
/// ```
///
/// See also:
///
///  * [Colors](https://api.flutter.dev/flutter/material/Colors-class.html), which
///    defines the colors found in the Material Design specification. ŒÚ‚Ñ }‚‚|/// Construct a color from the lower 32 bits of an [int].
///
/// The bits are interpreted as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value.
///
/// In other words, if AA is the alpha value in hex, RR the red value in hex,
/// GG the green value in hex, and BB the blue value in hex, a color can be
/// expressed as `const Color(0xAARRGGBB)`.
///
/// For example, to get a fully opaque orange, you would use `const
/// Color(0xFFFF9000)` (`FF` for the alpha, `FF` for the red, `90` for the
/// green, and `00` for the blue).ƒ	ˆ  –˜ ¯‚‚‘v‘w‘£/// Construct a color from the lower 8 bits of four integers.
///
/// * `a` is the alpha value, with 0 being transparent and 255 being fully
///   opaque.
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromRGBO], which takes the alpha value as a floating point
/// value.‘€‘…  ‘‡‘Œ  ‘‘“  ‘•‘š  -‘¨‘¢’$‘ª’"’‘à‘¾‘«‘¼‘·‘¬‘µ‘¯‘­‘±‘º‘Í‘Ş‘Ù‘Î‘×‘Ñ‘Ï‘Ó‘Ü‘ï‘ÿ‘û‘ğ‘ù‘ó‘ñ‘õ‘ş’’!’’’’’’’ ’&’5ƒ ”!”"”*Ê/// Create a color from red, green, blue, and opacity, similar to `rgba()` in CSS.
///
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
/// * `opacity` is alpha channel of this color as a double, with 0.0 being
///   transparent and 1.0 being fully opaque.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromARGB], which takes the opacity as an integer value.”+”0  ”2”7  ”9”>  ”@”H  3”\”V•(”^•&”ò”¼”†”_”„””`”}”w”a”u”q”j”b”l”t”y”‚”–”º”µ”—”³”­”˜”¯”¸”Ì”ï”ë”Í”é”ã”Î”å”î••%•!••••••$•*•9–?€ë/// A 32 bit value representing this color.
///
/// The bits are assigned as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value. –I€Ü—€§/// The alpha channel of this color in an 8 bit value.
///
/// A value of 0 means this color is fully transparent. A value of 255 means
/// this color is fully opaque.   —)€Ï—à€£/// The alpha channel of this color as a double.
///
/// A value of 0.0 means this color is fully transparent. A value of 1.0 means
/// this color is fully opaque.   —üa˜;4/// The red channel of this color in an 8 bit value.   ˜ad˜¢6/// The green channel of this color in an 8 bit value.   ˜Éb™	5/// The blue channel of this color in an 8 bit value.   ±Y/±m   ±Y±Z™/	™ò€´/// Returns a new color that matches this color with the alpha channel
/// replaced with `a` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. ™üš   š<U›€Æ/// Returns a new color that matches this color with the alpha channel
/// replaced with the given `opacity` (which ranges from 0.0 to 1.0).
///
/// Out of range values will have unexpected effects. ››%   ›•œV€²/// Returns a new color that matches this color with the red channel replaced
/// with `r` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. œ^œc   œ 	c€´/// Returns a new color that matches this color with the green channel
/// replaced with `g` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. mr   ­o€³/// Returns a new color that matches this color with the blue channel replaced
/// with `b` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. x}   ÷€ÅŸ  ŸŸ&   ŸÀ‚K Î€ú/// Returns a brightness value between 0 for darkest and 1 for lightest.
///
/// Represents the relative luminance of the color. This value is computationally
/// expensive to calculate.
///
/// See <https://en.wikipedia.org/wiki/Relative_luminance>.   ¢‡A§„Ç/// Linearly interpolate between two colors.
///
/// This is intended to be fast but as a result may be ugly. Consider
/// [HSVColor] or writing custom logic for interpolating colors.
///
/// If either color is null, this function linearly interpolates from a
/// transparent instance of the other color. This is usually preferable to
/// interpolating from [material.Colors.transparent] (`const
/// Color(0x00000000)`), which is specifically transparent _black_.
///
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]). Each channel
/// will be clamped to the range 0 to 255.
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController]. §§  § §(  §*§2   ©T† «hö/// Combine the foreground color as a transparent color over top
/// of a background color, and return the resulting combined color.
///
/// This uses standard alpha blending ("SRC over DST") rules to produce a
/// blended color from two colors. This can be used as a performance
/// enhancement when trying to avoid needless alpha blending compositing
/// operations for two things that are solid colors with the same shape, but
/// overlay each other: instead, just paint one with the combined color. «s«z  «…«Œ   ¯x€í°w/// Returns an alpha value representative of the provided [opacity] value.
///
/// The [opacity] value may not be null. °°   °i€ì°ƒ  °†°  °i°j±ŒW±Ÿ   ±Œ± À ¬…À GÀ ­6€ª/// A description of the style to use when drawing on a [Canvas].
///
/// Most APIs on [Canvas] take a [Paint] object to describe the style
/// to use for that operation. À ­@€¢ À ­À ­£Y/// Constructs an empty [Paint] object with all fields initialized to
/// their defaults.  'À °ÂLÀ °í 	À °ÂÀ °ÃÀ °ÉÀ °ÚÀ °ÊÀ °õÀ °ıÀ ±À °şÀ ±'À ±$ À ±9À ±>!À ±O À ±^À ±c%À ±t À ±‡À ±Œ!À ± À ±¬À ±±'À ±Â À ±×À ±Ü%À ±í À ² À ²&À ² À ²*À ²/,À ²@ À ²ZÀ ²_)À ²p À ²‡À ²Œ&À ² À ²±À ²¶0À ²Ç À ²äÀ ²ê,À ²û À ³À ³(À ³+ À ³@À ³F#À ³W À ³gÀ ³n>À ³ À ³¨À ³•À ³«À ³°2À ³Á À ³ŞÀ ³ÑÀ ³áÀ ³æ:À ³÷ À ´À ´À ´À ´$2À ´5 À ´RÀ ´EÀ ´UÀ ´Z>À ´k À ´”À ´À ´—À ´œ:À ´­ À ´ÒÀ ´ÁÀ ´ÕÀ ´Ú<À ´ë À µÀ µ À µÀ µHÀ µ+ À µ^À µFÀ µaÀ µfBÀ µw À µ¤À µÀ µ§À µ¬<À µ½ À µäÀ µÒÀ µçÀ µìNÀ µı À ¶6À ¶À ¶9À ¶>FÀ ¶O À ¶€À ¶iÀ ¶ƒÀ ¶ˆ>À ¶™ À ¶ÂÀ ¶¯À ¶ÅÀ ¶Ê4À ¶Û À ¶úÀ ¶ìÀ ¶ıÀ ·C%À ·T À ·fÀ ·Ò3À ·ı À ·ÒÀ ·ÓÀ ·ÙÀ ·êÀ ·ÚÀ ¸€"À ¸‘ À ¸¡À ¸¦'À ¸· À ¸ÌÀ ¸Ñ'À ¸â À ¸÷À ¸ü"À ¹ À ¹À »i,À »z À »‹À ¾=À ¾¡ À ¾¶À ¾¿À ¾ÀÀ ¾ÇÀ ¾ÈÀ ÍÇ3À ÍÛ À Í÷À é ‚À ë¨"/// Whether to dither the output when drawing some elements such as gradients.
///
/// It is not expected that this flag will be used in the future; please leave
/// feedback in <https://github.com/flutter/flutter/issues/112498> if there is
/// a use case for this flag to remain long term.
À êMÀ êNÀ êXÀ ë˜À ê^À ê®À êûÀ ë*À ëbÀ ëºÀ ¹Q€ÓÀ ¹Ìi/// Whether to apply anti-aliasing to lines and images drawn on the
/// canvas.
///
/// Defaults to true.   À º'À º+  À º7
À º=   À »š‚'À ½A„/// The color to use when stroking or filling a shape.
///
/// Defaults to opaque black.
///
/// See also:
///
///  * [style], which controls whether to stroke or fill (or both).
///  * [colorFilter], which overrides [color].
///  * [shader], which overrides [color] with more elaborate effects.
///
/// This color is not used when compositing. To colorize a layer, use
/// [colorFilter].   À ½Ä€À ½È  À ½ÎÀ ½Õ   À ¾ÒƒœÀ Á×‚Ò/// A blend mode to apply when a shape is drawn or a layer is composited.
///
/// The source colors are from the shape being drawn (e.g. from
/// [Canvas.drawPath]) or layer being composited (the graphics that were drawn
/// between the [Canvas.saveLayer] and [Canvas.restore] calls), after applying
/// the [colorFilter], if any.
///
/// The destination colors are from the background onto which the shape or
/// layer is being composited.
///
/// Defaults to [BlendMode.srcOver].
///
/// See also:
///
///  * [Canvas.saveLayer], which uses its [Paint]'s [blendMode] to composite
///    the layer when [Canvas.restore] is called.
///  * [BlendMode], which discusses the user of [Canvas.saveLayer] with
///    [blendMode].   À Âq€ À Âu  À ÂÀ ÂŠ   À Ã€áÀ Ã™k/// Whether to paint inside shapes, the edges of shapes, or both.
///
/// Defaults to [PaintingStyle.fill].   À Ãù€‡À Ãı  À ÄÀ Ä   À Ä„iÀ Å˜€ş/// How wide to make edges drawn when [style] is set to
/// [PaintingStyle.stroke]. The width is given in logical pixels measured in
/// the direction orthogonal to the direction of the path.
///
/// Defaults to 0.0, which correspond to a hairline width.   À Åğ€‹À Åô  À Æ À Æ   À ÆÀ Ç6€ /// The kind of finish to place on the end of lines drawn when
/// [style] is set to [PaintingStyle.stroke].
///
/// Defaults to [StrokeCap.butt], i.e. no caps.   À Çš€‹À Ç  À Ç¨À Ç³   À È)„ÑÀ Ì–„+/// The kind of finish to place on the joins between segments.
///
/// This applies to paths drawn when [style] is set to [PaintingStyle.stroke],
/// It does not apply to points drawn as lines with [Canvas.drawPoints].
///
/// Defaults to [StrokeJoin.miter], i.e. sharp corners.
///
/// Some examples of joins:
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeMiterLimit] to control when miters are replaced by bevels when
///    this is set to [StrokeJoin.miter].
///  * [strokeCap] to control what is drawn at the ends of the stroke.
///  * [StrokeJoin] for the definitive list of stroke joins.   À Ìı€À Í  À ÍÀ Í   À Íÿ…rÀ Ó„Ó/// The limit for miters to be drawn on segments when the join is set to
/// [StrokeJoin.miter] and the [style] is set to [PaintingStyle.stroke]. If
/// this limit is exceeded, then a [StrokeJoin.bevel] join will be drawn
/// instead. This may cause some 'popping' of the corners of a path if the
/// angle between line segments is animated, as seen in the diagrams below.
///
/// This limit is expressed as a limit on the length of the miter.
///
/// Defaults to 4.0.  Using zero as a limit will cause a [StrokeJoin.bevel]
/// join to be used all the time.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_0_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_6_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeJoin] to control the kind of finish to place on the joins
///    between segments.
///  * [strokeCap] to control what is drawn at the ends of the stroke.   À Ót€±À Óx  À Ó‰À Ó‘   À Ô)‚WÀ Ôñ€¯/// A mask filter (for example, a blur) to apply to a shape after it has been
/// drawn but before it has been composited into the image.
///
/// See [MaskFilter] for details.   À Öƒ‚°À Ö‡  À Ö’À ÖŸ   À Ù7ìÀ Ú¶/// Controls the performance vs quality trade-off to use when sampling bitmaps,
/// as with an [ImageShader], or when drawing images, as with [Canvas.drawImage],
/// [Canvas.drawImageRect], [Canvas.drawImageNine] or [Canvas.drawAtlas].
///
/// Defaults to [FilterQuality.none].   À Û&€—À Û*  À Û8À ÛG   À ÛÁÈÀ İMk/// The shader to use when stroking or filling a shape.
///
/// When this is null, the [color] is used instead.
///
/// See also:
///
///  * [Gradient], a shader that paints a color gradient.
///  * [ImageShader], a shader that tiles an [Image].
///  * [colorFilter], which overrides [shader].
///  * [color], which is used if [shader] and [colorFilter] are null.   À İŒïÀ İ  À İ—À İ    À ßvÀ àk€Î/// A color filter to apply when a shape is drawn or when a layer is
/// composited.
///
/// See [ColorFilter] for details.
///
/// When a shape is being drawn, [colorFilter] overrides [color] and [shader].   À àø<À àü  À áÀ á   À â8‚ˆÀ ä6È/// The [ImageFilter] to use when drawing raster images.
///
/// For example, to blur an image using [Canvas.drawImage], apply an
/// [ImageFilter.blur]:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   canvas.drawImage(
///     _image,
///     ui.Offset.zero,
///     Paint()..imageFilter = ui.ImageFilter.blur(sigmaX: 0.5, sigmaY: 0.5),
///   );
/// }
/// ```
///
/// See also:
///
///  * [MaskFilter], which is used for drawing geometry.   À äÃ·À äÇ  À äÓÀ äá   À æ~nÀ ç“/// Whether the colors of the image are inverted when drawn.
///
/// Inverting the colors of an image applies a new color filter that will
/// be composed with any user provided color filters. This is primarily
/// used for implementing smart invert on iOS.   À çïlÀ çó  À è 
À è   À è_XÀ èh    À èºbÀ è¾  À èÆ
À èÌ   À ¸
rÀ ¸    À ëÃ‡ÚÀ ëÖ   À ëÃÀ ëÄ À1¦hÀÖ„/// Opaque handle to raw decoded image data (pixels).
///
/// To obtain an [Image] object, use the [ImageDescriptor] API.
///
/// To draw an [Image], use one of the methods on the [Canvas] class, such as
/// [Canvas.drawImage].
///
/// A class or method that receives an image object must call [dispose] on the
/// handle when it is no longer needed. To create a shareable reference to the
/// underlying image, call [clone]. The method or object that receives
/// the new instance will then be responsible for disposing it, and the
/// underlying image itself will be disposed when all outstanding handles are
/// disposed.
///
/// If `dart:ui` passes an `Image` object and the recipient wishes to share
/// that handle with other callers, [clone] must be called _before_ [dispose].
/// A handle that has been disposed cannot create new handles anymore.
///
/// See also:
///
///  * [Image](https://api.flutter.dev/flutter/widgets/Image-class.html), the class in the [widgets] library.
///  * [ImageDescriptor], which allows reading information about the image and
///    creating a codec to decode it.
///  * [instantiateImageCodec], a utility method that wraps [ImageDescriptor]. Àà€ÁÀåÀæÀç ÀèÀî  Àõ
Àû  À	À	   À	Æ/À	ï À	ÆÀ	ÇÀ	ÍÀ	ŞÀ	ÎÀ	úÀ€ç/// A callback that is invoked to report an image creation.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onCreate] directly because [MemoryAllocations]
/// allows multiple callbacks. ÀÀ#€é/// A callback that is invoked to report the image disposal.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onDispose] directly because [MemoryAllocations]
/// allows multiple callbacks. À1À=  ÀMSÀ›A/// The number of image pixels along the image's horizontal axis. À¥RÀñ?/// The number of image pixels along the image's vertical axis. ÀüÀ ÀÀ@•À÷€¥/// Whether this reference to the underlying image is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   À§ƒÀÌ/// The color space that is used by the [Image]'s colors.
///
/// This value is a consequence of how the [Image] has been created.  For
/// example, loading a PNG that is in the Display P3 color space will result
/// in a [ColorSpace.extendedSRGB] image.
///
/// On rendering backends that don't support wide gamut colors (anything but
/// iOS impeller), wide gamut images will still report [ColorSpace.sRGB] if
/// rendering wide gamut colors isn't supported.   Àƒ&Àæ/// Release this handle's claim on the underlying Image. This handle is no
/// longer usable after this method is called.
///
/// Once all outstanding handles have been disposed, the underlying image will
/// be disposed as well.
///
/// In debug mode, [debugGetOpenHandleStackTraces] will return a list of
/// [StackTrace] objects from all open handles' creation points. This is
/// useful when trying to determine what parts of the program are keeping an
/// image resident in memory.   ÀÙƒÊÀÍ/// Converts the [Image] object into a byte array.
///
/// The [format] argument specifies the format in which the bytes will be
/// returned.
///
/// Using [ImageByteFormat.rawRgba] on an image in the color space
/// [ColorSpace.extendedSRGB] will result in the gamut being squished to fit
/// into the sRGB gamut, resulting in the loss of wide-gamut colors.
///
/// Returns a future that completes with the binary image data or an error
/// if encoding fails. À0À!  À)À8À9À;¢À€°/// If asserts are enabled, returns the [StackTrace]s of each open handle from
/// [clone], in creation order.
///
/// If asserts are disabled, this method always returns null.   ÀáŒàÀ&"Š¢/// Creates a disposable handle to this image.
///
/// Holders of an [Image] must dispose of the image when they no longer need
/// to access it or draw it. However, once the underlying image is disposed,
/// it is no longer possible to use it. If a holder of an image needs to share
/// access to that image with another object or method, [clone] creates a
/// duplicate handle. The underlying image will only be disposed once all
/// outstanding handles are disposed. This allows for safe sharing of image
/// references while still disposing of the underlying resources when all
/// consumers are finished.
///
/// It is safe to pass an [Image] handle to another object or method if the
/// current holder no longer needs it.
///
/// To check whether two [Image] references are referring to the same
/// underlying image memory, use [isCloneOf] rather than the equality operator
/// or [identical].
///
/// The following example demonstrates valid usage.
///
/// ```dart
/// import 'dart:async';
/// import 'dart:typed_data';
/// import 'dart:ui';
///
/// Future<Image> _loadImage(int width, int height) {
///   final Completer<Image> completer = Completer<Image>();
///   decodeImageFromPixels(
///     Uint8List.fromList(List<int>.filled(width * height * 4, 0xFF)),
///     width,
///     height,
///     PixelFormat.rgba8888,
///     // Don't worry about disposing or cloning this image - responsibility
///     // is transferred to the caller, and that is safe since this method
///     // will not touch it again.
///     (Image image) => completer.complete(image),
///   );
///   return completer.future;
/// }
///
/// Future<void> main() async {
///   final Image image = await _loadImage(5, 5);
///   // Make sure to clone the image, because MyHolder might dispose it
///   // and we need to access it again.
///   final MyImageHolder holder = MyImageHolder(image.clone());
///   final MyImageHolder holder2 = MyImageHolder(image.clone());
///   // Now we dispose it because we won't need it again.
///   image.dispose();
///
///   final PictureRecorder recorder = PictureRecorder();
///   final Canvas canvas = Canvas(recorder);
///
///   holder.draw(canvas);
///   holder.dispose();
///
///   canvas.translate(50, 50);
///   holder2.draw(canvas);
///   holder2.dispose();
/// }
///
/// class MyImageHolder {
///   MyImageHolder(this.image);
///
///   final Image image;
///
///   void draw(Canvas canvas) {
///     canvas.drawImage(image, Offset.zero, Paint());
///   }
///
///   void dispose() => image.dispose();
/// }
/// ```
///
/// The returned object behaves identically to this image. Calling
/// [dispose] on it will only dispose the underlying native resources if it
/// is the last remaining handle.   À'Å‚›À*/‚R/// Returns true if `other` is a [clone] of this and thus shares the same
/// underlying image memory, even if this or `other` is [dispose]d.
///
/// This method may return false for two images that were decoded from the
/// same underlying asset, if they are not sharing the same memory. For
/// example, if the same file is decoded using [instantiateImageCodec] twice,
/// or the same bytes are decoded using [decodeImageFromPixels] twice, there
/// will be two distinct [Image]s that render the same but do not share
/// underlying memory, and so will not be treated as clones of each other. À*9À*@   À*d3À*w   À*dÀ*e À*›‡6À*À  À+Å'À+çÀ+èÀ+é  À+ÅÀ+ÆÀ+ÌÀ+İÀ+ÍÀ.µÀ.º À.ÆÀ1%À1 À1)À1*À1"À1(À1#À+ğfÀ,P   À+ğÀ+ñÀ+÷À,À+şÀ+øÀ,À,À,À,À,À,À,À,;À,À,À,À,5À,/À,7À,ZhÀ,»   À,ZÀ,[À,aÀ,À,hÀ,bÀ,pÀ,~À,qÀ,xÀ,}À,yÀ,€À,¦À,‡À,À,‰À, À,šÀ,¢À10bÀ1‡   À10À11À17À1UÀ1>À18À1FÀ1TÀ1GÀ1NÀ1SÀ1OÀ1VÀ1rÀ1]À1WÀ1_À,ÆÀ,Ø  À,ä0À,õ  À,ıÀ-À-À-Ö€ÛÀ.y9/// Returns an error message on failure, null on success. À.…
À.Š  À.‘À.¨  À.À.À.À.GÀ.!À.À.)À.FÀ.*À.1À.6À.2À.9À.@À.HÀ.dÀ.OÀ.IÀ.QÀ.ÏdÀ.Ô    À07€ËÀ0÷k/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À0§À0¨À0®À0ËÀ0´À0¯À0¼À0ÊÀ0½À0ÄÀ0ÉÀ0ÅÀ0ÌÀ0åÀ0ÓÀ0ÍÀ0ÕÀ1–9À1©   À1–À1—À*›À*œÀ*¢À*³À*£À2B‰_À9†Ê/// Information for a single frame of an animation.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].
///
/// The recipient of an instance of this class is responsible for calling
/// [Image.dispose] on [image]. To share the image with other interested
/// parties, use [Image.clone]. If the [FrameInfo] object itself is passed to
/// another method or object, that method or object must assume it is
/// responsible for disposing the image when done, and the passer must not
/// access the [image] after that point.
///
/// For example, the following code sample is incorrect:
///
/// ```dart
/// /// BAD
/// Future<void> nextFrameRoutine(ui.Codec codec) async {
///   final ui.FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo);
///   // ERROR - _cacheImage is now responsible for disposing the image, and
///   // the image may not be available any more for this drawing routine.
///   _drawImage(frameInfo);
///   // ERROR again - the previous methods might or might not have created
///   // handles to the image.
///   frameInfo.image.dispose();
/// }
/// ```
///
/// Correct usage is:
///
/// ```dart
/// /// GOOD
/// Future<void> nextFrameRoutine(ui.Codec codec) async {
///   final ui.FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo.image.clone(), frameInfo.duration);
///   _drawImage(frameInfo.image.clone(), frameInfo.duration);
///   // This method is done with its handle, and has passed handles to its
///   // clients already.
///   // The image will live until those clients dispose of their handles, and
///   // this one must not be disposed since it will not be used again.
///   frameInfo.image.dispose();
/// }
/// ``` À9!À9ğÀ9ñÀ9ò€»/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].À9ôÀ:  À:À:   À:&€™À:·{/// The duration this frame should be shown.
///
/// A zero duration indicates that the frame should be shown indefinitely. À:Ä€ÚÀ;™€¾/// The [Image] object for this frame.
///
/// This object must be disposed by the recipient of this frame info.
///
/// To share this image with other interested parties, use [Image.clone].    À;£„>À<‘€Ş/// A handle to an image codec.
///
/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [Codec] interface, see
/// [instantiateImageCodec].   À<›9À<É#/// Number of frames in this image.   À<Ø€¦À=n€…/// Number of times to repeat the animation.
///
/// * 0 when the animation should be played once.
/// * -1 for infinity repetitions.   À=‚aÀ>Ô//// Fetches the next animation frame.
///
/// Wraps back to the first frame after returning the last frame.
///
/// The returned future can complete with an error if the decoding has failed.
///
/// The caller of this method is responsible for disposing the
/// [FrameInfo.image] on the returned object.   À>ç€øÀ?Õ€Ş/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).    À?ã‡5À?î  À@öÀAÀAÀA   ÀAÀA  ÀAãÀAè  ÀA&DÀA:   ÀA&ÀA'ÀAnqÀAÓ   ÀAnÀAoÀAuÀA“ÀA|ÀAvÀA„ÀA’ÀA…ÀAŒÀA‘ÀAÀA”ÀA¾ÀA›ÀA•ÀAÀA¸ÀA²ÀAºÀBSÀB   ÀBÀBÀBZ{ÀBÄ   ÀBZÀB[ÀBaÀBÀBhÀBbÀBpÀB~ÀBqÀBxÀB}ÀByÀB€ÀB¯ÀB‡ÀBÀB‰ÀB©ÀB£ÀB«ÀBÙ‚õÀB÷   ÀBÙÀBÚÀEÒ€ÚÀFp9/// Returns an error message on failure, null on success. ÀF~,ÀF£  ÀFÀFÀFÀF<ÀFÀFÀF%ÀF;ÀF&ÀF-ÀF2ÀF.ÀF5ÀF=ÀF[ÀFDÀF>ÀFFÀF°fÀG   ÀF°ÀF±ÀF¼ÀF½ÀFÃÀFàÀFÉÀFÄÀFÑÀFßÀFÒÀFÙÀFŞÀFÚÀFáÀFúÀFèÀFâÀFê Àf_†jÀgr/// A specification of the size to which an image should be decoded.
///
/// See also:
///
///  * [TargetImageSizeCallback], a callback that returns instances of this
///    class when consulted by image decoding methods such as
///    [instantiateImageCodecWithSize]. Àg†# Àh%Àh4€/// Creates a new instance of this class.
///
/// The `width` and `height` may both be null, but if they're non-null, they
/// must be positive.Àh6
Àh<  ÀhBÀhH  ÀhXÀh^ÀhyÀhmÀheÀh_ÀhhÀhvÀhpÀhxÀh„ÀhŠÀh§ÀhšÀh’Àh‹Àh•Àh¤ÀhÀh¦Àh­åÀjÂ/// The width into which to load the image.
///
/// If this is non-null, the image will be decoded into the specified width.
/// If this is null and [height] is also null, the image will be decoded into
/// its intrinsic size. If this is null and [height] is non-null, the image
/// will be decoded into a width that maintains its intrinsic aspect ratio
/// while respecting the [height] value.
///
/// If this value is non-null, it must be positive. Àj—æÀlwÂ/// The height into which to load the image.
///
/// If this is non-null, the image will be decoded into the specified height.
/// If this is null and [width] is also null, the image will be decoded into
/// its intrinsic size. If this is null and [width] is non-null, the image
/// will be decoded into a height that maintains its intrinsic aspect ratio
/// while respecting the [width] value.
///
/// If this value is non-null, it must be positive.  Àl‚EÀl•   Àl‚Àlƒ À†lƒ˜À†ÌP/// A handle for the framework to hold and retain an engine layer across frames.    À†Üƒ&À‰ø‚ø/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// EngineLayers indirectly retain platform specific graphics resources. Some
/// of these resources, such as images, may be memory intensive. It is
/// important to dispose of EngineLayer objects that will no longer be used as
/// soon as possible to avoid retaining these resources until the next
/// garbage collection.
///
/// Once this EngineLayer is disposed, it is no longer eligible for use as a
/// retained layer, and must not be passed as an `oldLayer` to any of the
/// [SceneBuilder] methods which accept that parameter.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).    ÀŠIÀŠ  ÀŠ`}ÀŠØÀŠÙÀŠÚa/// This class is created by the engine, and should not be instantiated
/// or extended directly.    ÀŠálÀ‹C   ÀŠáÀŠâÀŠíÀŠîÀŠôÀ‹ÀŠúÀŠõÀ‹À‹À‹À‹
À‹À‹À‹À‹1À‹À‹À‹ À‹Q¸XÀ‚¸/// A complex, one-dimensional subset of a plane.
///
/// A path consists of a number of sub-paths, and a _current point_.
///
/// Sub-paths consist of segments of various types, such as lines,
/// arcs, or beziers. Sub-paths can be open or closed, and can
/// self-intersect.
///
/// Closed sub-paths enclose a (possibly discontiguous) region of the
/// plane based on the current [fillType].
///
/// The _current point_ is initially at the origin. After each
/// operation adding a segment to a sub-path, the current point is
/// updated to the end of that segment.
///
/// Paths can be drawn on canvases using [Canvas.drawPath], and can
/// used to create clip regions using [Canvas.clipPath]. À" À*À.   ÀCiÀÀÀ€Á/// Creates a copy of another [Path].
///
/// This copy is fast and does not require additional memory unless either
/// the `source` path or the path returned by this constructor are modified.ÀÀ%    À°€£ÀJ€‚/// Determines how the interior of this path is calculated.
///
/// Defaults to the non-zero winding rule, [PathFillType.nonZero].   ÀV!ÀZ  ÀcÀq   À{UÀµ2/// Starts a new sub-path at the given coordinate. À¼ÀÄ  ÀÆÀÎ   ÀÔrÀ‘!E/// Starts a new sub-path at the given offset from the current point. À‘0	À‘8  À‘;	À‘C   À‘JtÀ‘£O/// Adds a straight line segment from the current point to the given
/// point. À‘ªÀ‘²  À‘´À‘¼   À‘Â€£À’@t/// Adds a straight line segment from the current point to the point
/// at the given offset from the current point. À’O	À’W  À’Z	À’b   À’iÁÀ“ìq/// Adds a quadratic bezier segment that curves from the current
/// point to the given point (x2,y2), using the control point
/// (x1,y1).
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_quadratic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_quadratic_to_dark.png#gh-dark-mode-only) À“ş	À”  À”		À”  À”	À”  À”	À”'   À”.'À•€Ó/// Adds a quadratic bezier segment that curves from the current
/// point to the point at the offset (x2,y2) from the current point,
/// using the control point at the offset (x1,y1) from the current
/// point. À•)	À•1  À•4	À•<  À•?	À•G  À•J	À•R   À•YÎÀ–İr/// Adds a cubic bezier segment that curves from the current point
/// to the given point (x3,y3), using the control points (x1,y1) and
/// (x2,y2).
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_cubic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_cubic_to_dark.png#gh-dark-mode-only) À–å	À–í  À–ğ	À–ø  À–û	À—  À—	À—  À—	À—  À—	À—$   À—+=À˜€İ/// Adds a cubic bezier segment that curves from the current point
/// to the point at the offset (x3,y3) from the current point, using
/// the control points at the offsets (x1,y1) and (x2,y2) from the
/// current point. À˜&	À˜.  À˜1	À˜9  À˜<	À˜D  À˜G	À˜O  À˜R	À˜Z  À˜]	À˜e   À˜l‚bÀš‚/// Adds a bezier segment that curves from the current point to the
/// given point (x2,y2), using the control points (x1,y1) and the
/// weight w. If the weight is greater than 1, then the curve is a
/// hyperbola; if the weight equals 1, it's a parabola; and if it is
/// less than 1, it is an ellipse.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_conic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_conic_to_dark.png#gh-dark-mode-only) Àš˜	Àš   Àš£	Àš«  Àš®	Àš¶  Àš¹	ÀšÁ  ÀšÄÀšÌ   ÀšÒÏÀœ[w/// Adds a bezier segment that curves from the current point to the
/// point at the offset (x2,y2) from the current point, using the
/// control point at the offset (x1,y1) from the current point and
/// the weight w. If the weight is greater than 1, then the curve is
/// a hyperbola; if the weight equals 1, it's a parabola; and if it
/// is less than 1, it is an ellipse. Àœk	Àœs  Àœv	Àœ~  Àœ	Àœ‰  ÀœŒ	Àœ”  Àœ—ÀœŸ   Àœ¥ƒrÀŸÎƒ/// If the `forceMoveTo` argument is false, adds a straight line
/// segment and an arc segment.
///
/// If the `forceMoveTo` argument is true, starts a new sub-path
/// consisting of an arc segment.
///
/// In either case, the arc segment consists of the arc that follows
/// the edge of the oval bounded by the given rectangle, from
/// startAngle radians around the oval up to startAngle + sweepAngle
/// radians around the oval, with zero radians being the point on
/// the right hand side of the oval that crosses the horizontal line
/// that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval.
///
/// The line segment added if `forceMoveTo` is false starts at the
/// current point and ends at the start of the arc. ÀŸÔ	ÀŸÚ  ÀŸßÀŸç  ÀŸòÀŸú  À À    À ƒ!À¢©‚p/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEnd`. The curves follow a path in a direction determined by
/// `clockwise` and `largeArc` in such a way that the sweep angle
/// is always less than 360 degrees.
///
/// A simple line is appended if either radii are zero or the last
/// point in the path is `arcEnd`. The radii are scaled to fit the last path
/// point if both are greater than zero but too small to describe an arc.
/// À¢´À¢¼  À¢ÉÀ¢Ñ  À¢êÀ¢ò  À£À£  À£ À£&  À¢ÙÀ¢ßÀ¢àÀ¢üÀ£À£1À£@ƒ£À¦>‚Ü/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The last path point is described by (px, py).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEndDelta.dx + px` and `arcEndDelta.dy + py`. The curves follow a
/// path in a direction determined by `clockwise` and `largeArc`
/// in such a way that the sweep angle is always less than 360 degrees.
///
/// A simple line is appended if either radii are zero, or, both
/// `arcEndDelta.dx` and `arcEndDelta.dy` are zero. The radii are scaled to
/// fit the last path point if both are greater than zero but too small to
/// describe an arc. À¦VÀ¦^  À¦pÀ¦x  À¦‘À¦™  À¦¬À¦²  À¦ÇÀ¦Í  À¦€À¦†À¦‡À¦£À¦¼À¦ØÀ¦çvÀ§JY/// Adds a new sub-path that consists of four lines that outline the
/// given rectangle. À§R	À§X   À§a.À¨|/// Adds a new sub-path that consists of a curve that forms the
/// ellipse that fills the given rectangle.
///
/// To add a circle, pass an appropriate rectangle as `oval`. [Rect.fromCircle]
/// can be used to easily describe the circle's center [Offset] and radius. À¨„	À¨Š   À¨“ƒèÀ¬Cƒ/// Adds a new sub-path with one arc segment that consists of the arc
/// that follows the edge of the oval bounded by the given
/// rectangle, from startAngle radians around the oval up to
/// startAngle + sweepAngle radians around the oval, with zero
/// radians being the point on the right hand side of the oval that
/// crosses the horizontal line that intersects the center of the
/// rectangle and with positive angles going clockwise around the
/// oval.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_dark.png#gh-dark-mode-only)
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_ccw.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_ccw_dark.png#gh-dark-mode-only) À¬J	À¬P  À¬UÀ¬]  À¬hÀ¬p   À¬XÀ­«/// Adds a new sub-path with a sequence of line segments that connect the given
/// points.
///
/// If `close` is true, a final line segment will be added that connects the
/// last point to the first point.
///
/// The `points` argument is interpreted as offsets from the origin. À­¶À­Ä  À­Ë
À­Ñ   À­Û€°À®u€/// Adds a new sub-path that consists of the straight lines and
/// curves needed to form the rounded rectangle described by the
/// argument. À®~À®…   À®QÀ¯¦/// Adds the sub-paths of `path`, offset by `offset`, to this path.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given offset. The matrix is a 4x4
/// matrix stored in column major order. À¯®	À¯´  À¯¹À¯Á  À¯ÉÀ¯×   À¯ä×À±z‚/// Adds the sub-paths of `path`, offset by `offset`, to this path.
/// The current sub-path is extended with the first sub-path
/// of `path`, connecting them with a lineTo if necessary.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given `offset`.  The matrix is a 4x4
/// matrix stored in column major order. À±‰	À±  À±”À±œ  À±¤À±²   À±¿€“À²J€/// Closes the last sub-path, as if a straight line had been drawn
/// from the current point to the first point of the sub-path.   À²V€±À²ÿ€/// Clears the [Path] object of all sub-paths, returning it to the
/// same state it had when it was created. The _current point_ is
/// reset to the origin.   À³qÀ´eF/// Tests to see if the given point is within the path. (That is, whether the
/// point would be in the visible portion of the path if the path was used
/// with [Canvas.clipPath].)
///
/// The `point` argument is interpreted as an offset from the origin.
///
/// Returns true if the point is in the path, and false otherwise. À´nÀ´v   À´€€‰À´ôj/// Returns a copy of the path with all the segments of every
/// sub-path translated by the given offset. À´úÀµ   Àµ€”Àµ‚k/// Returns a copy of the path with all the segments of every
/// sub-path transformed by the given matrix. ÀµŒÀµ™   Àµ¥ƒ£À¹<ƒ0/// Computes the bounding rectangle for this path.
///
/// A path containing only axis-aligned points on the same straight line will
/// have no area, and therefore `Rect.isEmpty` will return true for such a
/// path. Consider checking `rect.width + rect.height > 0.0` instead, or
/// using the [computeMetrics] API to check the path length.
///
/// For many more elaborate paths, the bounds may be inaccurate.  For example,
/// when a path contains a circle, the points used to compute the bounds are
/// the circle's implied control points, which form a square around the circle;
/// if the circle has a transformation applied using [transform] then that
/// square is rotated, and the (axis-aligned, non-rotated) bounding box
/// therefore ends up grossly overestimating the actual area covered by the
/// circle.   À¹L‚”Àº•0/// Combines the two paths according to the manner specified by the given
/// `operation`.
///
/// The resulting path will be constructed from non-overlapping contours. The
/// curve order is reduced where possible so that cubics may be turned into
/// quadratics, and quadratics maybe turned into lines. ÀºÀº¬  Àº¶
Àº¼  ÀºÂ
ÀºÈ   À»ä‡ÃÀÃ|‡M/// Creates a [PathMetrics] object for this path, which can describe various
/// properties about the contours of the path.
///
/// A [Path] is made up of zero or more contours. A contour is made up of
/// connected curves and segments, created via methods like [lineTo],
/// [cubicTo], [arcTo], [quadraticBezierTo], their relative counterparts, as
/// well as the add* methods such as [addRect]. Creating a new [Path] starts
/// a new contour once it has any drawing instructions, and another new
/// contour is started for each [moveTo] instruction.
///
/// A [PathMetric] object describes properties of an individual contour,
/// such as its length, whether it is closed, what the tangent vector of a
/// particular offset along the path is. It also provides a method for
/// creating sub-paths: [PathMetric.extractPath].
///
/// Calculating [PathMetric] objects is not trivial. The [PathMetrics] object
/// returned by this method is a lazy [Iterable], meaning it only performs
/// calculations when the iterator is moved to the next [PathMetric]. Callers
/// that wish to memoize this iterable can easily do so by using
/// [Iterable.toList] on the result of this method. In particular, callers
/// looking for information about how many contours are in the path should
/// either store the result of `path.computeMetrics().length`, or should use
/// `path.computeMetrics().toList()` so they can repeatedly check the length,
/// since calling `Iterable.length` causes traversal of the entire iterable.
///
/// In particular, callers should be aware that [PathMetrics.length] is the
/// number of contours, **not the length of the path**. To get the length of
/// a contour in a path, use [PathMetric.length].
///
/// If `forceClosed` is set to true, the contours of the path will be measured
/// as if they had been closed, even if they were not explicitly closed. ÀÃŒÀÃ’  ÀÃŸ ÀÃ«¥EÀÃ¶  ÀÃ÷I ÀÄÀÄ*%/// Create a new empty [Path] object.  ÀÄD€£ÀÄâÀÄãÀÄä€/// Avoids creating a new native backing for the path for methods that will
/// create it later, such as [Path.from], [shift] and [transform].   ÀÅ³MÀÅĞ   ÀÅ³ÀÅ´ÀÆJÀÆ  ÀÆÀÆ*  ÀÆÀÆ0ÀÄëVÀÅ2   ÀÄëÀÄìÀÄòÀÅÀÄøÀÄóÀÅ ÀÅÀÅÀÅ	ÀÅ ÀÅÀÅ
ÀÅÀÅEjÀÅš  ÀÅ¡ÀÅ§  ÀÅEÀÅFÀÅLÀÅqÀÅRÀÅMÀÅZÀÅpÀÅ[ÀÅbÀÅgÀÅcÀÅjÀÅrÀÅˆÀÅyÀÅsÀÅ{ÀÆQpÀÆ²   ÀÆQÀÆRÀÆXÀÆvÀÆ_ÀÆYÀÆgÀÆuÀÆhÀÆoÀÆtÀÆpÀÆwÀÆ¡ÀÆ~ÀÆxÀÆ€ÀÆ›ÀÆ•ÀÆÀÆÅ€ƒÀÇ-  ÀÇ:ÀÇ?  ÀÆÅÀÆÆÀÆÌÀÆğÀÆÒÀÆÍÀÆÚÀÆïÀÆÛÀÆâÀÆçÀÆãÀÆêÀÆñÀÇÀÆøÀÆòÀÆúÀÇÀÇÀÇÀÇL€“ÀÇÄ  ÀÇËÀÇÓ  ÀÇÕÀÇİ  ÀÇLÀÇMÀÇXÀÇYÀÇ_ÀÇŒÀÇeÀÇ`ÀÇmÀÇ‹ÀÇnÀÇuÀÇzÀÇvÀÇ}ÀÇ…ÀÇÀÇ²ÀÇ”ÀÇÀÇ–ÀÇ¬ÀÇ¦ÀÇ®ÀÇã€¥ÀÈc  ÀÈr	ÀÈz  ÀÈ}	ÀÈ…  ÀÇãÀÇäÀÇïÀÇğÀÇöÀÈ#ÀÇüÀÇ÷ÀÈÀÈ"ÀÈÀÈÀÈÀÈÀÈÀÈÀÈ$ÀÈQÀÈ+ÀÈ%ÀÈ-ÀÈKÀÈEÀÈMÀÈŒ€“ÀÉ  ÀÉÀÉ  ÀÉÀÉ  ÀÈŒÀÈÀÈ˜ÀÈ™ÀÈŸÀÈÌÀÈ¥ÀÈ ÀÈ­ÀÈËÀÈ®ÀÈµÀÈºÀÈ¶ÀÈ½ÀÈÅÀÈÍÀÈòÀÈÔÀÈÎÀÈÖÀÈìÀÈæÀÈîÀÉ#€¥ÀÉ£  ÀÉ²	ÀÉº  ÀÉ½	ÀÉÅ  ÀÉ#ÀÉ$ÀÉ/ÀÉ0ÀÉ6ÀÉcÀÉ<ÀÉ7ÀÉDÀÉbÀÉEÀÉLÀÉQÀÉMÀÉTÀÉ\ÀÉdÀÉ‘ÀÉkÀÉeÀÉmÀÉ‹ÀÉ…ÀÉÀÉÌ€ÑÀÊ_  ÀÊq	ÀÊy  ÀÊ|	ÀÊ„  ÀÊ‡	ÀÊ  ÀÊ’	ÀÊš  ÀÉÌÀÉÍÀÉØÀÉÙÀÉßÀÊÀÉåÀÉàÀÉíÀÊÀÉîÀÉõÀÉúÀÉöÀÉıÀÊÀÊÀÊÀÊÀÊMÀÊ$ÀÊÀÊ&ÀÊGÀÊAÀÊIÀÊ¡€èÀË<  ÀË]	ÀËe  ÀËh	ÀËp  ÀËs	ÀË{  ÀË~	ÀË†  ÀÊ¡ÀÊ¢ÀÊ­ÀÊ®ÀÊ´ÀÊñÀÊºÀÊµÀÊÂÀÊğÀÊÃÀÊÊÀÊÏÀÊËÀÊÒÀÊÚÀÊâÀÊêÀÊòÀË*ÀÊùÀÊóÀÊûÀË$ÀËÀË&ÀË€ãÀÌ&  ÀÌ.	ÀÌ6  ÀÌ9	ÀÌA  ÀÌD	ÀÌL  ÀÌO	ÀÌW  ÀÌZ	ÀÌb  ÀÌe	ÀÌm  ÀËÀËÀË™ÀËšÀË ÀËíÀË¦ÀË¡ÀË®ÀËìÀË¯ÀË¶ÀË»ÀË·ÀË¾ÀËÆÀËÎÀËÖÀËŞÀËæÀËîÀÌÀËõÀËïÀË÷ÀÌÀÌÀÌÀÌt€óÀÍ  ÀÍ%	ÀÍ-  ÀÍ0	ÀÍ8  ÀÍ;	ÀÍC  ÀÍF	ÀÍN  ÀÍQ	ÀÍY  ÀÍ\	ÀÍd  ÀÌtÀÌuÀÌ€ÀÌÀÌ‡ÀÌÔÀÌÀÌˆÀÌ•ÀÌÓÀÌ–ÀÌÀÌ¢ÀÌÀÌ¥ÀÌ­ÀÌµÀÌ½ÀÌÅÀÌÍÀÌÕÀÍÀÌÜÀÌÖÀÌŞÀÌıÀÌ÷ÀÌÿÀÍk€ÏÀÍü  ÀÎ	ÀÎ  ÀÎ	ÀÎ  ÀÎ	ÀÎ"  ÀÎ%	ÀÎ-  ÀÎ0ÀÎ8  ÀÍkÀÍlÀÍwÀÍxÀÍ~ÀÍÃÀÍ„ÀÍÀÍŒÀÍÂÀÍÀÍ”ÀÍ™ÀÍ•ÀÍœÀÍ¤ÀÍ¬ÀÍ´ÀÍ¼ÀÍÄÀÍêÀÍËÀÍÅÀÍÍÀÍäÀÍŞÀÍæÀÎ>€ßÀÎ×  ÀÎç	ÀÎï  ÀÎò	ÀÎú  ÀÎı	ÀÏ  ÀÏ	ÀÏ  ÀÏÀÏ  ÀÎ>ÀÎ?ÀÎJÀÎKÀÎQÀÎ–ÀÎWÀÎRÀÎ_ÀÎ•ÀÎ`ÀÎgÀÎlÀÎhÀÎoÀÎwÀÎÀÎ‡ÀÎÀÎ—ÀÎÅÀÎÀÎ˜ÀÎ ÀÎ¿ÀÎ¹ÀÎÁÀÏ!€ŞÀÏ2  ÀÏ8	ÀÏ>  ÀÏCÀÏK  ÀÏVÀÏ^  ÀÏiÀÏo  ÀÏ!ÀÏ"ÀĞÀĞ”  ÀĞ›ÀĞ£  ÀĞ¨
ÀĞ°  ÀĞ´ÀĞ¼  ÀĞÂÀĞÊ  ÀĞÑÀĞÙ  ÀĞäÀĞì  ÀĞ÷ÀĞı  ÀĞÀĞÀĞ
ÀĞ]ÀĞÀĞÀĞÀĞ\ÀĞÀĞ ÀĞ%ÀĞ!ÀĞ(ÀĞ0ÀĞ8ÀĞ@ÀĞHÀĞPÀĞXÀĞ^ÀĞ‚ÀĞeÀĞ_ÀĞgÀĞ|ÀĞvÀĞ~ÀÑKÀÑ  ÀÑ)ÀÑ1  ÀÑ>ÀÑF  ÀÑ_ÀÑg  ÀÑzÀÑ€  ÀÑ•ÀÑ›  ÀÑÀÑÀÑNÀÑTÀÑUÀÑqÀÑŠÀÑ¦ÀÒ\ÀÒğ  ÀÒüÀÓ  ÀÓÀÓ  ÀÓÀÓ$  ÀÓ,ÀÓ4  ÀÓ<ÀÓD  ÀÓMÀÓS  ÀÓ\ÀÓb  ÀÒ\ÀÒ]ÀÒcÀÒ´ÀÒiÀÒdÀÒqÀÒ³ÀÒrÀÒyÀÒ~ÀÒzÀÒÀÒ‰ÀÒ‘ÀÒ™ÀÒ¡ÀÒ©ÀÒ¯ÀÒµÀÒŞÀÒ¼ÀÒ¶ÀÒ¾ÀÒØÀÒÒÀÒÚÀÓptÀÓ  ÀÓ™ÀÓ¡  ÀÓ³ÀÓ»  ÀÓÔÀÓÜ  ÀÓïÀÓõ  ÀÔ
ÀÔ  ÀÓpÀÓqÀÓÃÀÓÉÀÓÊÀÓæÀÓÿÀÔÀÔèKÀÕ„  ÀÕŸÀÕ§  ÀÕµÀÕ½  ÀÕËÀÕÓ  ÀÕáÀÕé  ÀÕ÷ÀÕÿ  ÀÖÀÖ  ÀÖ#ÀÖ)  ÀÔèÀÔéÀÔïÀÕ@ÀÔõÀÔğÀÔıÀÕ?ÀÔşÀÕÀÕ
ÀÕÀÕÀÕÀÕÀÕ%ÀÕ-ÀÕ5ÀÕ;ÀÕAÀÕrÀÕHÀÕBÀÕJÀÕlÀÕfÀÕnÀÖ7€…ÀÖH  ÀÖP	ÀÖV  ÀÖ7ÀÖ8ÀÖÀ€¼À×=  À×FÀ×N  À×S
À×[  À×_À×g  À×mÀ×u  ÀÖÀÀÖÁÀÖÇÀ×ÀÖÍÀÖÈÀÖÕÀ×ÀÖÖÀÖİÀÖâÀÖŞÀÖåÀÖíÀÖõÀÖıÀ×À×+À×À×À×À×%À×À×'À×€€…À×‘  À×™	À×Ÿ  À×€À×ÀØ	€¼ÀØ†  ÀØÀØ—  ÀØœ
ÀØ¤  ÀØ¨ÀØ°  ÀØ¶ÀØ¾  ÀØ	ÀØ
ÀØÀØMÀØÀØÀØÀØLÀØÀØ&ÀØ+ÀØ'ÀØ.ÀØ6ÀØ>ÀØFÀØNÀØtÀØUÀØOÀØWÀØnÀØhÀØpÀØÉ€ÁÀØÚ  ÀØá	ÀØç  ÀØìÀØô  ÀØÿÀÙ  ÀØÉÀØÊÀÙ€ğÀÚ  ÀÚ"ÀÚ*  ÀÚ/
ÀÚ7  ÀÚ;ÀÚC  ÀÚIÀÚQ  ÀÚXÀÚ`  ÀÚkÀÚs  ÀÙÀÙÀÙ•ÀÙâÀÙ›ÀÙ–ÀÙ£ÀÙáÀÙ¤ÀÙ«ÀÙ°ÀÙ¬ÀÙ³ÀÙ»ÀÙÃÀÙËÀÙÓÀÙÛÀÙãÀÚÀÙêÀÙäÀÙìÀÚÀÙüÀÚÀÚ‚tÀÚ“  ÀÚÀÚ¬  ÀÚ³
ÀÚ¹  ÀÚ‚ÀÚƒÀÚú€ŒÀÛZ  ÀÛfÀÛs  ÀÛz
ÀÛ€  ÀÚúÀÚûÀÛÀÛ,ÀÛÀÛÀÛÀÛ+ÀÛÀÛÀÛÀÛÀÛÀÛ'ÀÛ-ÀÛHÀÛ4ÀÛ.ÀÛ6ÀÛŠrÀÛ›  ÀÛ¤ÀÛ«  ÀÛŠÀÛ‹ÀÜ uÀÜX  ÀÜbÀÜo  ÀÜ ÀÜÀÜÀÜ,ÀÜÀÜÀÜÀÜ+ÀÜÀÜÀÜ"ÀÜÀÜ%ÀÜ-ÀÜFÀÜ4ÀÜ.ÀÜ6ÀÜySÀÜŠ  ÀÜ’	ÀÜ˜  ÀÜÀÜ¥  ÀÜ­ÀÜ»  ÀÜyÀÜzÀİĞ€ŸÀŞ>  ÀŞGÀŞT  ÀŞY	ÀŞa  ÀŞd	ÀŞl  ÀİĞÀİÑÀİ×ÀŞÀİİÀİØÀİåÀŞÀİæÀİíÀİòÀİîÀİõÀİüÀŞÀİıÀŞÀŞÀŞÀŞ,ÀŞÀŞÀŞÀŞs€ÏÀŞó  ÀßÀß  Àß	Àß   Àß#	Àß+  Àß.Àß;  ÀŞsÀŞtÀŞzÀŞ¾ÀŞ€ÀŞ{ÀŞˆÀŞ½ÀŞ‰ÀŞÀŞ•ÀŞ‘ÀŞ˜ÀŞŸÀŞ¤ÀŞ ÀŞ§ÀŞ¯ÀŞ·ÀŞ¿ÀŞáÀŞÆÀŞÀÀŞÈÀßFgÀßW  Àßf	Àßl  ÀßqÀßy  ÀßÀß  ÀßFÀßGÀà±€­Àá&  Àá6ÀáC  ÀáH	ÀáP  ÀáS	Àá[  Àà±Àà²Àà¸ÀàôÀà¾Àà¹ÀàÆÀàóÀàÇÀàÎÀàÓÀàÏÀàÖÀàİÀàâÀàŞÀàåÀàíÀàõÀáÀàüÀàöÀàşÀáb€ÛÀáè  ÀâÀâ  Àâ	Àâ  Àâ	Àâ&  Àâ)Àâ6  ÀábÀácÀáiÀá­ÀáoÀájÀáwÀá¬ÀáxÀáÀá„Àá€Àá‡ÀáÀá“ÀáÀá–ÀáÀá¦Àá®ÀáÖÀáµÀá¯Àá·ÀâAoÀâ¨   ÀâAÀâBÀâMÀâNÀâTÀâqÀâZÀâUÀâbÀâpÀâcÀâjÀâoÀâkÀârÀâ–ÀâyÀâsÀâ{ÀâÀâŠÀâ’Àâ´oÀã   Àâ´ÀâµÀâÀÀâÁÀâÇÀâäÀâÍÀâÈÀâÕÀâãÀâÖÀâİÀââÀâŞÀâåÀã	ÀâìÀâæÀâîÀãÀâıÀãÀã'zÀã8  ÀãAÀãI  Àã'Àã(Àã¥€ŒÀä  ÀäÀä%  Àä'Àä/  Àã¥Àã¦Àã¬ÀãÙÀã²Àã­ÀãºÀãØÀã»ÀãÂÀãÇÀãÃÀãÊÀãÒÀãÚÀäÀãáÀãÛÀããÀãûÀãõÀãıÀä5€¶ÀäF  ÀäLÀäT  Àä5Àä6Àäï€ÀåT  Àå[Àåa  Àåi	Àåq  Àåt	Àå|  ÀäïÀäğÀäöÀå+ÀäüÀä÷ÀåÀå*ÀåÀåÀåÀåÀåÀåÀå$Àå,ÀåBÀå3Àå-Àå5Àåƒ€¹Àå”  ÀåÀå«  ÀåƒÀå„Àæ@€Àæ¡  Àæ¬Àæ²  ÀæºÀæÇ  Àæ@ÀæAÀæGÀætÀæMÀæHÀæUÀæsÀæVÀæ]ÀæbÀæ^ÀæeÀæmÀæuÀæÀæ|ÀævÀæ~ÀæÓ€‹Àæä   ÀæÓÀæÔÀçbgÀç¼   ÀçbÀçcÀçiÀçˆÀçqÀçjÀçyÀç‡ÀçzÀçÀç†Àç‚Àç‰Àç£ÀçÀçŠÀç’ÀçÍ€¨Àè<  Àè@ÀèM  ÀèSÀè`  ÀèfÀèk  ÀçÍÀçÎÀçÔÀèÀçÚÀçÕÀçâÀèÀçãÀçêÀçïÀçëÀçòÀçùÀçşÀçúÀèÀèÀèÀè	ÀèÀèÀè*ÀèÀèÀè ÀèyuÀè‘  Àè¡Àè§  ÀèyÀèzÀè´ Àèò‡DÀéª€±/// The geometric description of a tangent: the angle at a point.
///
/// See also:
///  * [PathMetric.getTangentForOffset], which returns the tangent of an offset along a path. Àé¶€‡ ÀêÀê V/// Creates a [Tangent] with the given values.
///
/// The arguments must not be null.Àê!Àê'  Àê0Àê6   ÀêARÀëÀëÀë&€Ã/// Creates a [Tangent] based on the angle rather than the vector.
///
/// The [vector] is computed to be the unit vector at the given angle, interpreted
/// as clockwise radians from the x axis.Àë'Àë/  Àë8Àë@   Àë—€ÑÀì`€³/// Position of the tangent.
///
/// When used with [PathMetric.getTangentForOffset], this represents the precise
/// position that the given offset along the path corresponds to. ÀìmÀíl€ç/// The vector of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the vector of the
/// curve that is at the given offset along the path (i.e. the direction of the
/// curve at [position]). Àíw‚½Àğ	‚+/// The direction of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the angle of the
/// curve that is the given offset along the path (i.e. the direction of the
/// curve at [position]).
///
/// This value is in radians, with 0.0 meaning pointing along the x axis in
/// the positive x-axis direction, positive numbers pointing downward toward
/// the negative y-axis, i.e. in a clockwise direction, and negative numbers
/// pointing upward toward the positive y-axis, i.e. in a counter-clockwise
/// direction.     Àğ8„#Àó3‚ô/// An iterable collection of [PathMetric] objects describing a [Path].
///
/// A [PathMetrics] object is created by using the [Path.computeMetrics] method,
/// and represents the path as it stood at the time of the call. Subsequent
/// modifications of the path do not affect the [PathMetrics] object.
///
/// Each path metric corresponds to a segment, or contour, of a path.
///
/// For example, a path consisting of a [Path.lineTo], a [Path.moveTo], and
/// another [Path.lineTo] will contain two contours and thus be represented by
/// two [PathMetric] objects.
///
/// This iterable does not memoize. Callers who need to traverse the list
/// multiple times, or who need to randomly access elements of the list, should
/// use [toList] on this object. Àóo€‚ÀózÀó{Àó| Àó}	Àóƒ  ÀóˆÀó  ÀóªÀó Àó¬Àó¾Àó¿ÀóÀÀóïÀóÁÀóÍÀóîÀóÓÀóÎÀóÖÀóãÀóõ$Àô  Àô;ÀôC   ÀôÀô  Àô]ƒÂÀôÌh/// Used by [PathMetrics] to track iteration from one segment of a path to the
/// next for measurement. Àõ(ÀõÀõÀõ ÀõÀõ   Àõ/Àõ;  ÀõJÀõ]  ÀõnğÀõ‰   ÀõnÀõoÀ÷b€»À÷s   À÷bÀ÷c Àø!kÀû‚à/// Utilities for measuring a [Path] and extracting sub-paths.
///
/// Iterate over the object returned by [Path.computeMetrics] to obtain
/// [PathMetric] objects. Callers that want to randomly access elements or
/// iterate multiple times should use `path.computeMetrics().toList()`, since
/// [PathMetrics] does not memoize.
///
/// Once created, the metrics are only valid for the path as it was specified
/// when [Path.computeMetrics] was called. If additional contours are added or
/// any contours are updated, the metrics need to be recomputed. Previously
/// created metrics will still refer to a snapshot of the path at the time they
/// were computed, rather than to the actual metrics for the new mutations to
/// the path. Àû€ÎÀû!Àû"Àû# Àû$Àû*  Àû@Àû9ÀûBÀûJÀûKÀûQÀûnÀûRÀûZÀû[Àû€ÀûwÀû‚ÀûŠÀû‹Àû“Àû°Àû”ÀûœÀûÀûÆÀû¹ÀûÈÀûĞÀûÑÀûé+Àı/// Return the total length of the current contour.
///
/// The length may be calculated from an approximation of the geometry
/// originally added. For this reason, it is not recommended to rely on
/// this property for mathematically correct lengths of common shapes. ÀıAÀşR!/// Whether the contour is closed.
///
/// Returns true if the contour ends with a call to [Path.close] (which may
/// have been implied when using methods like [Path.addRect]) or if
/// `forceClosed` was specified as true in the call to [Path.computeMetrics].
/// Returns false otherwise. Àş_‚àÀ3‚±/// The zero-based index of the contour.
///
/// [Path] objects are made up of zero or more contours. The first contour is
/// created once a drawing command (e.g. [Path.lineTo]) is issued. A
/// [Path.moveTo] command after a drawing command may create a new contour,
/// although it may not if optimizations are applied that determine the move
/// command did not actually result in moving the pen.
///
/// This property is only valid with reference to its original iterator and
/// the contours of the path at the time the path's metrics were computed. If
/// additional contours were added or existing contours updated, this metric
/// will be invalid for the current state of the path. ÀDÀW   Àd‚,À%£/// Computes the position of the current contour at the given offset, and the
/// angle of the path at that point.
///
/// For example, calling this method with a distance of 1.41 for a line from
/// 0.0,0.0 to 2.0,2.0 would give a point 1.0,1.0 and the angle 45 degrees
/// (but in radians).
///
/// Returns null if the contour has zero [length].
///
/// The distance is clamped to the [length] of the current contour. À9ÀA   À”Àn€Ì/// Given a start and end distance, return the intervening segment(s).
///
/// `start` and `end` are clamped to legal values (0..[length])
/// Begin the segment with a moveTo if `startWithMoveTo` is true. ÀzÀ‚  Àˆ
À  À•À›  À¬ÀqÀ,   ÀÀ À‹À™  ÀË[ ÀËÀ× ÀØÀå  ÀêÀğ   Àó€¯ÀŠ€Œ/// The index of the current contour in the list of contours in the path.
///
/// [nextContour] will increment this to the zero based index.À À¡ À*€”À  ÀšÀ§  À¬À²  À*À+À1À\À7À2À?À[À@ÀHÀOÀTÀPÀWÀ]À{ÀdÀ^ÀfÀÂ€½ÀÉ  ÀĞÀÕ   Àƒ€‹Àô  ÀüÀ  ÀƒÀ„ÀŠÀ°À’À‹ÀšÀ¯À›À¢À§À£ÀªÀ±ÀàÀ¸À²ÀºÀÚÀÔÀÜÀíÀ  À/À4  ÀAÀI   À
€À
s  À
~À
ƒ  À
À
˜  À
À
À

À
8À
À
À
À
7À
À
"À
'À
#À
*À
1À
9À
ZÀ
@À
:À
BÀ
¥_À
ª  À
¶À
»  À
ÈÀ
Ğ  À
Ö
À
Ş  À
éÀ
ï  À À€ÛÀ†  À“À™  À¡À¦  À³À»  ÀÁ
ÀÉ  ÀÍÀÓ  ÀÀ	ÀÀQÀÀÀÀPÀÀ%À*À&À-À5À<ÀDÀLÀRÀtÀYÀSÀ[Àç€¿Àì  ÀõÀú   Àª€ˆÀ  À À%  ÀªÀ«À±ÀÕÀ·À²À¿ÀÔÀÀÀÇÀÌÀÈÀÏÀÖÀÀİÀ×ÀßÀşÀøÀ Àå€‰Àê    Àr}ÀÚ   ÀrÀsÀyÀ–ÀÀzÀ‡À•ÀˆÀÀ”ÀÀ—ÀÈÀÀ˜À ÀÂÀ¼ÀÄ À$†|À./// A mask filter to apply to shapes as they are painted. A mask filter is a
/// function that takes a bitmap of color pixels, and returns another bitmap of
/// color pixels.
///
/// Instances of this class are used with [Paint.maskFilter] on [Paint] objects. À=ƒÀÀÀ‚¥/// Creates a mask filter that takes the shape being drawn and blurs it.
///
/// This is commonly used to approximate shadows.
///
/// The `style` argument controls the kind of effect to draw; see [BlurStyle].
///
/// The `sigma` argument controls the size of the effect. It is the standard
/// deviation of the Gaussian blur to apply. The value must be greater than
/// zero. The sigma corresponds to very roughly half the radius of the effect
/// in pixels.
///
/// A blur is an expensive operation and should therefore be used sparingly.
///
/// The arguments must not be null.
///
/// See also:
///
///  * [Canvas.drawShadow], which is a more efficient way to draw shadows.À"À(  À3À9   ÀHÀX  ÀbÀo  ÀÀ À(À5ÀF ÀRÀ<À   ÀÀÀl€”À†  À‰À‘  ÀlÀmÀDZÀW   ÀDÀE À¢™kÀmÄ/// A description of a color filter to apply when drawing a shape or compositing
/// a layer with a particular [Paint]. A color filter is a function that takes
/// two colors, and outputs one color. When applied during compositing, it is
/// independently applied to each pixel of the layer being drawn before the
/// entire layer is merged with the destination.
///
/// Instances of this class are used with [Paint.colorFilter] on [Paint]
/// objects. À”‚XÀYÀZÀ^¥/// Creates a color filter that applies the blend mode given as the second
/// argument. The source color is the one given as the first argument, and the
/// destination color is the one from the layer being composited.
///
/// The output of this filter is then composited into the background according
/// to the [Paint.blendMode], using the output of this filter as the source
/// and the background as the destination.À_Àf  ÀlÀw  ÀÀ‰À’À¬À¡À®ÀÉÀÁÀËÀßÀÙÀáÀğˆEÀ&¯À&°À&¶‡7/// Construct a color filter from a 4x5 row-major matrix. The matrix is
/// interpreted as a 5x5 matrix, where the fifth row is the identity
/// configuration.
///
/// Every pixel's color value, represented as an `[R, G, B, A]`, is matrix
/// multiplied to create a new color:
///
///     | R' |   | a00 a01 a02 a03 a04 |   | R |
///     | G' |   | a10 a11 a12 a13 a14 |   | G |
///     | B' | = | a20 a21 a22 a23 a24 | * | B |
///     | A' |   | a30 a31 a32 a33 a34 |   | A |
///     | 1  |   |  0   0   0   0   1  |   | 1 |
///
/// The matrix is in row-major order and the translation column is specified
/// in unnormalized, 0...255, space. For example, the identity matrix is:
///
/// ```dart
/// const ColorFilter identity = ColorFilter.matrix(<double>[
///   1, 0, 0, 0, 0,
///   0, 1, 0, 0, 0,
///   0, 0, 1, 0, 0,
///   0, 0, 0, 1, 0,
/// ]);
/// ```
///
/// ## Examples
///
/// An inversion color matrix:
///
/// ```dart
/// const ColorFilter invert = ColorFilter.matrix(<double>[
///   -1,  0,  0, 0, 255,
///    0, -1,  0, 0, 255,
///    0,  0, -1, 0, 255,
///    0,  0,  0, 1,   0,
/// ]);
/// ```
///
/// A sepia-toned color matrix (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#sepiaEquivalent)):
///
/// ```dart
/// const ColorFilter sepia = ColorFilter.matrix(<double>[
///   0.393, 0.769, 0.189, 0, 0,
///   0.349, 0.686, 0.168, 0, 0,
///   0.272, 0.534, 0.131, 0, 0,
///   0,     0,     0,     1, 0,
/// ]);
/// ```
///
/// A greyscale color filter (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#grayscaleEquivalent)):
///
/// ```dart
/// const ColorFilter greyscale = ColorFilter.matrix(<double>[
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0,      0,      0,      1, 0,
/// ]);
/// ```À&·À&Å  À&ÛÀ&ÔÀ&İÀ&öÀ&ëÀ&øÀ'À'À'À'&À' À'(À'9€ôÀ'¦À'§À'¸W/// Construct a color filter that applies the sRGB gamma curve to the RGB
/// channels. À'ÊÀ'ÃÀ'ÌÀ'åÀ'ÚÀ'çÀ'ıÀ'õÀ'ÿÀ(À(À(À(1À(«À(¬À(½d/// Creates a color filter that applies the inverse of the sRGB gamma curve
/// to the RGB channels. À(ÏÀ(ÈÀ(ÑÀ(êÀ(ßÀ(ìÀ)À(úÀ)À)À)À)À)6À)C  À)MÀ)^  À)lÀ)€  À)‹À)•  À)ÏÀ)à À)íÀ*!À* À*$À*H,À*Y À*sÀ*‘,À*¢ À*¼À/f€¯À/z   À/fÀ/gÀ0ÁÀ00   À0À0À*óVÀ+   À*óÀ*ôÀ+M‚×À+[    À.(:À.B  À.EÀ.M  À.(À.)À1Ş‚-À1ñ   À1ŞÀ1ß À4‡jÀ5_D/// A [ColorFilter] that is backed by a native DlColorFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ColorFilter, because we want ColorFilter to be const constructible and
/// efficiently comparable, so that widgets can check for ColorFilter equality to
/// avoid repainting. À5‘€°À5À5À5¢ À5£À5©  
À5·À5½À5åÀ5ÌÀ5¾À5ÅÀ5ÆÀ5ÏÀ5ÚÀ5ÛÀ6E€¬À6QÀ6RÀ6X À6YÀ6_  
À6mÀ6sÀ6À6‚À6tÀ6{À6|À6…À6À6‘À6ô€§À7 À7À7 À7À7  
À7'À7-À7bÀ7<À7.À75À76À7?À7JÀ7KÀ7Ÿ€§À7«À7¬À7½ À7¾À7Ä  
À7ÒÀ7ØÀ8À7çÀ7ÙÀ7àÀ7áÀ7êÀ7õÀ7öÀ8J€À8Ğo/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  À8Ü]À9*   À8ÜÀ8İÀ8ãÀ8ùÀ8éÀ8äÀ8ñÀ8øÀ8òÀ8úÀ9À9À8ûÀ9À9=€—À9°  À9º	À9¿  À9ÅÀ9Ê  À9=À9>À9DÀ9oÀ9JÀ9EÀ9RÀ9nÀ9SÀ9ZÀ9_À9[À9bÀ9iÀ9pÀ9À9wÀ9qÀ9yÀ9˜À9’À9šÀ9Ø€À:9  À:EÀ:R  À9ØÀ9ÙÀ9ßÀ:À9åÀ9àÀ9íÀ:À9îÀ9õÀ9úÀ9öÀ9ıÀ:À:'À:À:À:À:]€‹À:Ï   À:]À:^À:dÀ:À:jÀ:eÀ:rÀ:€À:sÀ:zÀ:À:{À:‚À:½À:‰À:ƒÀ:‹À:·À:±À:¹À:ì€‹À;^   À:ìÀ:íÀ:óÀ;À:ùÀ:ôÀ;À;À;À;	À;À;
À;À;LÀ;À;À;À;FÀ;@À;H À;{‹À=]Ò/// A filter operation to apply to a raster image.
///
/// See also:
///
///  * [BackdropFilter], a widget that applies [ImageFilter] to its rendering.
///  * [ImageFiltered], a widget that applies [ImageFilter] to its children.
///  * [SceneBuilder.pushBackdropFilter], which is the low-level API for using
///    this class as a backdrop filter.
///  * [SceneBuilder.pushImageFilter], which is the low-level API for using
///    this class as a child layer filter. À=¿À=ÊÀ=ËÀ=Ì   À=íÀ><À>=À>A9/// Creates an image filter that applies a Gaussian blur.À>DÀ>L  À>YÀ>a  À>n"À>x  À>TÀ>iÀ>‚À>ŠÀ>‹À>ö&À?œÀ?À?£€/// Creates an image filter that dilates each input pixel's channel values
/// to the max value within the given radii along the x and y axes.À?¦À?®  À?¼À?Ä  À?·À?ÍÀ@ 'À@ÉÀ@ÊÀ@Ï€‘/// Create a filter that erodes each input pixel's channel values
/// to the minimum channel value within the given radii along the x and y axes.À@ÒÀ@Ú  À@èÀ@ğ  À@ãÀ@ùÀAK‚'ÀB@ÀBAÀBG€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.ÀBHÀBU  ÀBt/ÀBƒ  ÀB’ÀBŸÀB ÀCv ÀD„ÀD…ÀDŒ€ğ/// Composes the `inner` filter with `outer`, to combine their effects.
///
/// Creates a single [ImageFilter] that when applied, has the same effect as
/// subsequently applying `inner` and `outer`, i.e.,
/// result = outer(inner(source)).ÀDÀD¥  ÀD«ÀDÁ    ÀFaÀFl    ÀE¸$ÀEÅ     ÀF‚ƒ`ÀFˆ  ÀF¶H ÀF¶ÀFÈ ÀFËÀFÚ  ÀFßÀFî   ÀGÀG  ÀG!ÀG0  ÀGc@ÀG{ ÀGŠÀG–ÀG—ÀGÀG¢ÀGÀGëLÀH   ÀGëÀGìÀIQÀI£   ÀIÀIÀG§@ÀGÀ   ÀG§ÀG¨ÀH;MÀHN   ÀH;ÀH<ÀHŒ€ÿÀH¦  ÀH©ÀH±  ÀHŒÀH ÀIä„tÀIê  ÀJa ÀJÀJ6 ÀJ9ÀJH  ÀJOÀJ^  ÀJeÀJt   ÀJƒÀJ  ÀJšÀJ§  ÀJ±ÀJÀ  ÀJá>ÀJù ÀKÀKÀKÀKÀKÀKÀKg€îÀKr    ÀLYSÀLp   ÀLYÀLZÀN<ÀN.   ÀNÀNÀK#@ÀK<   ÀK#ÀK$ÀL°TÀLÃ   ÀL°ÀL±ÀMÀM"  ÀM%ÀM-  ÀMÀM	 ÀNZ‚ûÀN`  ÀNE ÀNÀN  ÀN£ÀN²  ÀNºÀNÉ   ÀN×ÀNä  ÀNïÀNü  ÀO@ÀO  ÀO/ÀO;ÀO<ÀOBÀOGÀOCÀOIÀO§   ÀOÀO‘ÀQ>ÀQ)   ÀQÀQÀOL@ÀOe   ÀOLÀOMÀOİJÀOğ   ÀOİÀOŞÀP+€æÀPE  ÀPHÀPP  ÀP+ÀP, ÀQW‚õÀQ]  ÀQŠD ÀQŠÀQ› ÀQÀQ­  ÀQµÀQÄ   ÀQÒÀQß  ÀQêÀQ÷  ÀR?ÀR ÀR*ÀR6ÀR7ÀR<ÀRAÀR=ÀRŠHÀR¡   ÀRŠÀR‹ÀT>ÀT    ÀTÀTÀRF@ÀR_   ÀRFÀRGÀRÖIÀRé   ÀRÖÀR×ÀS#€åÀS=  ÀS@ÀSH  ÀS#ÀS$ ÀTNƒ‹ÀTT  ÀTƒN ÀTƒÀT– ÀT™ÀT¨  ÀT´ÀTÃ   ÀTÕÀTç  ÀTöÀU  ÀU2BÀUJ ÀUYÀUeÀUfÀUnÀUsÀUoÀU¼sÀUÓ   ÀU¼ÀU½ÀW‘FÀW¥   ÀW‘ÀW’ÀUx@ÀU‘   ÀUxÀUyÀV3_ÀVF   ÀV3ÀV4ÀV–€÷ÀV°  ÀV³ÀV»  ÀV–ÀV— ÀWÛöÀY)/// An [ImageFilter] that is backed by a native DlImageFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ImageFilter, because we want ImageFilter to be efficiently comparable, so that
/// widgets can check for ImageFilter equality to avoid repainting. ÀYB€ãÀYŠÀY‹ÀY9/// Creates an image filter that applies a Gaussian blur.ÀYÀYª  ÀY¿ÀY·ÀYÁÀZ)#ÀZÈÀZÉÀZÏ€/// Creates an image filter that dilates each input pixel's channel values
/// to the max value within the given radii along the x and y axes.ÀZĞÀZä  ÀZùÀZñÀZûÀ[P#À[òÀ[óÀ[ø€‘/// Create a filter that erodes each input pixel's channel values
/// to the minimum channel value within the given radii along the x and y axes.À[ùÀ\  À\!À\À\#À\wãÀ]eÀ]fÀ]l€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.À]mÀ]  À]–À]À]˜À^^€ıÀ^œÀ^À^¬//// Converts a color filter to an image filter.À^­À^º  À^ÏÀ^ÇÀ^ÑÀ__zÀ_À_ŸÀ_§0/// Composes `_innerFilter` with `_outerFilter`.À_¨À_½  À_ÒÀ_ÊÀ_ÔÀeA€ÀeÇo/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  À`İ]Àa+   À`İÀ`ŞÀ`äÀ`úÀ`êÀ`åÀ`òÀ`ùÀ`óÀ`ûÀaÀaÀ`üÀaÀa>€²Àaº  ÀaÄÀaÌ  ÀaÓÀaÛ  ÀaâÀaç  Àa>Àa?ÀaEÀayÀaKÀaFÀaSÀaxÀaTÀa[Àa`Àa\ÀacÀakÀasÀazÀa¨ÀaÀa{ÀaƒÀa¢ÀaœÀa¤Àaô€£Àbk  ÀbwÀb  Àb‡Àb  ÀaôÀaõÀaûÀb(ÀbÀaüÀb	Àb'Àb
ÀbÀbÀbÀbÀb!Àb)ÀbYÀb0Àb*Àb2ÀbSÀbMÀbUÀb›€¡Àc  ÀcÀc$  Àc,Àc4  Àb›ÀbœÀb¢ÀbÏÀb¨Àb£Àb°ÀbÎÀb±Àb¸Àb½Àb¹ÀbÀÀbÈÀbĞÀbÿÀb×ÀbÑÀbÙÀbùÀbóÀbûÀc@€œÀc¨  Àc´ÀcÁ  ÀcÉÀcÎ  Àc@ÀcAÀcGÀcsÀcMÀcHÀcUÀcrÀcVÀc]ÀcbÀc^ÀceÀcmÀctÀc–Àc{ÀcuÀc}Àcà€™ÀdM  Àd^Àdm  ÀcàÀcáÀcçÀdÀcíÀcèÀcõÀdÀcöÀcıÀdÀcşÀdÀdÀdÀdÀdÀd;ÀdÀdÀdÀd}€ÀÀdû  Àe	Àe  Àe#Àe1  Àd}Àd~Àd„Àd¿ÀdŠÀd…Àd’Àd¾Àd“ÀdšÀdŸÀd›Àd¢Àd©Àd®ÀdªÀd±Àd¸Àd½Àd¹ÀdÀÀdéÀdÇÀdÁÀdÉ ÀeÓ„ëÀfYz/// Base class for objects such as [Gradient] and [ImageShader] which
/// correspond to shaders as used by [Paint.shader]. Àf…€ÀgÀgÀga/// This class is created by the engine, and should not be instantiated
/// or extended directly. ÀfëÀfìÀfòÀgÀfóÀgÀg Àg,Àg6Àg¿y/// Whether [dispose] has been called.
///
/// This must only be used when asserts are enabled. Otherwise, it will throw.   ÀhQ‚kÀjDÛ/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// The underlying memory allocated by this object will be retained beyond
/// this call if it is still needed by another object that has not been
/// disposed. For example, a [Picture] that has not been disposed that
/// refers to an [ImageShader] may keep its underlying resources alive.
///
/// Classes that override this method must call `super.dispose()`.    Àu©À‚Á@/// A shader (as used by [Paint.shader]) that renders a color gradient.
///
/// There are several types of gradients, represented by the various constructors
/// on this class.
///
/// See also:
///
///  * [Gradient](https://api.flutter.dev/flutter/painting/Gradient-class.html), the class in the [painting] library.
/// À‚İ‰À‰&À‰'À‰-†/// Creates a linear gradient from `from` to `to`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries). Stop values less than 0.0
/// will be rounded up to 0.0 and stop values greater than 1.0 will be rounded
/// down to 1.0. Each stop value must be greater than or equal to the previous
/// stop value. Stop values that do not meet this criteria will be rounded up
/// to the previous stop value.
///
/// The behavior before `from` and after `to` is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
///
/// If `from`, `to`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.À‰3À‰;  À‰D	À‰L  À‰SÀ‰`  À‰mÀ‰|  À‰‹"À‰•  À‰³À‰Á  !À‰ŸÀ‰§À‰¨À‰ĞÀ‰ÖÀ‰ëÀ‰×À‰åÀ‰êÀ‰æÀ‰õÀ‰ûÀŠÀ‰üÀŠ
ÀŠÀŠÀŠÀŠÀŠJÀŠ/ÀŠ'ÀŠÀŠ*ÀŠ2ÀŠAÀŠIÀŠBÀŠTÀŠYÀŠZÀŠ[ÀŠ\À‹ìŒøÀ”À”À”#‡ã/// Creates a radial gradient centered at `center` that ends at `radius`
/// distance from the center.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries). Stop values less than 0.0
/// will be rounded up to 0.0 and stop values greater than 1.0 will be rounded
/// down to 1.0. Each stop value must be greater than or equal to the previous
/// stop value. Stop values that do not meet this criteria will be rounded up
/// to the previous stop value.
///
/// The behavior before and after the radius is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
///
/// If `center`, `radius`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.
///
/// If `focal` is provided and not equal to `center` and `focalRadius` is
/// provided and not equal to 0.0, the generated shader will be a two point
/// conical radial gradient, with `focal` being the center of the focal
/// circle and `focalRadius` being the radius of that circle. If `focal` is
/// provided and not equal to `center`, at least one of the two offsets must
/// not be equal to [Offset.zero].À”)À”1  À”<À”D  À”OÀ”\  À”iÀ”x  À”‡"À”‘  À”¯À”½  À”ÉÀ”Ò  À”ÜÀ”ä  À”›À”£À”¤À”ñÀ”üÀ•À•À•À•À•À•À•#À•)À•UÀ•:À•2À•*À•5À•=À•LÀ•TÀ•MÀ•_À•dÀ•eÀ•fÀ•gÀ˜èŠIÀ bÀ cÀ h‡3/// Creates a sweep gradient centered at `center` that starts at `startAngle`
/// and ends at `endAngle`.
///
/// `startAngle` and `endAngle` should be provided in radians, with zero
/// radians being the horizontal line to the right of the `center` and with
/// positive angles going clockwise around the `center`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries). Stop values less than 0.0
/// will be rounded up to 0.0 and stop values greater than 1.0 will be rounded
/// down to 1.0. Each stop value must be greater than or equal to the previous
/// stop value. Stop values that do not meet this criteria will be rounded up
/// to the previous stop value.
///
/// The behavior before `startAngle` and after `endAngle` is described by the
/// `tileMode` argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png)
///
/// If `center`, `colors`, `tileMode`, `startAngle`, or `endAngle` are null,
/// or if `colors` or `colorStops` contain null values, this constructor will
/// throw a [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.À nÀ v  À À   À ›À ª  À ¹"À Ã  À áÀ é  À şÀ¡  À¡!À¡/  &À ÍÀ ÕÀ ÖÀ õÀ¡À¡À¡À¡À¡À¡>À¡DÀ¡[À¡EÀ¡SÀ¡ZÀ¡TÀ¡eÀ¡kÀ¡À¡wÀ¡lÀ¡yÀ¡‹À¡‘À¡½À¡¢À¡šÀ¡’À¡À¡¥À¡´À¡¼À¡µÀ¡ÇÀ¡ÌÀ¡ÍÀ¡ÎÀ¡Ï  À£5ZÀ£€   À£5À£6À£<À£RÀ£BÀ£=À£JÀ£QÀ£KÀ£SÀ£nÀ£ZÀ£TÀ£\À£“€ïÀ¤  À¤À¤)  À¤3À¤>  À¤EÀ¤S  À¤^À¤c  À¤lÀ¤z  À£“À£”À£šÀ£ŞÀ£ À£›À£¨À£İÀ£©À£°À£µÀ£±À£¸À£ÀÀ£ÈÀ£ĞÀ£×À£ßÀ£şÀ£æÀ£àÀ£èÀ¤†BÀ¥  À¥&À¥.  À¥<À¥D  À¥RÀ¥Z  À¥gÀ¥r  À¥À¥  À¥À¥£  À¥²À¥À  À¤†À¤‡À¤À¤áÀ¤“À¤À¤›À¤àÀ¤œÀ¤£À¤¨À¤¤À¤«À¤³À¤»À¤ÃÀ¤ËÀ¤ÓÀ¤ÚÀ¤âÀ¥À¤éÀ¤ãÀ¤ëÀ¥Ì¥À¦z  
À¦À¦–  À¦£À¦«  À¦¸À¦À  À¦ÒÀ¦Ú  À¦åÀ¦í  À¦øÀ§   À§À§  À§(À§6  À§GÀ§L  À§[À§i  À¥ÌÀ¥ÍÀ¥ÓÀ¦?À¥ÙÀ¥ÔÀ¥áÀ¦>À¥âÀ¥éÀ¥îÀ¥êÀ¥ñÀ¥ùÀ¦À¦	À¦À¦À¦!À¦)À¦1À¦8À¦@À¦hÀ¦GÀ¦AÀ¦IÀ§ubÀ¨	  À¨À¨#  À¨1À¨9  À¨GÀ¨R  À¨_À¨m  À¨~À¨ƒ  À¨’À¨š  À¨«À¨³  À¨ÂÀ¨Ğ  À§uÀ§vÀ§|À§ØÀ§‚À§}À§ŠÀ§×À§‹À§’À§—À§“À§šÀ§¢À§ªÀ§²À§ºÀ§ÁÀ§ÉÀ§ÑÀ§ÙÀ§÷À§àÀ§ÚÀ§âÀ¨ÛŸÀ¨ç  À©À©  À©À©%    Àª~ˆlÀªÇ=/// A shader (as used by [Paint.shader]) that tiles an image. Àªæ…– À®ªÀ®µƒ/// Creates an image-tiling shader.
///
/// The first argument specifies the image to render. The
/// [decodeImageFromList] function can be used to decode an image from bytes
/// into the form expected here. (In production code, starting from
/// [instantiateImageCodec] may be preferable.)
///
/// The second and third arguments specify the [TileMode] for the x direction
/// and y direction respectively. [TileMode.repeated] can be used for tiling
/// images.
///
/// The fourth argument gives the matrix to apply to the effect. The
/// expression `Matrix4.identity().storage` creates a [Float64List]
/// prepopulated with the identity matrix.
///
/// All the arguments are required and must not be null, except for
/// [filterQuality]. If [filterQuality] is not specified at construction time
/// it will be deduced from the environment where it is used, such as from
/// [Paint.filterQuality].À®¶À®½  À®ÃÀ®Í  À®ÑÀ®Û  À®ßÀ®ì  À®úÀ¯
  À®À®À®•À®¦À®–À¯#À¯)À¯>À¯*À¯+À¯0À¯1À¯EÀ¯JÀ¯KÀ¯LÀ¯M  À°€EÀ°‘   À°€À°À°É]À±   À°ÉÀ°ÊÀ°ĞÀ°æÀ°ÖÀ°ÑÀ°ŞÀ°åÀ°ßÀ°çÀ±À°îÀ°èÀ°ğÀ±*€éÀ±·  À±ÆÀ±Î  À±ÔÀ±Ù  À±İÀ±â  À±æÀ±ë  À±şÀ²  À±*À±+À±1À±|À±9À±2À±AÀ±{À±BÀ±IÀ±NÀ±JÀ±QÀ±XÀ±]À±YÀ±`À±gÀ±nÀ±uÀ±}À±¢À±„À±~À±†À²€ÑÀ²İk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À²‡À²ˆÀ²À²«À²”À²À²œÀ²ªÀ²À²¤À²©À²¥À²¬À²ËÀ²³À²­À²µ À²ìŒÏÀ³Ô€Ü/// An instance of [FragmentProgram] creates [Shader] objects (as used by
/// [Paint.shader]).
///
/// For more information, see the website
/// [documentation]( https://docs.flutter.dev/development/ui/advanced/shaders). À´	!À´4À´5À´? À´@À´H  À´	À´
À´À´!À´Àµ.Àµ6  ÀºĞ{À»	 	À»IÀ»JÀ»!À»HÀ»"À»*À»7À»GÀ»8À½Ì7À½ñ À½ÌÀ½ÍÀ½ÓÀ½äÀ½ÔÀ¾2À¾- À¾À¾	À¾À¾ À¾ ÀµE„SÀ¶ //// Creates a fragment program from the asset with key [assetKey].
///
/// The asset must be a file produced as the output of the `impellerc`
/// compiler. The constructed object should then be reused via the
/// [fragmentShader] method to create [Shader] objects that can be used by
/// [Paint.shader]. À¶ªÀ¶²   À»P‚xÀ»\  À»pÀ»x   À¾?aÀ¾‘   À¾?À¾@À¾FÀ¾\À¾LÀ¾GÀ¾TÀ¾[À¾UÀ¾]À¾À¾dÀ¾^À¾fÀ¾¤€ŒÀ¿  À¿À¿'  À¾¤À¾¥À¾«À¾ÒÀ¾³À¾¬À¾»À¾ÑÀ¾¼À¾ÃÀ¾ÈÀ¾ÄÀ¾ËÀ¾ÓÀ¾üÀ¾ÚÀ¾ÔÀ¾ÜÀ¿4€…À¿w1/// Returns a fresh instance of [FragmentShader].    À¿½‘şÀÂ®‚å/// A [Shader] generated from a [FragmentProgram].
///
/// Instances of this class can be obtained from the
/// [FragmentProgram.fragmentShader] method. The float uniforms list is
/// initialized to the size expected by the shader and is zero-filled. Uniforms
/// of float type can then be set by calling [setFloat]. Sampler uniforms are
/// set by calling [setImageSampler].
///
/// A [FragmentShader] can be re-used, and this is an efficient way to avoid
/// allocating and re-initializing the uniform buffer and samplers. However,
/// if two [FragmentShader] objects with different float uniforms or samplers
/// are required to exist simultaneously, they must be obtained from two
/// different calls to [FragmentProgram.fragmentShader]. ÀÂĞ€ÛÀÂŞÀÂßÀÂà ÀÂáÀÂò  ÀÂüÀÃ  ÀÃÀÃÀÃ ÀÃ+ÀÃ0ÀÃ1ÀÃ2ÀÃ3ÀÃ¯ÀÃ½  ÀÃÌ<ÀÃå ÀÃúÀÄÀÄÀÄÀÄ(ÀÄ ÀÄ" ÀÄ9‡ÀË1†œ/// Sets the float uniform at [index] to [value].
///
/// All uniforms defined in a fragment shader that are not samplers must be
/// set through this method. This includes floats and vec2, vec3, and vec4.
/// The correct index for each uniform is determined by the order of the
/// uniforms as defined in the fragment program, ignoring any samplers. For
/// data types that are composed of multiple floats such as a vec4, more than
/// one call to [setFloat] is required.
///
/// For example, given the following uniforms in a fragment program:
///
/// ```glsl
/// uniform float uScale;
/// uniform sampler2D uTexture;
/// uniform vec2 uMagnitude;
/// uniform vec4 uColor;
/// ```
///
/// Then the corresponding Dart code to correctly initialize these uniforms
/// is:
///
/// ```dart
/// void updateShader(ui.FragmentShader shader, Color color, ui.Image image) {
///   shader.setFloat(0, 23);  // uScale
///   shader.setFloat(1, 114); // uMagnitude x
///   shader.setFloat(2, 83);  // uMagnitude y
///
///   // Convert color to premultiplied opacity.
///   shader.setFloat(3, color.red / 255 * color.opacity);   // uColor r
///   shader.setFloat(4, color.green / 255 * color.opacity); // uColor g
///   shader.setFloat(5, color.blue / 255 * color.opacity);  // uColor b
///   shader.setFloat(6, color.opacity);                     // uColor a
///
///   // initialize sampler uniform.
///   shader.setImageSampler(0, image);
/// }
/// ```
///
/// Note how the indexes used does not count the `sampler2D` uniform. This
/// uniform will be set separately with [setImageSampler], with the index starting
/// over at 0.
///
/// Any float uniforms that are left uninitialized will default to `0`. ÀË:	ÀË?  ÀËEÀËM   ÀËÍüÀÍ</// Sets the sampler uniform at [index] to [image].
///
/// The index provided to setImageSampler is the index of the sampler uniform defined
/// in the fragment program, excluding all non-sampler uniforms.
///
/// All the sampler uniforms that a shader expects must be provided or the
/// results will be undefined. ÀÍ-	ÀÍ2  ÀÍ8ÀÍ?   ÀÍÍ…ÀÎü/// Releases the native resources held by the [FragmentShader].
///
/// After this method is called, calling methods on the shader, or attaching
/// it to a [Paint] object will fail with an exception. Calling [dispose]
/// twice will also result in an exception being thrown.  ÀÎëÀÎìÀÏV€ÈÀÏĞ  ÀÏİÀÏî  ÀÏöÀÏû  ÀĞ	ÀĞ  ÀÏVÀÏWÀÏ]ÀÏÀÏeÀÏ^ÀÏmÀÏŒÀÏnÀÏvÀÏ~ÀÏ†ÀÏÀÏ·ÀÏ•ÀÏÀÏ—ÀĞ"€¥ÀĞ›  ÀĞ¬	ÀĞ±  ÀĞ·ÀĞ¿  ÀĞ"ÀĞ#ÀĞ)ÀĞVÀĞ/ÀĞ*ÀĞ7ÀĞUÀĞ8ÀĞ?ÀĞDÀĞ@ÀĞGÀĞOÀĞWÀĞ‰ÀĞ^ÀĞXÀĞ`ÀĞË~ÀÑ5   ÀĞËÀĞÌÀĞÒÀĞïÀĞØÀĞÓÀĞàÀĞîÀĞáÀĞèÀĞíÀĞéÀĞğÀÑ#ÀĞ÷ÀĞñÀĞùÀÑMlÀÑ®   ÀÑMÀÑNÀÑTÀÑqÀÑZÀÑUÀÑbÀÑpÀÑcÀÑjÀÑoÀÑkÀÑrÀÑœÀÑyÀÑsÀÑ{ ÀÔ‚¬ÀÜüˆn/// A set of vertex data used by [Canvas.drawVertices].
///
/// Vertex data consists of a series of points in the canvas coordinate space.
/// Based on the [VertexMode], these points are interpreted either as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single shared
/// point ([VertexMode.triangleFan]).
///
/// Each point can be associated with a color. Each triangle is painted as a
/// gradient that blends between the three colors at the three points of that
/// triangle. If no colors are specified, transparent black is assumed for all
/// the points.
///
/// These colors are then blended with the [Paint] specified in the call to
/// [Canvas.drawVertices]. This paint is either a solid color ([Paint.color]),
/// or a bitmap, specified using a shader ([Paint.shader]), typically either a
/// gradient ([Gradient]) or image ([ImageFilter]). The bitmap uses the same
/// coordinate space as the canvas (in the case of an [ImageFilter], this is
/// notably different than the coordinate space of the source image; the source
/// image is tiled according to the filter's configuration, and the image that
/// is sampled when painting the triangles is the infinite one after all the
/// repeating is applied.)
///
/// Each point in the [Vertices] is associated with a specific point on this
/// image. Each triangle is painted by sampling points from this image by
/// interpolating between the three points of the image corresponding to the
/// three points of the triangle.
///
/// The [Vertices.new] constructor configures all this using lists of [Offset]
/// and [Color] objects. The [Vertices.raw] constructor instead uses
/// [Float32List], [Int32List], and [Uint16List] objects, which more closely
/// corresponds to the data format used internally and therefore reduces some of
/// the conversion overhead. The raw constructor is useful if the data is coming
/// from another source (e.g. a file) and can therefore be parsed directly into
/// the underlying representation. Àİ*é Àæ+Àæ3ˆ¬/// Creates a set of vertex data for use with [Canvas.drawVertices].
///
/// The `mode` parameter describes how the points should be interpreted: as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single
/// shared point ([VertexMode.triangleFan]).
///
/// The `positions` parameter provides the points in the canvas space that
/// will be use to draw the triangles.
///
/// The `colors` parameter, if specified, provides the color for each point in
/// `positions`. Each triangle is painted as a gradient that blends between
/// the three colors at the three points of that triangle. (These colors are
/// then blended with the [Paint] specified in the call to
/// [Canvas.drawVertices].)
///
/// The `textureCoordinates` parameter, if specified, provides the points in
/// the [Paint] image to sample for the corresponding points in `positions`.
///
/// If the `colors` or `textureCoordinates` parameters are specified, they must
/// be the same length as `positions`.
///
/// The `indices` parameter specifies the order in which the points should be
/// painted. If it is omitted (or present but empty), the points are processed
/// in the order they are given in `positions`, as if the `indices` was a list
/// from 0 to n-1, where _n_ is the number of entries in `positions`. The
/// `indices` parameter, if present and non-empty, must have at least three
/// entries, but may be of any length beyond this. Indicies may refer to
/// offsets in the positions array multiple times, or may skip positions
/// entirely.
///
/// If the `indices` parameter is specified, all values in the list must be
/// valid index values for `positions`.
///
/// The `mode` and `positions` parameters must not be null.
///
/// This constructor converts its parameters into [dart:typed_data] lists
/// (e.g. using [Float32List]s for the coordinates) before sending them to the
/// Flutter engine. If the data provided to this constructor is not already in
/// [List] form, consider using the [Vertices.raw] constructor instead to
/// avoid converting the data twice.Àæ9ÀæE  ÀæNÀæ\  ÀælÀæz  Àæ… Àæ”  Àæ«Àæ·   ÀìWÀö Àö¡Àö¤Š(/// Creates a set of vertex data for use with [Canvas.drawVertices], using the
/// encoding expected by the Flutter engine.
///
/// The `mode` parameter describes how the points should be interpreted: as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single
/// shared point ([VertexMode.triangleFan]).
///
/// The `positions` parameter provides the points in the canvas space that
/// will be use to draw the triangles. Each point is represented as two
/// numbers in the list, the first giving the x coordinate and the second
/// giving the y coordinate. (As a result, the list must have an even number
/// of entries.)
///
/// The `colors` parameter, if specified, provides the color for each point in
/// `positions`. Each color is represented as ARGB with 8 bit color channels
/// (like [Color.value]'s internal representation), and the list, if
/// specified, must therefore be half the length of `positions`. Each triangle
/// is painted as a gradient that blends between the three colors at the three
/// points of that triangle. (These colors are then blended with the [Paint]
/// specified in the call to [Canvas.drawVertices].)
///
/// The `textureCoordinates` parameter, if specified, provides the points in
/// the [Paint] image to sample for the corresponding points in `positions`.
/// Each point is represented as two numbers in the list, the first giving the
/// x coordinate and the second giving the y coordinate. This list, if
/// specified, must be the same length as `positions`.
///
/// The `indices` parameter specifies the order in which the points should be
/// painted. If it is omitted (or present but empty), the points are processed
/// in the order they are given in `positions`, as if the `indices` was a list
/// from 0 to n-2, where _n_ is the number of pairs in `positions` (i.e. half
/// the length of `positions`). The `indices` parameter, if present and
/// non-empty, must have at least three entries, but may be of any length
/// beyond this. Indicies may refer to offsets in the positions array multiple
/// times, or may skip positions entirely.
///
/// If the `indices` parameter is specified, all values in the list must be
/// valid index values for pairs in `positions`. For example, if there are 12
/// numbers in `positions` (representing 6 coordinates), the `indicies` must
/// be numbers in the range 0..5 inclusive.
///
/// The `mode` and `positions` parameters must not be null.ÀöªÀö¶  Àö¿ÀöÌ  ÀöÜÀöè  ÀöóÀ÷  À÷À÷%   ÀşÎÀşÓ ÀşßÀşèÀÿ¥€«/// Whether this reference to the underlying vertex data is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   ÀûrÀûé  ÀûïÀûù  Àü"Àü'  ÀüIÀüV  Àü}Àü‹  Àü»ÀüÇ  ÀüëÀüø  ÀûrÀûsÀûyÀû¶ÀûÀûzÀû‡ÀûµÀûˆÀûÀû—ÀûŸÀû§Àû¯Àû·ÀûĞÀû¾Àû¸ÀûÀÀı€ôÀı|n/// Release the resources used by this object. The object is no longer usable
/// after this method is called.   Àıü€ÎÀş¿k/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  ÀşlÀşmÀşsÀşÀşyÀştÀşÀşÀş‚Àş‰ÀşÀşŠÀş‘Àş­Àş˜Àş’Àşš ÀĞÀ –2À	Iƒi/// An interface for recording graphical operations.
///
/// [Canvas] objects are used in creating [Picture] objects, which can
/// themselves be used with a [SceneBuilder] to build a [Scene]. In
/// normal usage, however, this is all handled by the framework.
///
/// A canvas has a current transformation matrix which is applied to all
/// operations. Initially, the transformation matrix is the identity transform.
/// It can be modified using the [translate], [scale], [rotate], [skew],
/// and [transform] methods.
///
/// A canvas also has a current clip region which is applied to all operations.
/// Initially, the clip region is infinite. It can be modified using the
/// [clipRect], [clipRRect], and [clipPath] methods.
///
/// The current transform and clip can be saved and restored using the stack
/// managed by the [save], [saveLayer], and [restore] methods. À	T‚× ÀæÀì‚q/// Creates a canvas for recording graphical operations into the
/// given picture recorder.
///
/// Graphical operations that affect pixels entirely outside the given
/// `cullRect` might be discarded by the implementation. However, the
/// implementation might draw outside these bounds if, for example, a command
/// draws partially inside and outside the `cullRect`. To ensure that pixels
/// outside a given region are discarded, consider using a [clipRect]. The
/// `cullRect` is optional; by default, all operations are kept.
///
/// To end the recording, call [PictureRecorder.endRecording] on the
/// given recorder.ÀíÀş  À	À     %À/(ÀP/// Saves a copy of the current transform and clip on the save stack.
///
/// Call [restore] to pop the save stack.
///
/// See also:
///
///  * [saveLayer], which does the same thing but additionally also groups the
///    commands done until the matching [restore].   À[”šÀ!Ğ“•/// Saves a copy of the current transform and clip on the save stack, and then
/// creates a new group which subsequent calls will become a part of. When the
/// save stack is later popped, the group will be flattened into a layer and
/// have the given `paint`'s [Paint.colorFilter] and [Paint.blendMode]
/// applied.
///
/// This lets you create composite effects, for example making a group of
/// drawing commands semi-transparent. Without using [saveLayer], each part of
/// the group would be painted individually, so where they overlap would be
/// darker than where they do not. By using [saveLayer] to group them
/// together, they can be drawn with an opaque color at first, and then the
/// entire group can be made transparent using the [saveLayer]'s paint.
///
/// Call [restore] to pop the save stack and apply the paint to the group.
///
/// ## Using saveLayer with clips
///
/// When a rectangular clip operation (from [clipRect]) is not axis-aligned
/// with the raster buffer, or when the clip operation is not rectilinear
/// (e.g. because it is a rounded rectangle clip created by [clipRRect] or an
/// arbitrarily complicated path clip created by [clipPath]), the edge of the
/// clip needs to be anti-aliased.
///
/// If two draw calls overlap at the edge of such a clipped region, without
/// using [saveLayer], the first drawing will be anti-aliased with the
/// background first, and then the second will be anti-aliased with the result
/// of blending the first drawing and the background. On the other hand, if
/// [saveLayer] is used immediately after establishing the clip, the second
/// drawing will cover the first in the layer, and thus the second alone will
/// be anti-aliased with the background when the layer is clipped and
/// composited (when [restore] is called).
///
/// For example, this [CustomPainter.paint] method paints a clean white
/// rounded rectangle:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.saveLayer(rect, Paint());
///   canvas.drawPaint(Paint()..color = Colors.red);
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.restore();
/// }
/// ```
///
/// On the other hand, this one renders a red outline, the result of the red
/// paint being anti-aliased with the background at the clip edge, then the
/// white paint being similarly anti-aliased with the background _including
/// the clipped red paint_:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   // (this example renders poorly, prefer the example above)
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.drawPaint(Paint()..color = Colors.red);
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// This point is moot if the clip only clips one draw operation. For example,
/// the following paint method paints a pair of clean white rounded
/// rectangles, even though the clips are not done on a separate layer:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(Offset.zero & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(size.center(Offset.zero) & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// (Incidentally, rather than using [clipRRect] and [drawPaint] to draw
/// rounded rectangles like this, prefer the [drawRRect] method. These
/// examples are using [drawPaint] as a proxy for "complicated draw operations
/// that will get clipped", to illustrate the point.)
///
/// ## Performance considerations
///
/// Generally speaking, [saveLayer] is relatively expensive.
///
/// There are a several different hardware architectures for GPUs (graphics
/// processing units, the hardware that handles graphics), but most of them
/// involve batching commands and reordering them for performance. When layers
/// are used, they cause the rendering pipeline to have to switch render
/// target (from one layer to another). Render target switches can flush the
/// GPU's command buffer, which typically means that optimizations that one
/// could get with larger batching are lost. Render target switches also
/// generate a lot of memory churn because the GPU needs to copy out the
/// current frame buffer contents from the part of memory that's optimized for
/// writing, and then needs to copy it back in once the previous render target
/// (layer) is restored.
///
/// See also:
///
///  * [save], which saves the current state, but does not create a new layer
///    for subsequent commands.
///  * [BlendMode], which discusses the use of [Paint.blendMode] with
///    [saveLayer]. À!ÚÀ!á  À!èÀ!ï   À!ùFÀ#5(/// Pops the current save stack, if there is anything to pop.
/// Otherwise, does nothing.
///
/// Use [save] and [saveLayer] to push state onto the stack.
///
/// If the state was pushed with [saveLayer], then this call will also
/// cause the new layer to be composited into the previous layer.   À#C‚%À%Nó/// Restores the save stack to a previous level as might be obtained from [getSaveCount].
/// If [count] is less than 1, the stack is restored to its initial state.
/// If [count] is greater than the current [getSaveCount] then nothing happens.
///
/// Use [save] and [saveLayer] to push state onto the stack.
///
/// If any of the state stack levels restored by this call were pushed with
/// [saveLayer], then this call will also cause those layers to be composited
/// into their previous layers. À%]	À%b   À%lBÀ&Ÿ"/// Returns the number of items on the save stack, including the
/// initial state. This means it returns 1 for a clean canvas, and
/// that each call to [save] and [saveLayer] increments it, and that
/// each matching call to [restore] decrements it.
///
/// This number cannot go below 1.   À&²€ÅÀ'W€›/// Add a translation to the current transform, shifting the coordinate space
/// horizontally by the first argument and vertically by the second argument. À'a	À'i  À'l	À't   À'{,À(ˆ€û/// Add an axis-aligned scale to the current transform, scaling by the first
/// argument in the horizontal direction and the second in the vertical
/// direction.
///
/// If [sy] is unspecified, [sx] will be used for the scale in both
/// directions. À(	À(–  À(š
À(£   À(«qÀ)R/// Add a rotation to the current transform. The argument is in radians clockwise. À)À)   À) 5À*:/// Add an axis-aligned skew to the current transform, with the first argument
/// being the horizontal skew in rise over run units clockwise around the
/// origin, and the second argument being the vertical skew in rise over run
/// units clockwise around the origin. À*?	À*G  À*J	À*R   À*Y€¯À*é€ˆ/// Multiply the current transform by the specified 4â¨‰4 transformation matrix
/// specified as a list of values in column-major order. À*óÀ+    À+‚À- ×/// Returns the current transform including the combined result of all transform
/// methods executed since the creation of this [Canvas] object, and respecting the
/// save/restore history.
///
/// Methods that can change the current transform include [translate], [scale],
/// [rotate], [skew], and [transform]. The [restore] method can also modify
/// the current transform by restoring it to the same value it had before its
/// associated [save] or [saveLayer] call.   À-‚À/P‚/// Reduces the clip region to the intersection of the current clip and the
/// given rectangle.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_rect.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that.
///
/// Use [ClipOp.difference] to subtract the provided rectangle from the
/// current clip. À/Y	À/_  À/f À/n  À/ˆÀ/  À/vÀ/|À/}À/›À/§‚;À1°ï/// Reduces the clip region to the intersection of the current clip and the
/// given rounded rectangle.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_rrect.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that and some examples of using [clipRRect]. À1ºÀ1Á  À1ÈÀ1Î  À1ÛÀ1æ‚À3¼¼/// Reduces the clip region to the intersection of the current clip and the
/// given [Path].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_path.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that. À3Å	À3Ë  À3ÑÀ3×  À3äÀ3ïŠİÀ>·ŠZ/// Returns the conservative bounds of the combined result of all clip methods
/// executed within the current save stack of this [Canvas] object, as measured
/// in the local coordinate space under which rendering operations are currently
/// performed.
///
/// The combined clip results are rounded out to an integer pixel boundary before
/// they are transformed back into the local coordinate space which accounts for
/// the pixel roundoff in rendering operations, particularly when antialiasing.
/// Because the [Picture] may eventually be rendered into a scene within the
/// context of transforming widgets or layers, the result may thus be overly
/// conservative due to premature rounding. Using the [getDestinationClipBounds]
/// method combined with the external transforms and rounding in the true device
/// coordinate system will produce more accurate results, but this value may
/// provide a more convenient approximation to compare rendering operations to
/// the established clip.
///
/// {@template dart.ui.canvas.conservativeClipBounds}
/// The conservative estimate of the bounds is based on intersecting the bounds
/// of each clip method that was executed with [ClipOp.intersect] and potentially
/// ignoring any clip method that was executed with [ClipOp.difference]. The
/// [ClipOp] argument is only present on the [clipRect] method.
///
/// To understand how the bounds estimate can be conservative, consider the
/// following two clip method calls:
///
/// ```dart
/// void draw(Canvas canvas) {
///   canvas.clipPath(Path()
///     ..addRect(const Rect.fromLTRB(10, 10, 20, 20))
///     ..addRect(const Rect.fromLTRB(80, 80, 100, 100)));
///   canvas.clipPath(Path()
///     ..addRect(const Rect.fromLTRB(80, 10, 100, 20))
///     ..addRect(const Rect.fromLTRB(10, 80, 20, 100)));
///   // ...
/// }
/// ```
///
/// After executing both of those calls there is no area left in which to draw
/// because the two paths have no overlapping regions. But, in this case,
/// [getLocalClipBounds] would return a rectangle from `10, 10` to `100, 100` because it
/// only intersects the bounds of the two path objects to obtain its conservative
/// estimate.
///
/// The clip bounds are not affected by the bounds of any enclosing
/// [saveLayer] call as the engine does not currently guarantee the strict
/// enforcement of those bounds during rendering.
///
/// Methods that can change the current clip include [clipRect], [clipRRect],
/// and [clipPath]. The [restore] method can also modify the current clip by
/// restoring it to the same value it had before its associated [save] or
/// [saveLayer] call.
/// {@endtemplate}   À>ĞƒŸÀBTƒb/// Returns the conservative bounds of the combined result of all clip methods
/// executed within the current save stack of this [Canvas] object, as measured
/// in the destination coordinate space in which the [Picture] will be rendered.
///
/// Unlike [getLocalClipBounds], the bounds are not rounded out to an integer
/// pixel boundary as the Destination coordinate space may not represent pixels
/// if the [Picture] being constructed will be further transformed when it is
/// rendered or added to a scene. In order to determine the true pixels being
/// affected, those external transforms should be applied first before rounding
/// out the result to integer pixel boundaries. Most typically, [Picture] objects
/// are rendered in a scene with a scale transform representing the Device Pixel
/// Ratio.
///
/// {@macro dart.ui.canvas.conservativeClipBounds}   ÀBs€İÀC$€¥/// Paints the given [Color] onto the canvas, applying the given
/// [BlendMode], with the given color being the source and the background
/// being the destination. ÀC.ÀC5  ÀC;ÀCF   ÀCTüÀE$¼/// Draws a line between the given points using the given paint. The line is
/// stroked, the value of the [Paint.style] is ignored for this call.
///
/// The `p1` and `p2` arguments are interpreted as offsets from the origin.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_line.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_line_dark.png#gh-dark-mode-only) ÀE-	ÀE5  ÀE8	ÀE@  ÀECÀEJ   ÀET€±ÀEî€Œ/// Fills the canvas with the given [Paint].
///
/// To fill the canvas with a solid color and blend mode, consider
/// [drawColor] instead. ÀEøÀEÿ   ÀF	‘ÀGy`/// Draws a rectangle with the given [Paint]. Whether the rectangle is filled
/// or stroked (or both) is controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rect.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rect_dark.png#gh-dark-mode-only) ÀG‚	ÀGˆ  ÀGÀG”   ÀGÀIj/// Draws a rounded rectangle with the given [Paint]. Whether the rectangle is
/// filled or stroked (or both) is controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rrect.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rrect_dark.png#gh-dark-mode-only) ÀI"ÀI)  ÀI/ÀI6   ÀI@HÀJV/// Draws a shape consisting of the difference between two rounded rectangles
/// with the given [Paint]. Whether this shape is filled or stroked (or both)
/// is controlled by [Paint.style].
///
/// This shape is almost but not quite entirely unlike an annulus. ÀJaÀJh  ÀJnÀJu  ÀJ{ÀJ‚   ÀJŒÇÀL2”/// Draws an axis-aligned oval that fills the given axis-aligned rectangle
/// with the given [Paint]. Whether the oval is filled or stroked (or both) is
/// controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_oval.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_oval_dark.png#gh-dark-mode-only) ÀL;	ÀLA  ÀLFÀLM   ÀLW‚)ÀNOä/// Draws a circle centered at the point given by the first argument and
/// that has the radius given by the second argument, with the [Paint] given in
/// the third argument. Whether the circle is filled or stroked (or both) is
/// controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_circle.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_circle_dark.png#gh-dark-mode-only) ÀNZÀNb  ÀNdÀNl  ÀNsÀNz   ÀN„ƒÛÀR	ƒc/// Draw an arc scaled to fit inside the given rectangle.
///
/// It starts from `startAngle` radians around the oval up to
/// `startAngle` + `sweepAngle` radians around the oval, with zero radians
/// being the point on the right hand side of the oval that crosses the
/// horizontal line that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval. If `useCenter` is true, the arc is
/// closed back to the center, forming a circle sector. Otherwise, the arc is
/// not closed, forming a circle segment.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_draw_arc.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_draw_arc_dark.png#gh-dark-mode-only)
///
/// This method is optimized for drawing arcs and should be faster than [Path.arcTo]. ÀR	ÀR  ÀRÀR$  ÀR/ÀR7  ÀRBÀRH  ÀRRÀRY   ÀRcÀSa€î/// Draws the given [Path] with the given [Paint].
///
/// Whether this shape is filled or stroked (or both) is controlled by
/// [Paint.style]. If the path is filled, then sub-paths within it are
/// implicitly closed (see [Path.close]). ÀSj	ÀSp  ÀSuÀS|   ÀS†€İÀT0€ /// Draws the given [Image] into the canvas with its top-left corner at the
/// given [Offset]. The image is composited into the canvas using the given [Paint]. ÀT:ÀTA  ÀTGÀTO  ÀTVÀT]   ÀTgøÀV#¤/// Draws the subset of the given image described by the `src` argument into
/// the canvas in the axis-aligned rectangle given by the `dst` argument.
///
/// This might sample from outside the `src` rect by up to half the width of
/// an applied filter.
///
/// Multiple calls to this method with different arguments (from the same
/// image) can be batched into a single call to [drawAtlas] to improve
/// performance. ÀV1ÀV8  ÀV>ÀVD  ÀVHÀVN  ÀVRÀVY   ÀVcƒQÀYu‚ò/// Draws the given [Image] into the canvas using the given [Paint].
///
/// The image is drawn in nine portions described by splitting the image by
/// drawing two horizontal lines and two vertical lines, where the `center`
/// argument describes the rectangle formed by the four points where these
/// four lines intersect each other. (This forms a 3-by-3 grid of regions,
/// the center region being described by the `center` argument.)
///
/// The four regions in the corners are drawn, without scaling, in the four
/// corners of the destination rectangle described by `dst`. The remaining
/// five regions are drawn by stretching them to fit such that they exactly
/// cover the destination rectangle while maintaining their relative
/// positions. ÀYƒÀYŠ  ÀYÀY–  ÀYÀY£  ÀY§ÀY®   ÀY¸€‚ÀZ[/// Draw the given picture onto the canvas. To create a picture, see
/// [PictureRecorder]. ÀZ)ÀZ2   ÀZ>„IÀ^Uƒé/// Draws the text in the given [Paragraph] into this canvas at the given
/// [Offset].
///
/// The [Paragraph] object must have had [Paragraph.layout] called on it
/// first.
///
/// To align the text, set the `textAlign` on the [ParagraphStyle] object
/// passed to the [ParagraphBuilder.new] constructor. For more details see
/// [TextAlign] and the discussion at [ParagraphStyle.new].
///
/// If the text is left aligned or justified, the left margin will be at the
/// position specified by the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is right aligned or justified, the right margin will be at the
/// position described by adding the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is centered, the centering axis will be at the position
/// described by adding half of the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate. À^cÀ^n  À^xÀ^€   À^‹ôÀ`=–/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as offsets from the origin.
///
/// The `paint` is used for each point ([PointMode.points]) or line
/// ([PointMode.lines] or [PointMode.polygon]), ignoring [Paint.style].
///
/// See also:
///
///  * [drawRawPoints], which takes `points` as a [Float32List] rather than a
///    [List<Offset>]. À`HÀ`S  À`]À`k  À`rÀ`y   À`ƒ‚OÀbí/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as a list of pairs of floating point
/// numbers, where each pair represents an x and y offset from the origin.
///
/// The `paint` is used for each point ([PointMode.points]) or line
/// ([PointMode.lines] or [PointMode.polygon]), ignoring [Paint.style].
///
/// See also:
///
///  * [drawPoints], which takes `points` as a [List<Offset>] rather than a
///    [List<Float32List>]. ÀbœÀb§  Àb±Àb¾  ÀbÅÀbÌ   ÀbÖ†;ÀhÏ…»/// Draws a set of [Vertices] onto the canvas as one or more triangles.
///
/// The [Paint.color] property specifies the default color to use for the
/// triangles.
///
/// The [Paint.shader] property, if set, overrides the color entirely,
/// replacing it with the colors from the specified [ImageShader], [Gradient],
/// or other shader.
///
/// The `blendMode` parameter is used to control how the colors in the
/// `vertices` are combined with the colors in the `paint`. If there are no
/// colors specified in `vertices` then the `blendMode` has no effect. If
/// there are colors in the `vertices`, then the color taken from the
/// [Paint.shader] or [Paint.color] in the `paint` is blended with the colors
/// specified in the `vertices` using the `blendMode` parameter. For the
/// purposes of this blending, the colors from the `paint` parameter are
/// considered the source, and the colors from the `vertices` are considered
/// the destination. [BlendMode.dst] ignores the `paint` and uses only the
/// colors of the `vertices`; [BlendMode.src] ignores the colors of the
/// `vertices` and uses only the colors in the `paint`.
///
/// All parameters must not be null.
///
/// See also:
///   * [Vertices.new], which creates a set of vertices to draw on the canvas.
///   * [Vertices.raw], which creates the vertices using typed data lists
///     rather than unencoded lists.
///   * [paint], Image shaders can be used to draw images on a triangular mesh. ÀhÜÀhæ  ÀhïÀhú  ÀiÀi   Ài–•À~µ””/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color.
///
/// The method takes a list of [Rect] objects that each define a piece of the
/// [atlas] image to be drawn independently. Each [Rect] is associated with an
/// [RSTransform] entry in the [transforms] list which defines the location,
/// rotation, and (uniform) scale with which to draw that portion of the image.
/// Each [Rect] can also be associated with an optional [Color] which will be
/// composed with the associated image part using the [blendMode] before blending
/// the result onto the canvas. The full operation can be broken down as:
///
/// - Blend each rectangular portion of the image specified by an entry in the
/// [rects] argument with its associated entry in the [colors] list using the
/// [blendMode] argument (if a color is specified). In this part of the operation,
/// the image part will be considered the source of the operation and the associated
/// color will be considered the destination.
/// - Blend the result from the first step onto the canvas using the translation,
/// rotation, and scale properties expressed in the associated entry in the
/// [transforms] list using the properties of the [Paint] object.
///
/// If the first stage of the operation which blends each part of the image with
/// a color is needed, then both the [colors] and [blendMode] arguments must
/// not be null and there must be an entry in the [colors] list for each
/// image part. If that stage is not needed, then the [colors] argument can
/// be either null or an empty list and the [blendMode] argument may also be null.
///
/// The optional [cullRect] argument can provide an estimate of the bounds of the
/// coordinates rendered by all components of the atlas to be compared against
/// the clip to quickly reject the operation if it does not intersect.
///
/// An example usage to render many sprites from a single sprite atlas with no
/// rotations or scales:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center);
///   int index;
///   Offset center;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (final Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: 0.0,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.center.dx,
///           translateY: sprite.center.dy,
///         ),
///     ], <Rect>[
///       for (final Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], null, null, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center, this.alpha, this.rotation);
///   int index;
///   Offset center;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (final Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: sprite.rotation,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.center.dx,
///           translateY: sprite.center.dy,
///         ),
///     ], <Rect>[
///       for (final Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], <Color>[
///       for (final Sprite sprite in allSprites)
///         Colors.white.withAlpha(sprite.alpha),
///     ], BlendMode.srcIn, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// The length of the [transforms] and [rects] lists must be equal and
/// if the [colors] argument is not null then it must either be empty or
/// have the same length as the other two lists.
///
/// See also:
///
///  * [drawRawAtlas], which takes its arguments as typed data lists rather
///    than objects. À~¿À~Æ  À~İÀ~ğ  ÀÀ  À/À=  ÀUÀa  À|Àƒ  ÀÀ¤   À®›À™¾˜ä/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color. It is also more efficient
/// than [drawAtlas] as the data in the arguments is already packed in a format
/// that can be directly used by the rendering code.
///
/// A full description of how this method uses its arguments to draw onto the
/// canvas can be found in the description of the [drawAtlas] method.
///
/// The [rstTransforms] argument is interpreted as a list of four-tuples, with
/// each tuple being ([RSTransform.scos], [RSTransform.ssin],
/// [RSTransform.tx], [RSTransform.ty]).
///
/// The [rects] argument is interpreted as a list of four-tuples, with each
/// tuple being ([Rect.left], [Rect.top], [Rect.right], [Rect.bottom]).
///
/// The [colors] argument, which can be null, is interpreted as a list of
/// 32-bit colors, with the same packing as [Color.value]. If the [colors]
/// argument is not null then the [blendMode] argument must also not be null.
///
/// An example usage to render many sprites from a single sprite atlas with no rotations
/// or scales:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center);
///   int index;
///   Offset center;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     for (int i = 0; i < allSprites.length; i++) {
///       Sprite sprite = allSprites[i];
///       final double rectX = sprite.index * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example sets the RSTransform values directly for a common case of no
///       // rotations or scales and just a translation to position the atlas entry. For
///       // more complicated transforms one could use the RSTransform class to compute
///       // the necessary values or do the same math directly.
///       transformList[i * 4 + 0] = 1.0;
///       transformList[i * 4 + 1] = 0.0;
///       transformList[i * 4 + 2] = sprite.center.dx - 5.0;
///       transformList[i * 4 + 3] = sprite.center.dy - 5.0;
///     }
///     Paint paint = Paint();
///     canvas.drawRawAtlas(spriteAtlas, transformList, rectList, null, null, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center, this.alpha, this.rotation);
///   int index;
///   Offset center;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     Int32List colorList = Int32List(allSprites.length);
///     for (int i = 0; i < allSprites.length; i++) {
///       Sprite sprite = allSprites[i];
///       final double rectX = sprite.index * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example uses an RSTransform object to compute the necessary values for
///       // the transform using a factory helper method because the sprites contain
///       // rotation values which are not trivial to work with. But if the math for the
///       // values falls out from other calculations on the sprites then the values could
///       // possibly be generated directly from the sprite update code.
///       final RSTransform transform = RSTransform.fromComponents(
///         rotation: sprite.rotation,
///         scale: 1.0,
///         // Center of the sprite relative to its rect
///         anchorX: 5.0,
///         anchorY: 5.0,
///         // Location at which to draw the center of the sprite
///         translateX: sprite.center.dx,
///         translateY: sprite.center.dy,
///       );
///       transformList[i * 4 + 0] = transform.scos;
///       transformList[i * 4 + 1] = transform.ssin;
///       transformList[i * 4 + 2] = transform.tx;
///       transformList[i * 4 + 3] = transform.ty;
///
///       // This example computes the color value directly, but one could also compute
///       // an actual Color object and use its Color.value getter for the same result.
///       // Since we are using BlendMode.srcIn, only the alpha component matters for
///       // these colors which makes this a simple shift operation.
///       colorList[i] = sprite.alpha << 24;
///     }
///     Paint paint = Paint();
///     canvas.drawRawAtlas(spriteAtlas, transformList, rectList, colorList, BlendMode.srcIn, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// See also:
///
///  * [drawAtlas], which takes its arguments as objects rather than typed
///    data lists. À™ËÀ™Ò  À™ìÀ™ù  ÀšÀš(  ÀšBÀšN  ÀšiÀšu  Àš“Àšš  Àš·Àš¾   ÀšÈ8À›±€×/// Draws a shadow for a [Path] representing the given material elevation.
///
/// The `transparentOccluder` argument should be true if the occluding object
/// is not opaque.
///
/// The arguments must not be null. À›¼	À›Â  À›ÇÀ›Î  À›ÔÀ›Ü  À›æÀ›ì    ÀœÀ HÖÀœ  ÀœT“ ÀœTÀœa ÀœbÀœs  Àœ~Àœ…   ÀŸÈ!ÀŸà   BÀë€ÜÀc  ÀpÀˆ  À‘À™  À
À¦  ÀªÀ²  À¸ÀÀ  ÀëÀìÀòÀ7ÀøÀóÀ À6ÀÀ	ÀÀÀÀÀ À(À0À8ÀQÀ?À9ÀAÀŸîoÀ V   ÀŸîÀŸïÀŸúÀŸûÀ À À À À À À À À À À À DÀ &À  À (À >À 8À @À a-À r  À |À ƒ  À ŠÀ ‘  À aÀ bÀ¡’€¹À¢  À¢À¢*  À¢7À¢A  À¡’À¡“À¡™À¡ÆÀ¡ŸÀ¡šÀ¡§À¡ÅÀ¡¨À¡¯À¡´À¡°À¡·À¡¿À¡ÇÀ¡ğÀ¡ÎÀ¡ÈÀ¡ĞÀ¢O€õÀ¢Ò  À¢İÀ¢å  À¢ê
À¢ò  À¢öÀ¢ş  À£À£  À£À£#  À£0À£:  À¢OÀ¢PÀ¢VÀ¢£À¢\À¢WÀ¢dÀ¢¢À¢eÀ¢lÀ¢qÀ¢mÀ¢tÀ¢|À¢„À¢ŒÀ¢”À¢œÀ¢¤À¢ÀÀ¢«À¢¥À¢­À£HuÀ£³   À£HÀ£IÀ£TÀ£UÀ£[À£xÀ£aÀ£\À£iÀ£wÀ£jÀ£qÀ£vÀ£rÀ£yÀ£¡À£€À£zÀ£‚À£›À£•À£À£Á€“À¤:  À¤I	À¤N  À£ÁÀ£ÂÀ£ÍÀ£ÎÀ£ÔÀ£øÀ£ÚÀ£ÕÀ£âÀ£÷À£ãÀ£êÀ£ïÀ£ëÀ£òÀ£ùÀ¤(À¤ À£úÀ¤À¤"À¤À¤$À¤XÀ¤È   À¤XÀ¤YÀ¤dÀ¤eÀ¤kÀ¤‰À¤rÀ¤lÀ¤zÀ¤ˆÀ¤{À¤‚À¤‡À¤ƒÀ¤ŠÀ¤·À¤‘À¤‹À¤“À¤±À¤«À¤³À¤Û€À¥X  À¥b	À¥j  À¥m	À¥u  À¤ÛÀ¤ÜÀ¤çÀ¤èÀ¤îÀ¥À¤ôÀ¤ïÀ¤üÀ¥À¤ıÀ¥À¥	À¥À¥À¥À¥À¥FÀ¥#À¥À¥%À¥@À¥:À¥BÀ¥|HÀ¥  À¥“	À¥›  À¥Ÿ
À¥¨  À¥|À¥}À¥È€ŠÀ¦5  À¦<	À¦D  À¦G	À¦O  À¥ÈÀ¥ÉÀ¥ÏÀ¥üÀ¥ÕÀ¥ĞÀ¥İÀ¥ûÀ¥ŞÀ¥åÀ¥êÀ¥æÀ¥íÀ¥õÀ¥ıÀ¦#À¦À¥şÀ¦À¦À¦À¦À¦V€‰À¦È  À¦ÏÀ¦×  À¦VÀ¦WÀ¦bÀ¦cÀ¦iÀ¦À¦oÀ¦jÀ¦wÀ¦À¦xÀ¦À¦„À¦€À¦‡À¦À¦¶À¦–À¦À¦˜À¦°À¦ªÀ¦²À¦ã€“À§[  À§`	À§h  À§k	À§s  À¦ãÀ¦äÀ¦ïÀ¦ğÀ¦öÀ§#À¦üÀ¦÷À§À§"À§À§À§À§À§À§À§$À§IÀ§+À§%À§-À§CÀ§=À§EÀ§z€²À§‹  À§•À§¢  À§zÀ§{À¨0{À¨‹  À¨–À¨£  À¨0À¨1À¨7À¨\À¨=À¨8À¨EÀ¨[À¨FÀ¨MÀ¨RÀ¨NÀ¨UÀ¨]À¨yÀ¨dÀ¨^À¨fÀ¨¯€À¨Ç   À¨¯À¨°À©@€À©  À©¬À©¹  À©@À©AÀ©GÀ©lÀ©MÀ©HÀ©UÀ©kÀ©VÀ©]À©bÀ©^À©eÀ©mÀ©ŒÀ©tÀ©nÀ©vÀ©Å€áÀ©Ö  À©ß	À©å  À©ì À©ô  ÀªÀª  À©ÅÀ©ÆÀ©üÀªÀªÀª!Àªª€ëÀ«7  À«AÀ«I  À«N
À«V  À«ZÀ«b  À«hÀ«p  À«w
À«|  À«ƒÀ«‰  ÀªªÀª«Àª±ÀªûÀª·Àª²Àª¿ÀªúÀªÀÀªÇÀªÌÀªÈÀªÏÀª×ÀªßÀªçÀªïÀªöÀªüÀ«%À«ÀªıÀ«À«À«À«!À«™€œÀ«ª  À«´À«»  À«ÂÀ«È  À«™À«šÀ«ÕÀ¬9€‘À¬š  À¬¥À¬²  À¬¸À¬¾  À¬9À¬:À¬@À¬kÀ¬FÀ¬AÀ¬NÀ¬jÀ¬OÀ¬VÀ¬[À¬WÀ¬^À¬fÀ¬lÀ¬ˆÀ¬sÀ¬mÀ¬uÀ¬ÎvÀ¬ß  À¬è	À¬î  À¬ôÀ¬ú  À¬ÎÀ¬ÏÀ­À­H€•À­¯  À­¹À­Æ  À­ËÀ­Ñ  À­HÀ­IÀ­OÀ­À­UÀ­PÀ­]À­€À­^À­eÀ­jÀ­fÀ­mÀ­tÀ­yÀ­uÀ­|À­‚À­À­‰À­ƒÀ­‹À­á€ÁÀ­ò   À­áÀ­âÀ®¦€ŒÀ¯
  À¯À¯+  À®¦À®§À®­À®ÒÀ®³À®®À®»À®ÑÀ®¼À®ÃÀ®ÈÀ®ÄÀ®ËÀ®ÓÀ®øÀ®ÚÀ®ÔÀ®ÜÀ¯6€ÍÀ¯G   À¯6À¯7À°€˜À°q  À°‹À°˜  À°À°À°À°3À°À°À°À°2À°À°$À°)À°%À°,À°4À°_À°;À°5À°=À°£pÀ°´  À°¾À°Å  À°ËÀ°Ö  À°£À°¤À±€•À±‡  À±’	À±—  À±À±¢  À±À±À±À±JÀ±$À±À±,À±IÀ±-À±4À±9À±5À±<À±DÀ±KÀ±uÀ±RÀ±LÀ±TÀ±oÀ±iÀ±qÀ±°€ÊÀ±Á  À±Ê	À±Ò  À±Õ	À±İ  À±àÀ±ç  À±°À±±À²~€éÀ³   À³
	À³  À³	À³  À³ 	À³(  À³+	À³3  À³6À³F  À³SÀ³]  À²~À²À²…À²ÒÀ²‹À²†À²“À²ÑÀ²”À²›À² À²œÀ²£À²«À²³À²»À²ÃÀ²ËÀ²ÓÀ²îÀ²ÚÀ²ÔÀ²ÜÀ³kZÀ³|  À³†À³  À³kÀ³lÀ³É€ŸÀ´,  À´7À´G  À´TÀ´^  À³ÉÀ³ÊÀ³ĞÀ³ıÀ³ÖÀ³ÑÀ³ŞÀ³üÀ³ßÀ³æÀ³ëÀ³çÀ³îÀ³öÀ³şÀ´À´À³ÿÀ´À´l€±À´}  À´†	À´Œ  À´‘À´˜  À´lÀ´mÀµ!€óÀµ£  Àµ­Àµµ  Àµº
ÀµÂ  ÀµÆÀµÎ  ÀµÔÀµÜ  ÀµãÀµó  À¶ À¶
  Àµ!Àµ"Àµ(ÀµuÀµ.Àµ)Àµ6ÀµtÀµ7Àµ>ÀµCÀµ?ÀµFÀµNÀµVÀµ^ÀµfÀµnÀµvÀµ‘Àµ}ÀµwÀµÀ¶€À¶)  À¶3À¶:  À¶@À¶G  À¶À¶À¶º€ºÀ·%  À·0À·=  À·CÀ·S  À·`À·j  À¶ºÀ¶»À¶ÁÀ¶öÀ¶ÇÀ¶ÂÀ¶ÏÀ¶õÀ¶ĞÀ¶×À¶ÜÀ¶ØÀ¶ßÀ¶çÀ¶ïÀ¶÷À·À¶şÀ¶øÀ· À·x€äÀ·‰  À·”À·›  À·¡À·¨  À·®À·µ  À·xÀ·yÀ¸`€×À¸Ô  À¸àÀ¸í  À¸óÀ¹   À¹À¹  À¹#À¹-  À¸`À¸aÀ¸gÀ¸¤À¸mÀ¸hÀ¸uÀ¸£À¸vÀ¸}À¸‚À¸~À¸…À¸À¸•À¸À¸¥À¸ÂÀ¸¬À¸¦À¸®À¹;€±À¹L  À¹U	À¹[  À¹`À¹g  À¹;À¹<À¹ğ€óÀºr  Àº|Àº„  Àº‰
Àº‘  Àº•Àº  Àº£Àº«  Àº²ÀºÂ  ÀºÏÀºÙ  À¹ğÀ¹ñÀ¹÷ÀºDÀ¹ıÀ¹øÀºÀºCÀºÀºÀºÀºÀºÀºÀº%Àº-Àº5Àº=ÀºEÀº`ÀºLÀºFÀºNÀºç€¨Àºø  À»À»  À»À»  À»À»#  ÀºçÀºèÀ»“€ÜÀ¼  À¼À¼#  À¼%À¼-  À¼/À¼7  À¼>À¼N  À¼[À¼e  À»“À»”À»šÀ»ßÀ» À»›À»¨À»ŞÀ»©À»°À»µÀ»±À»¸À»ÀÀ»ÈÀ»ĞÀ»ØÀ»àÀ»ıÀ»çÀ»áÀ»éÀ¼sÀ¼„  À¼Œ	À¼’  À¼—À¼Ÿ  À¼ªÀ¼²  À¼½À¼Ã  À¼ÍÀ¼Ô  À¼sÀ¼tÀ½tÀ¾  	À¾&À¾.  À¾9
À¾A  À¾KÀ¾S  À¾_À¾g  À¾tÀ¾|  À¾À¾•  À¾¦À¾¬  À¾¼À¾Ì  À¾ßÀ¾é  À½À½€À½†À½éÀ½ŒÀ½‡À½”À½èÀ½•À½œÀ½¡À½À½¤À½¬À½´À½¼À½ÄÀ½ÌÀ½ÔÀ½ÚÀ½âÀ½êÀ¾À½ñÀ½ëÀ½óÀ¾÷xÀ¿  À¿	À¿  À¿À¿#  À¾÷À¾øÀ¿s€¾À¿ä  À¿îÀ¿û  ÀÀ ÀÀ  ÀÀÀÀ'  À¿sÀ¿tÀ¿zÀ¿¶À¿€À¿{À¿ˆÀ¿µÀ¿‰À¿À¿•À¿‘À¿˜À¿ŸÀ¿¤À¿ À¿§À¿¯À¿·À¿ÒÀ¿¾À¿¸À¿ÀÀÀ5~ÀÀF  ÀÀPÀÀW  ÀÀ]ÀÀe  ÀÀlÀÀs  ÀÀ5ÀÀ6ÀÁ·ÀÂE  ÀÂPÀÂX  ÀÂ^ÀÂf  ÀÂhÀÂp  ÀÂrÀÂ‚  ÀÂÀÂ™  ÀÂ£ÀÂ¨  ÀÁ·ÀÁ¸ÀÁ¾ÀÂÀÁÆÀÁ¿ÀÁÎÀÂÀÁÏÀÁÖÀÁÛÀÁ×ÀÁŞÀÁåÀÁêÀÁæÀÁíÀÁõÀÁıÀÂÀÂÀÂÀÂ0ÀÂÀÂÀÂÀÂ¿ƒ¦ÀÂĞ  ÀÂŞÀÂå  ÀÂëÀÂñ  ÀÂõÀÂû  ÀÂÿÀÃ  ÀÂ¿ÀÂÀÀÆiõÀÇ+  ÀÇAÀÇI  ÀÇUÀÇ]  ÀÇkÀÇs  ÀÇ€ÀÇˆ  ÀÇ—ÀÇŸ  ÀÇ¯ÀÇ·  ÀÇÅÀÇÍ  ÀÇÚÀÇâ  ÀÇñÀÇù  ÀÈ	ÀÈ  ÀÈ,ÀÈ6  ÀÈFÀÈK   ÀÆiÀÆjÀÆpÀÆõÀÆxÀÆqÀÆ€ÀÆôÀÆÀÆˆÀÆÀÆ‰ÀÆÀÆ—ÀÆœÀÆ˜ÀÆŸÀÆ§ÀÆ¯ÀÆ·ÀÆ¿ÀÆÇÀÆÏÀÆ×ÀÆßÀÆçÀÆïÀÆöÀÇÀÆıÀÆ÷ÀÆÿÀÈbƒ¸ÀÈs  ÀÈÀÈˆ  ÀÈÀÈ”  ÀÈ›ÀÈ¡  ÀÈ¥ÀÈ¬  ÀÈbÀÈcÀÌ‚ÀÌà  ÀÌöÀÌş  ÀÍ
ÀÍ  ÀÍ#ÀÍ+  ÀÍ;ÀÍC  ÀÍUÀÍ]  ÀÍpÀÍx  ÀÍ†ÀÍ  ÀÍ›ÀÍ£  ÀÍ²ÀÍº  ÀÍÊÀÍÚ  ÀÍíÀÍ÷  ÀÎÀÎ   ÀÌÀÌÀÌ%ÀÌªÀÌ-ÀÌ&ÀÌ5ÀÌ©ÀÌ6ÀÌ=ÀÌBÀÌ>ÀÌEÀÌLÀÌQÀÌMÀÌTÀÌ\ÀÌdÀÌlÀÌtÀÌ|ÀÌ„ÀÌŒÀÌ”ÀÌœÀÌ¤ÀÌ«ÀÌËÀÌ²ÀÌ¬ÀÌ´ÀÎ#€„ÀÎ4  ÀÎ@ÀÎI  ÀÎ#ÀÎ$ÀÎ«€‰ÀÏ  ÀÏÀÏ,  ÀÎ«ÀÎ¬ÀÎ²ÀÎŞÀÎ¸ÀÎ³ÀÎÀÀÎİÀÎÁÀÎÈÀÎÍÀÎÉÀÎĞÀÎ×ÀÎÜÀÎØÀÎßÀÎıÀÎæÀÎàÀÎèÀÏ8GÀÏI  ÀÏWÀÏb  ÀÏlÀÏt  ÀÏ8ÀÏ9ÀĞƒ€±ÀĞ”  ÀĞŸÀĞª  ÀĞ´ÀĞÂ  ÀĞÉÀĞĞ  ÀĞƒÀĞ„ÀÑ8ÀÑI  ÀÑWÀÑb  ÀÑlÀÑy  ÀÑ€ÀÑ‡  ÀÑ8ÀÑ9ÀÒP€ÓÀÒÃ  ÀÒÏÀÒß  ÀÒìÀÒö  ÀÓ ÀÓ  ÀÓÀÓ  ÀÒPÀÒQÀÒWÀÒ“ÀÒ]ÀÒXÀÒeÀÒ’ÀÒfÀÒmÀÒrÀÒnÀÒuÀÒ}ÀÒ…ÀÒŒÀÒ”ÀÒ±ÀÒ›ÀÒ•ÀÒÀÓ'€ÈÀÓ8  ÀÓEÀÓO  ÀÓXÀÓc  ÀÓmÀÓt  ÀÓ'ÀÓ(ÀÓó€İÀÔo  ÀÔ}ÀÔ‡  ÀÔÀÔ•  ÀÔŸÀÔ¯  ÀÔ¼ÀÔÆ  ÀÓóÀÓôÀÓúÀÔ=ÀÔ ÀÓûÀÔÀÔ<ÀÔ	ÀÔÀÔÀÔÀÔÀÔÀÔ$ÀÔ ÀÔ'ÀÔ.ÀÔ6ÀÔ>ÀÔ]ÀÔEÀÔ?ÀÔGÀÔÔˆ"ÀÔå  ÀÔïÀÔö  ÀÕÀÕ   ÀÕ<ÀÕH  ÀÕ_ÀÕm  ÀÕ…ÀÕ‘  ÀÕ¬ÀÕ³  ÀÕÍÀÕÔ  ÀÔÔÀÔÕÀÜú„§Àİ  ÀİÀİ  Àİ9ÀİF  ÀİhÀİu  ÀİÀİ›  Àİ¶ÀİÂ  ÀİàÀİç  ÀŞÀŞ  ÀÜúÀÜûÀá¥¥ÀâJ  	Àâ\Àâl  ÀâÀâ‰  Àâ™Àâ  Àâ·Àâ¿  ÀâËÀâØ  ÀâìÀâù  ÀãÀã  ÀãÀã#  Àã3ÀãA  Àá¥Àá¦Àá¬ÀâÀá´Àá­Àá¼ÀâÀá½ÀáÄÀáÉÀáÅÀáÌÀáÔÀáÜÀáãÀáêÀáïÀáëÀáòÀáúÀâÀâ
ÀâÀâÀâ5Àâ ÀâÀâ"ÀãN€¸Àã_  Àãj	Àãp  ÀãuÀã|  Àã‚ÀãŠ  Àã”Àãš  ÀãNÀãOÀä
€ÎÀäƒ  ÀäÀäœ  Àä¡	Àä¦  Àä¬Àä´  Àä¾ÀäÄ  Àä
ÀäÀäÀäSÀäÀäÀäÀäRÀä Àä'Àä,Àä(Àä/Àä6Àä;Àä7Àä>ÀäFÀäNÀäTÀäqÀä[ÀäUÀä] ÀåJŠ¸Àæ¨N/// An object representing a sequence of recorded graphical operations.
///
/// To create a [Picture], use a [PictureRecorder].
///
/// A [Picture] can be placed in a [Scene] using a [SceneBuilder], via
/// the [SceneBuilder.addPicture] method. A [Picture] can also be
/// drawn into a [Canvas], using the [Canvas.drawPicture] method.  Àæ´ÀçÄ€è/// A callback that is invoked to report a picture creation.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onCreate] directly because [MemoryAllocations]
/// allows multiple callbacks. ÀçÑÀèä€ë/// A callback that is invoked to report the picture disposal.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onDispose] directly because [MemoryAllocations]
/// allows multiple callbacks. ÀîF€ÇÀîÿ€§/// Whether this reference to the underlying picture is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   Àï€ïÀïë€É/// Returns the approximate number of bytes allocated for this object.
///
/// The actual size of this picture may be larger, particularly if it contains
/// references to image or other large objects.   ÀèòDÀê/// Creates an image from this picture.
///
/// The returned image will be `width` pixels wide and `height` pixels high.
/// The picture is rasterized within the 0 (left), 0 (top), `width` (right),
/// `height` (bottom) bounds. Content outside these bounds is clipped. Àê	Àê$  Àê*
Àê/   Àê:ƒ‚Àí™ƒ6/// Synchronously creates a handle to an image of this picture.
///
/// {@template dart.ui.painting.Picture.toImageSync}
/// The returned image will be `width` pixels wide and `height` pixels high.
/// The picture is rasterized within the 0 (left), 0 (top), `width` (right),
/// `height` (bottom) bounds. Content outside these bounds is clipped.
///
/// The image object is created and returned synchronously, but is rasterized
/// asynchronously. If the rasterization fails, an exception will be thrown
/// when the image is drawn to a [Canvas].
///
/// If a GPU context is available, this image will be created as GPU resident
/// and not copied back to the host. This means the image will be more
/// efficient to draw.
///
/// If no GPU context is available, the image will be rasterized on the CPU.
/// {@endtemplate} Àí¥	Àíª  Àí°
Àíµ   ÀíÀ€‚Àî8n/// Release the resources used by this object. The object is no longer usable
/// after this method is called.    Àğˆ‹Àğ  ÀğV€µÀñÀñÀñ€™/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To create a [Picture], use a [PictureRecorder].  ÀöéÀöî ÀöúÀ÷€õÀ÷   À÷À÷À÷ı€Àøx   À÷ıÀ÷şÀø	Àø
ÀøÀø/ÀøÀøÀø Àø.Àø!Àø(Àø-Àø)Àø0ÀøcÀø7Àø1Àø9Àø]ÀøWÀø_Àñ½Àñ)  Àñ1	Àñ6  Àñ<
ÀñA  ÀñÀñÀòĞ€°Àó?  ÀóH	ÀóM  ÀóS
ÀóX  Àó_Àów  ÀòĞÀòÑÀò×ÀóÀòßÀòØÀòçÀóÀòèÀòïÀòôÀòğÀò÷ÀòÿÀóÀóÀó*ÀóÀóÀóÀó„5Àó–  Àó¢	Àó§  Àó­
Àó²  Àó„Àó…Àô½€£Àõ+  Àõ8	Àõ=  ÀõC
ÀõH  ÀõOÀõW  Àô½Àô¾ÀôÄÀôùÀôÊÀôÅÀôÒÀôøÀôÓÀôÚÀôßÀôÛÀôâÀôêÀôòÀôúÀõÀõÀôûÀõÀõd€°Àõu   ÀõdÀõeÀö€ÍÀöÚk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  ÀöˆÀö‰ÀöÀö¬Àö•ÀöÀöÀö«ÀöÀö¥ÀöªÀö¦Àö­ÀöÈÀö´Àö®Àö¶ Àø‘„Àùu€Ô/// Records a [Picture] containing a sequence of graphical operations.
///
/// To begin recording, construct a [Canvas] to record the commands.
/// To end recording, use the [PictureRecorder.endRecording] method. Àù‰€× Àú5ÀúD€/// Creates a new idle PictureRecorder. To associate it with a
/// [Canvas] and begin recording, pass this [PictureRecorder] to the
/// [Canvas] constructor.   Àúd™Àûñu/// Whether this object is currently recording commands.
///
/// Specifically, this returns true if a [Canvas] object has been
/// created to record commands and recording has not yet ended via a
/// call to [endRecording], and false if either this
/// [PictureRecorder] has not yet been associated with a [Canvas],
/// or the [endRecording] method has already been called.   Àü,Àı
/// Finishes recording graphical operations.
///
/// Returns a picture containing the graphical operations that have been
/// recorded thus far. After calling this function, both the picture recorder
/// and the canvas objects are invalid and cannot be used further.    Àı1ƒÆÀı<  Àı“, Àı“Àı©   À ŞÀ í  Àş(4Àş=   Àş(Àş)ÀıÃaÀş   ÀıÃÀıÄÀıÊÀıàÀıĞÀıËÀıØÀıßÀıÙÀıáÀşÀıèÀıâÀıêÀş`æÀşt   Àş`ÀşaÀ J€À ±  À ¿À Ï  À JÀ KÀ QÀ vÀ WÀ RÀ _À uÀ `À gÀ lÀ hÀ oÀ wÀ ŸÀ ~À xÀ € À ù›ÀTT/// A single shadow.
///
/// Multiple shadows are stacked together in a [TextStyle]. À_‚P ÀêÀğp/// Construct a shadow.
///
/// The default shadow is a black shadow with zero offset and zero blur.
/// Default shadows should be completely covered by the casting element,
/// and not be visible.
///
/// Transparency should be adjusted through the [color] alpha.
///
/// Shadow order matters due to compositing multiple translucent objects not
/// being commutative.À÷(Àı  À%À+  ÀDÀJ  ÀÀ
ÀÀÀÀ3À9À:ÀVÀbÀhÀzÀ­ÀtÀiÀwÀ|	À³,ÀÄ ÀÕÀ&À À+À1'ÀB ÀTÀRÀWÀ\#Àm À{ÀyÀ~Àƒ#À” À¢À À¥Àª&À» ÀÌÀÊÀÏÀÕ€¼ÀŒ€¢/// Color that the shadow will be drawn with.
///
/// The shadows are shapes composited directly over the base canvas, and do not
/// represent optical occlusion. À–4ÀÄ/// The displacement of the shadow from the casting element.
///
/// Positive x/y offsets will shift the shadow to the right and down, while
/// negative offsets shift the shadow to the left and up. The offsets are
/// relative to the position of the element that is casting it. ÀÏiÀ.O/// The standard deviation of the Gaussian to convolve with the shadow's shape. À½€®À	=n/// The [blurRadius] in sigmas instead of logical pixels.
///
/// See the sigma argument to [MaskFilter.blur].   ÀÔGÀè   ÀÔÀÕÀ=|À\h/// Converts a blur radius in pixels to sigmas.
///
/// See the sigma argument to [MaskFilter.blur].
/// ÀqÀy   À	o‚‹Àõ/// Create the [Paint] object that corresponds to this shadow description.
///
/// The [offset] is not represented in the [Paint] object.
/// To honor this as well, the shape should be translated by [offset] before
/// being filled using this [Paint].
///
/// This class does not provide a way to disable shadows to avoid
/// inconsistencies in shadow blur rendering, primarily as a method of
/// reducing test flakiness. [toPaint] should be overridden in subclasses to
/// provide this functionality.   Àş€õÀe[/// Returns a new shadow with its [offset] and [blurRadius] scaled by the given
/// factor. ÀkÀs   À÷…×ÀƒÔ/// Linearly interpolate between two shadows.
///
/// If either shadow is null, this function linearly interpolates from
/// a shadow that matches the other shadow in color but has a zero
/// offset and a zero blurRadius.
///
/// {@template dart.ui.shadow.lerp}
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]).
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController].
/// {@endtemplate} À	À  À	À  ÀÀ$   ÀÒƒÀ—€¥/// Linearly interpolate between two lists of shadows.
///
/// If the lists differ in length, excess items are lerped with null.
///
/// {@macro dart.ui.shadow.lerp} À À¯  À±ÀÀ  ÀÂÀÊ   Àİ€óÀ÷  ÀúÀ  ÀİÀŞÀÙƒÓÀé  ÀøÀ   À°LÀÃ   À°À± À ÌÀ»€¯/// A handle to a read-only byte buffer that is managed by the engine.
///
/// The creator of this object is responsible for calling [dispose] when it is
/// no longer needed. Àğ ÀÿÀ À ÀÀ   À&À&  À&À& À&)À%²NÀ%î1/// The length, in bytes, of the underlying data.   À&3À&¼y/// Whether [dispose] has been called.
///
/// This must only be used when asserts are enabled. Otherwise, it will throw.   ÀgÀ–^/// Creates a copy of the data from a [Uint8List] suitable for internal use
/// in the engine. À¤À¯   ÀƒGÀr/// Create a buffer from the asset with key [assetKey].
///
/// Throws an [Exception] if the asset does not exist. À!À)   À!Ê÷À"Yi/// Create a buffer from the file with [path].
///
/// Throws an [Exception] if the asset does not exist. À"fÀ"n   À#Å€•À$*  À$0À$;  À$@À$Q  À#ÅÀ#ÆÀ#ÌÀ#ôÀ#ÔÀ#ÍÀ#ÜÀ#óÀ#İÀ#åÀ#íÀ#õÀ$À#üÀ#öÀ#şÀ$^€§À$Ì  À$ÛÀ$ã  À$ìÀ$ü  À$^À$_À$eÀ$À$mÀ$fÀ$uÀ$ŒÀ$vÀ$~À$†À$À$·À$•À$À$—À%	€¥À%v  À%„À%Œ  À%•À%¥  À%	À%
À%À%8À%À%À% À%7À%!À%)À%1À%9À%aÀ%@À%:À%BÀ'N‚£À)i‚/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// The underlying memory allocated by this object will be retained beyond
/// this call if it is still needed by another object that has not been
/// disposed. For example, an [ImageDescriptor] that has not been disposed
/// may still retain a reference to the memory from this buffer even if it
/// has been disposed. Freeing that memory requires disposing all resources
/// that may still hold it.   À)õ€ÕÀ*¿k/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À*eÀ*fÀ*lÀ*‰À*rÀ*mÀ*zÀ*ˆÀ*{À*‚À*‡À*ƒÀ*ŠÀ*­À*‘À*‹À*“ À*Î‰‰À+“€µ/// A descriptor of data that can be turned into an [Image] via a [Codec].
///
/// Use this class to determine the height, width, and byte size of image data
/// before decoding it. À+§‚çÀ-ŞÀ-ßÀ-âĞ/// Creates an image descriptor from raw image pixels.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `pixelFormat`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.À-èÀ-ù  À.À.  À.À.,  À.7À.=  À.J À.`    À/ùyÀ0ld/// The width, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   À0v{À0êe/// The height, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   À0õ€…À1lh/// The number of bytes per pixel in the image.
///
/// On web, this is only supported for [raw] images.   À.’cÀ.üH/// Creates an image descriptor from encoded data in a supported format. À/À/   À1~€øÀ2l€Ş/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).   À2zÛÀ4‚/// Creates a [Codec] object which is suitable for decoding the data in the
/// buffer to an [Image].
///
/// If only one of targetWidth or  targetHeight are specified, the other
/// dimension will be scaled according to the aspect ratio of the supplied
/// dimension.
///
/// If either targetWidth or targetHeight is less than or equal to zero, it
/// will be treated as if it is null. À4/À45  À4AÀ4G    À4YŒêÀ4d  À4»À4ÑÀ4ÒÀ4Ó   À4Úƒ£À7À7À7Ğ/// Creates an image descriptor from raw image pixels.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `pixelFormat`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.À7À7+  À78À7F  À7PÀ7^  À7iÀ7o  À7| À7’   À:/À:4  À:íÀ:ò  À;±À;¶  À:µ4À:É   À:µÀ:¶À;v7À;Š   À;vÀ;wÀ<OLÀ<c   À<OÀ<PÀ8€²À8ô  À9À9  À9À9*  À8À8‚À8ˆÀ8·À8À8‰À8˜À8¶À8™À8¡À8¨À8­À8©À8°À8¸À8ßÀ8¿À8¹À8ÁÀ97€ôÀ9µ  À9¾À9Ï  À9İÀ9î  À9õ	À9ú  À: 
À:  À:À:  À:À:  À97À98À9>À9xÀ9DÀ9?À9LÀ9wÀ9MÀ9UÀ9]À9dÀ9kÀ9rÀ9yÀ9œÀ9€À9zÀ9‚À:?rÀ:¥   À:?À:@À:FÀ:dÀ:MÀ:GÀ:UÀ:cÀ:VÀ:]À:bÀ:^À:eÀ:”À:lÀ:fÀ:nÀ:À:ˆÀ:À:ştÀ;e   À:şÀ:ÿÀ;À;#À;À;À;À;"À;À;À;!À;À;$À;TÀ;+À;%À;-À;NÀ;HÀ;PÀ;É€‚À<7   À;ÉÀ;ÊÀ;ĞÀ;îÀ;×À;ÑÀ;ßÀ;íÀ;àÀ;çÀ;ìÀ;èÀ;ïÀ<&À;öÀ;ğÀ;øÀ< À<À<"À<ŸpÀ=   À<ŸÀ< À<«À<¬À<²À<ÏÀ<¸À<³À<ÀÀ<ÎÀ<ÁÀ<ÈÀ<ÍÀ<ÉÀ<ĞÀ<óÀ<×À<ÑÀ<ÙÀ=ƒlÀ=-  À=?À=E  À=QÀ=W  À=À=À@ƒ€¾À@ü  ÀAÀA  ÀAÀA#  ÀA/ÀA4  À@ƒÀ@„À@ŠÀ@½À@À@‹À@˜À@¼À@™À@ À@¥À@¡À@¨À@°À@·À@¾À@êÀ@ÅÀ@¿À@Ç ÀHÈƒùÀJDu/// An exception thrown by [Canvas.drawImage] and related methods when drawing
/// an [Image] created via [Picture.toImageSync] that is in an invalid state.
///
/// This exception may be thrown if the requested image dimensions exceeded the
/// maximum 2D texture size allowed by the GPU, or if no GPU surface or context
/// was available for rasterization at request time. ÀJ{BÀJÀJŸÀJ  ÀJ¡ÀJ§  ÀJ°
ÀJ¶   ÀJÁIÀK2/// A string containing details about the failure. ÀKiÀKsO/// If available, the stack trace at the time [Picture.toImageSync] was called.  ÀK}BÀK   ÀK}ÀK~  ±çÀ Oò½‹/// Algorithms to use when painting on the canvas.
///
/// When drawing a shape or image onto a canvas, different algorithms can be
/// used to blend the pixels. The different values of [BlendMode] specify
/// different such algorithms.
///
/// Each algorithm has two inputs, the _source_, which is the image being drawn,
/// and the _destination_, which is the image into which the source image is
/// being composited. The destination is often thought of as the _background_.
/// The source and destination both have four color channels, the red, green,
/// blue, and alpha channels. These are typically represented as numbers in the
/// range 0.0 to 1.0. The output of the algorithm also has these same four
/// channels, with values computed from the source and destination.
///
/// The documentation of each value below describes how the algorithm works. In
/// each case, an image shows the output of blending a source image with a
/// destination image. In the images below, the destination is represented by an
/// image with horizontal lines and an opaque landscape photograph, and the
/// source is represented by an image with vertical lines (the same lines but
/// rotated) and a bird clip-art image. The [src] mode shows only the source
/// image, and the [dst] mode shows only the destination image. In the
/// documentation below, the transparency is illustrated by a checkerboard
/// pattern. The [clear] mode drops both the source and destination, resulting
/// in an output that is entirely transparent (illustrated by a solid
/// checkerboard pattern).
///
/// The horizontal and vertical bars in these images show the red, green, and
/// blue channels with varying opacity levels, then all three color channels
/// together with those same varying opacity levels, then all three color
/// channels set to zero with those varying opacity levels, then two bars showing
/// a red/green/blue repeating gradient, the first with full opacity and the
/// second with partial opacity, and finally a bar with the three color channels
/// set to zero but the opacity varying in a repeating gradient.
///
/// ## Application to the [Canvas] API
///
/// When using [Canvas.saveLayer] and [Canvas.restore], the blend mode of the
/// [Paint] given to the [Canvas.saveLayer] will be applied when
/// [Canvas.restore] is called. Each call to [Canvas.saveLayer] introduces a new
/// layer onto which shapes and images are painted; when [Canvas.restore] is
/// called, that layer is then composited onto the parent layer, with the source
/// being the most-recently-drawn shapes and images, and the destination being
/// the parent layer. (For the first [Canvas.saveLayer] call, the parent layer
/// is the canvas itself.)
///
/// See also:
///
///  * [Paint.blendMode], which uses [BlendMode] to define the compositing
///    strategy.  ½¹€î¾¢€Ş/// Drop both the source and destination images, leaving nothing.
///
/// This corresponds to the "clear" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_clear.png) ¾¬H¿ñ4/// Drop the destination image, only paint the source image.
///
/// Conceptually, the destination is first cleared, then the source image is
/// painted.
///
/// This corresponds to the "Copy" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_src.png) ¿ùMÀ AC9/// Drop the source image, only paint the destination image.
///
/// Conceptually, the source image is discarded, leaving the destination
/// untouched.
///
/// This corresponds to the "Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dst.png) À AKìÀ C0Ğ/// Composite the source image over the destination image.
///
/// This is the default value. It represents the most intuitive case, where
/// shapes are painted on top of what is below, with transparent areas showing
/// the destination layer.
///
/// This corresponds to the "Source over Destination" Porter-Duff operator,
/// also known as the Painter's Algorithm.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOver.png) À C<­À Dâ‘/// Composite the source image under the destination image.
///
/// This is the opposite of [srcOver].
///
/// This corresponds to the "Destination over Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOver.png)
///
/// This is useful when the source image should have been painted before the
/// destination image, but could not be. À Dî‚šÀ Gƒ‚x/// Show the source image, but only where the two images overlap. The
/// destination image is not rendered, it is treated merely as a mask. The
/// color channels of the destination are ignored, only the opacity has an
/// effect.
///
/// To show the destination image instead, consider [dstIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is absent, rather than where it is present), consider
/// [srcOut].
///
/// This corresponds to the "Source in Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcIn.png) À G‚„À J‚f/// Show the destination image, but only where the two images overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [dstOut].
///
/// This corresponds to the "Destination in Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstIn.png) À J‚˜À L¨‚y/// Show the source image, but only where the two images do not overlap. The
/// destination image is not rendered, it is treated merely as a mask. The color
/// channels of the destination are ignored, only the opacity has an effect.
///
/// To show the destination image instead, consider [dstOut].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [srcIn].
///
/// This corresponds to the "Source out Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOut.png) À L³‚À O;‚o/// Show the destination image, but only where the two images do not overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcOut].
///
/// To reverse the semantic of the mask (only showing the destination where the
/// source is present, rather than where it is absent), consider [dstIn].
///
/// This corresponds to the "Destination out Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOut.png) À OF‚gÀ Q¦‚E/// Composite the source image over the destination image, but only where it
/// overlaps the destination.
///
/// This corresponds to the "Source atop Destination" Porter-Duff operator.
///
/// This is essentially the [srcOver] operator, but with the output's opacity
/// channel being set to that of the destination image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the destination on top instead of the source, see
/// [dstATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcATop.png) À Q²‚]À T‚;/// Composite the destination image over the source image, but only where it
/// overlaps the source.
///
/// This corresponds to the "Destination atop Source" Porter-Duff operator.
///
/// This is essentially the [dstOver] operator, but with the output's opacity
/// channel being set to that of the source image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the source on top instead of the destination, see
/// [srcATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstATop.png) À T;À UL+/// Apply a bitwise `xor` operator to the source and destination images. This
/// leaves transparency where they would overlap.
///
/// This corresponds to the "Source xor Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_xor.png) À UTƒOÀ XŸƒ,/// Sum the components of the source and destination images.
///
/// Transparency in a pixel of one of the images reduces the contribution of
/// that image to the corresponding output pixel, as if the color of that
/// pixel in that image was darker.
///
/// This corresponds to the "Source plus Destination" Porter-Duff operator.
///
/// This is the right blend mode for cross-fading between two images. Consider
/// two images A and B, and an interpolation time variable _t_ (from 0.0 to
/// 1.0). To cross fade between them, A should be drawn with opacity 1.0 - _t_
/// into a new layer using [BlendMode.srcOver], and B should be drawn on top
/// of it, at opacity _t_, into the same layer, using [BlendMode.plus].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_plus.png) À X¨ƒVÀ [öƒ'/// Multiply the color components of the source and destination images.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// When compositing two opaque images, this has similar effect to overlapping
/// two transparencies on a projector.
///
/// For a variant that also multiplies the alpha channel, consider [multiply].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_modulate.png)
///
/// See also:
///
///  * [screen], which does a similar computation but inverted.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À \L…!À ag„â/// Multiply the inverse of the components of the source and destination
/// images, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// This is essentially the same as [modulate] blend mode, but with the values
/// of the colors inverted before the multiplication and the result being
/// inverted back before rendering.
///
/// This can only result in the same or lighter colors (multiplying by black,
/// 1.0, results in no change; multiplying by white, 0.0, results in white).
/// Similarly, in the alpha channel, it can only result in more opaque colors.
///
/// This has similar effect to two projectors displaying their images on the
/// same screen simultaneously.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_screen.png)
///
/// See also:
///
///  * [modulate], which does a similar computation but without inverting the
///    values.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À a‹ƒŞÀ ebƒ®/// Multiply the components of the source and destination images after
/// adjusting them to favor the destination.
///
/// Specifically, if the destination value is smaller, this multiplies it with
/// the source value, whereas is the source value is smaller, it multiplies
/// the inverse of the source value with the inverse of the destination value,
/// then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_overlay.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [hardLight], which is similar to [overlay] but favors the source image
///    instead of the destination image. À en7À fŸ"/// Composite the source and destination image by choosing the lowest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_darken.png) À fª:À gİ$/// Composite the source and destination image by choosing the highest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_lighten.png) À gé{À iZb/// Divide the destination by the inverse of the source.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorDodge.png) À ii‘À jñy/// Divide the inverse of the destination by the source, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorBurn.png) À jÿƒâÀ nØƒ°/// Multiply the components of the source and destination images after
/// adjusting them to favor the source.
///
/// Specifically, if the source value is smaller, this multiplies it with the
/// destination value, whereas is the destination value is smaller, it
/// multiplies the inverse of the destination value with the inverse of the
/// source value, then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hardLight.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [overlay], which is similar to [hardLight] but favors the destination
///    image instead of the source image. À næsÀ pPU/// Use [colorDodge] for source values below 0.5 and [colorBurn] for source
/// values above 0.5.
///
/// This results in a similar but softer effect than [overlay].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_softLight.png)
///
/// See also:
///
///  * [color], which is a more subtle tinting effect. À p^ÅÀ r¤/// Subtract the smaller value from the bigger value for each channel.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [exclusion] but harsher.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_difference.png) À r(ÔÀ só²/// Subtract double the product of the two images from the sum of the two
/// images.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [difference] but softer.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_exclusion.png) À t‚ÙÀ vÒ‚´/// Multiply the components of the source and destination images, including
/// the alpha channel.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// Since the alpha channel is also multiplied, a fully-transparent pixel
/// (opacity 0.0) in one image results in a fully transparent pixel in the
/// output. This is similar to [dstIn], but with the colors combined.
///
/// For a variant that multiplies the colors but does not multiply the alpha
/// channel, consider [modulate].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_multiply.png) À vü‚÷À yğ‚Ñ/// Take the hue of the source image, and the saturation and luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hue.png)
///
/// See also:
///
///  * [color], which is a similar but stronger effect as it also applies the
///    saturation of the source image.
///  * [HSVColor], which allows colors to be expressed using Hue rather than
///    the red/green/blue channels of [Color]. À yø‚dÀ |R‚=/// Take the saturation of the source image, and the hue and luminosity of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hue.png)
///
/// See also:
///
///  * [color], which also applies the hue of the source image.
///  * [luminosity], which applies the luminosity of the source image to the
///    destination. À |a‚ãÀ ?‚½/// Take the hue and saturation of the source image, and the luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue and saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_color.png)
///
/// See also:
///
///  * [hue], which is a similar but weaker effect.
///  * [softLight], which is a similar tinting effect but also tints white.
///  * [saturation], which only applies the saturation of the source image. À I‚À Ì‚d/// Take the luminosity of the source image, and the hue and saturation of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their luminosity from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_luminosity.png)
///
/// See also:
///
///  * [saturation], which applies the saturation of the source image to the
///    destination.
///  * [ImageFilter.blur], which can be used with [BackdropFilter] for a
///    related effect.    À ÛŒ{À ‡U…t/// Quality levels for image sampling in [ImageFilter] and [Shader] objects that sample
/// images and for [Canvas] operations that render images.
///
/// When scaling up typically the quality is lowest at [none], higher at [low] and [medium],
/// and for very large scale factors (over 10x) the highest at [high].
///
/// When scaling down, [medium] provides the best quality especially when scaling an
/// image to less than half its size or for animating the scale factor between such
/// reductions. Otherwise, [low] and [high] provide similar effects for reductions of
/// between 50% and 100% but the image may lose detail and have dropouts below 50%.
///
/// To get high quality when scaling images up and down, or when the scale is
/// unknown, [medium] is typically a good balanced choice.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/filter_quality.png)
///
/// When building for the web using the `--web-renderer=html` option, filter
/// quality has no effect. All images are rendered using the respective
/// browser's default setting.
///
/// See also:
///
///  * [Paint.filterQuality], which is used to pass [FilterQuality] to the
///    engine while using drawImage calls on a [Canvas].
///  * [ImageShader].
///  * [ImageFilter.matrix].
///  * [Canvas.drawImage].
///  * [Canvas.drawImageRect].
///  * [Canvas.drawImageNine].
///  * [Canvas.drawAtlas].  À ‡æ€ÙÀ ˆ»€Ì/// The fastest filtering method, albeit also the lowest quality.
///
/// This value results in a "Nearest Neighbor" algorithm which just
/// repeats or eliminates pixels as an image is scaled up or down. À ˆÄ€²À ‰s€¦/// Better quality than [none], faster than [medium].
///
/// This value results in a "Bilinear" algorithm which smoothly
/// interpolates between pixels in an image. À ‰{‚À Œ‚k/// The best all around filtering method that is only worse than [high]
/// at extremely large scale factors.
///
/// This value improves upon the "Bilinear" algorithm specified by [low]
/// by utilizing a Mipmap that pre-computes high quality lower resolutions
/// of the image at half (and quarter and eighth, etc.) sizes and then
/// blends between those to prevent loss of detail at small scale sizes.
///
/// {@template dart.ui.filterQuality.seeAlso}
/// See also:
///
///  * [FilterQuality] class-level documentation that goes into detail about
///    relative qualities of the constant values.
/// {@endtemplate} À Œ‚EÀ O‚&/// Best possible quality when scaling up images by scale factors larger than
/// 5-10x.
///
/// When images are scaled down, this can be worse than [medium] for scales
/// smaller than 0.5x, or when animating the scale factor.
///
/// This option is also the slowest.
///
/// This value results in a standard "Bicubic" algorithm which uses a 3rd order
/// equation to smooth the abrupt transitions between pixels while preserving
/// some of the sense of an edge and avoiding sharp peaks in the result.
///
/// {@macro dart.ui.filterQuality.seeAlso}    À X†ÆÀ K€±/// Styles to use for line endings.
///
/// See also:
///
///  * [Paint.strokeCap] for how this value is used.
///  * [StrokeJoin] for the different kinds of line segment joins.  À Y…À Úr/// Begin and end contours with a flat edge and no extension.
///
/// ![A butt cap ends line segments with a square end that stops at the end of
/// the line segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/butt_cap.png)
///
/// Compare to the [square] cap, which has the same shape, but extends past
/// the end of the line by half a stroke width. À ãËÀ ’©µ/// Begin and end contours with a semi-circle extension.
///
/// ![A round cap adds a rounded end to the line segment that protrudes
/// by one half of the thickness of the line (which is the radius of the cap)
/// past the end of the segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line. À ’³‚hÀ •‚I/// Begin and end contours with a half square extension. This is
/// similar to extending each contour by half the stroke width (as
/// given by [Paint.strokeWidth]).
///
/// ![A square cap has a square end that effectively extends the line length
/// by half of the stroke width.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/square_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line.
///
/// Compare to the [butt] cap, which has the same shape, but doesn't extend
/// past the end of the line.    À • ˆÀ –Êg/// Styles to use for line segment joins.
///
/// This only affects line joins for polygons drawn by [Canvas.drawPath] and
/// rectangles, not points drawn as lines with [Canvas.drawPoints].
///
/// See also:
///
/// * [Paint.strokeJoin] and [Paint.strokeMiterLimit] for how this value is
///   used.
/// * [StrokeCap] for the different kinds of line endings.  À –Ù‚YÀ ™-‚7/// Joins between line segments form sharp corners.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.
///   * [Paint.strokeMiterLimit], used to define when a miter is drawn instead
///     of a bevel when the join is set to this value. À ™7ÌÀ šş®/// Joins between line segments are semi-circular.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value. À ›‚À ÷/// Joins between line segments connect the corners of the butt ends of the
/// line segments to give a beveled appearance.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.    À $‚ÖÀ ºT/// Strategies for painting shapes and paths on a canvas.
///
/// See [Paint.style].  À &€·À Ù€¬/// Apply the [Paint] to the inside of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results in a disc
/// of the given size being painted. À âÀ Ÿñ/// Apply the [Paint] to the edge of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results is a hoop
/// of the given size being painted. The line drawn on the edge will
/// be the width given by the [Paint.strokeWidth] property.    À ŸüŒ‡À  0./// Different ways to clip a widget's content.  À  9‚8À ¢m‚/// No clip at all.
///
/// This is the default option for most widgets: if the content does not
/// overflow the widget boundary, don't pay any performance cost for clipping.
///
/// If the content does overflow, please explicitly specify the following
/// [Clip] options:
///  * [hardEdge], which is the fastest clipping, but with lower fidelity.
///  * [antiAlias], which is a little slower than [hardEdge], but with smoothed edges.
///  * [antiAliasWithSaveLayer], which is much slower than [antiAlias], and should
///    rarely be used. À ¢v‚_À ¤Í‚:/// Clip, but do not apply anti-aliasing.
///
/// This mode enables clipping, but curves and non-axis-aligned straight lines will be
/// jagged as no effort is made to anti-alias.
///
/// Faster than other clipping modes, but slower than [none].
///
/// This is a reasonable choice when clipping is needed, if the container is an axis-
/// aligned rectangle or an axis-aligned rounded rectangle with very small corner radii.
///
/// See also:
///
///  * [antiAlias], which is more reasonable when clipping is needed and the shape is not
///    an axis-aligned rectangle. À ¤Úƒ.À §ÿƒ /// Clip with anti-aliasing.
///
/// This mode has anti-aliased clipping edges to achieve a smoother look.
///
/// It' s much faster than [antiAliasWithSaveLayer], but slower than [hardEdge].
///
/// This will be the common case when dealing with circles and arcs.
///
/// Different from [hardEdge] and [antiAliasWithSaveLayer], this clipping may have
/// bleeding edge artifacts.
/// (See https://fiddle.skia.org/c/21cb4c2b2515996b537f36e7819288ae for an example.)
///
/// See also:
///
///  * [hardEdge], which is a little faster, but with lower fidelity.
///  * [antiAliasWithSaveLayer], which is much slower, but can avoid the
///    bleeding edges if there's no other way.
///  * [Paint.isAntiAlias], which is the anti-aliasing switch for general draw operations. À ¨„sÀ ¬j„4/// Clip with anti-aliasing and saveLayer immediately following the clip.
///
/// This mode not only clips with anti-aliasing, but also allocates an offscreen
/// buffer. All subsequent paints are carried out on that buffer before finally
/// being clipped and composited back.
///
/// This is very slow. It has no bleeding edge artifacts (that [antiAlias] has)
/// but it changes the semantics as an offscreen buffer is now introduced.
/// (See https://github.com/flutter/flutter/issues/18057#issuecomment-394197336
/// for a difference between paint without saveLayer and paint with saveLayer.)
///
/// This will be only rarely needed. One case where you might need this is if
/// you have an image overlaid on a very different background color. In these
/// cases, consider whether you can avoid overlaying multiple colors in one
/// spot (e.g. by having the background color only present where the image is
/// absent). If you can, [antiAlias] would be fine and much faster.
///
/// See also:
///
///  * [antiAlias], which is much faster, and has similar clipping results.    À ó¡ƒ×À õrË/// The color space describes the colors that are available to an [Image].
///
/// This value can help decide which [ImageByteFormat] to use with
/// [Image.toByteData]. Images that are in the [extendedSRGB] color space
/// should use something like [ImageByteFormat.rawExtendedRgba128] so that
/// colors outside of the sRGB gamut aren't lost.
///
/// This is also the result of [Image.colorSpace].
///
/// See also: https://en.wikipedia.org/wiki/Color_space  À õ€ØÀ öU€Ç/// The sRGB color space.
///
/// You may know this as the standard color space for the web or the color
/// space of non-wide-gamut Flutter apps.
///
/// See also: https://en.wikipedia.org/wiki/SRGB À ö]À ÷i/// A color space that is backwards compatible with sRGB but can represent
/// colors outside of that gamut with values outside of [0..1]. In order to
/// see the extended values an [ImageByteFormat] like
/// [ImageByteFormat.rawExtendedRgba128] must be used.    À ÷z‰À ùY/// The format in which image bytes should be returned when using
/// [Image.toByteData].  À ù€‚À ù•t/// Raw RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with premultiplied alpha, 8 bits per channel. À ù¡€À ú x/// Raw straight RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with straight alpha, 8 bits per channel. À ú4€»À úâ€¥/// Raw unmodified format.
///
/// Unencoded bytes, in the image's existing format. For example, a grayscale
/// image may use a single 8-bit channel for each pixel. À úô‚ÎÀ ı°‚/// Raw extended range RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with straight alpha, 32 bit
/// float (IEEE 754 binary32) per channel.
///
/// Example usage:
///
/// ```dart
/// import 'dart:ui' as ui;
/// import 'dart:typed_data';
///
/// Future<Map<String, double>> getFirstPixel(ui.Image image) async {
///   final ByteData data =
///       (await image.toByteData(format: ui.ImageByteFormat.rawExtendedRgba128))!;
///   final Float32List floats = Float32List.view(data.buffer);
///   return <String, double>{
///     'r': floats[0],
///     'g': floats[1],
///     'b': floats[2],
///     'a': floats[3],
///   };
/// }
/// ``` À ıÇ‚¾À ‚‚œ/// PNG format.
///
/// A loss-less compression format for images. This format is well suited for
/// images with hard edges, such as screenshots or sprites, and images with
/// text. Transparency is supported. The PNG format supports images up to
/// 2,147,483,647 pixels in either dimension, though in practice available
/// memory provides a more immediate limitation on maximum image size.
///
/// PNG images normally use the `.png` file extension and the `image/png` MIME
/// type.
///
/// See also:
///
///  * <https://en.wikipedia.org/wiki/Portable_Network_Graphics>, the Wikipedia page on PNG.
///  * <https://tools.ietf.org/rfc/rfc2083.txt>, the PNG standard.    À Šƒ?À Î>/// The format of pixel data given to [decodeImageFromPixels].  À Ş€ÙÀ¯€Ê/// Each pixel is 32 bits, with the highest 8 bits encoding red, the next 8
/// bits encoding green, the next 8 bits encoding blue, and the lowest 8 bits
/// encoding alpha. Premultiplied alpha is used. À¼€ÙÀ€Ê/// Each pixel is 32 bits, with the highest 8 bits encoding blue, the next 8
/// bits encoding green, the next 8 bits encoding red, and the lowest 8 bits
/// encoding alpha. Premultiplied alpha is used. Àš,À»/// Each pixel is 128 bits, where each color component is a 32 bit float that
/// is normalized across the sRGB gamut.  The first float is the red
/// component, followed by: green, blue and alpha. Premultiplied alpha isn't
/// used, matching [ImageByteFormat.rawExtendedRgba128].    Àz‡ƒ•À{$€—/// Determines the winding rule that decides how the interior of a [Path] is
/// calculated.
///
/// This enum is used by the [Path.fillType] property.  À{5¯À|İ—/// The interior is defined by a non-zero sum of signed edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses lines going clockwise
/// around the point a different number of times than it crosses lines going
/// counter-clockwise around that point.
///
/// See: <https://en.wikipedia.org/wiki/Nonzero-rule> À|é0À~/// The interior is defined by an odd number of edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses an odd number of lines.
///
/// See: <https://en.wikipedia.org/wiki/Even-odd_rule>    À~ˆLÀ~Ò€ˆ/// Strategies for combining paths.
///
/// See also:
///
/// * [Path.combine], which uses this enum to decide how to combine two paths.  À~ä£À€}„/// Subtract the second path from the first path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// first circle that was not overlapped by the second circle.
///
/// See also:
///
///  * [reverseDifference], which is the same but subtracting the first path
///    from the second. À€‹‡À‚	k/// Create a new path that is the intersection of the two paths, leaving the
/// overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be only the overlapping portion
/// of the two circles.
///
/// See also:
///  * [xor], which is the inverse of this operation À‚$Àƒ5/// Create a new path that is the union (inclusive-or) of the two paths.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a figure-eight like shape
/// matching the outer boundaries of both circles. Àƒ>‚À„½n/// Create a new path that is the exclusive-or of the two paths, leaving
/// everything but the overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the figure-eight like shape less the overlapping parts
///
/// See also:
///  * [intersect], which is the inverse of this operation À„Ä£À†V}/// Subtract the first path from the second path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// second circle that was not overlapped by the first circle.
///
/// See also:
///
///  * [difference], which is the same but subtracting the second path
///    from the first.    À§ƒ{À4/// Styles to use for blurs in [MaskFilter] objects.  Àd€–Àô€‹/// Fuzzy inside and outside. This is useful for painting shadows that are
/// offset from the shape that ostensibly is casting the shadow. Àÿ€ÍÀÇ€Á/// Solid inside, fuzzy outside. This corresponds to drawing the shape, and
/// additionally drawing the blur. This can make objects appear brighter,
/// maybe even as if they were fluorescent. ÀÑ€æÀ²€Ú/// Nothing inside, fuzzy outside. This is useful for painting shadows for
/// partially transparent shapes, when they are painted separately but without
/// an offset, so that the shadow doesn't paint below the shape. À¼cÀY/// Fuzzy inside, nothing outside. This can make shapes appear to be lit from
/// within.    ÀjÀ“Àq“†’/// Defines what happens at the edge of a gradient or the sampling of a source image
/// in an [ImageFilter].
///
/// A gradient is defined along a finite inner area. In the case of a linear
/// gradient, it's between the parallel lines that are orthogonal to the line
/// drawn between two points. In the case of radial gradients, it's the disc
/// that covers the circle centered on a particular point up to a given radius.
///
/// An image filter reads source samples from a source image and performs operations
/// on those samples to produce a result image. An image defines color samples only
/// for pixels within the bounds of the image but some filter operations, such as a blur
/// filter, read samples over a wide area to compute the output for a given pixel. Such
/// a filter would need to combine samples from inside the image with hypothetical
/// color values from outside the image.
///
/// This enum is used to define how the gradient or image filter should treat the regions
/// outside that defined inner area.
///
/// See also:
///
///  * [painting.Gradient], the superclass for [LinearGradient] and
///    [RadialGradient], as used by [BoxDecoration] et al, which works in
///    relative coordinates and can create a [Shader] representing the gradient
///    for a particular [Rect] on demand.
///  * [dart:ui.Gradient], the low-level class used when dealing with the
///    [Paint.shader] property directly, with its [Gradient.linear] and
///    [Gradient.radial] constructors.
///  * [dart:ui.ImageFilter.blur], an ImageFilter that may sometimes need to
///    read samples from outside an image to combine with the pixels near the
///    edge of the image.  Àq ‚£Àt>‚‡/// Samples beyond the edge are clamped to the nearest color in the defined inner area.
///
/// A gradient will paint all the regions outside the inner area with the
/// color at the end of the color stop list closest to that region.
///
/// An image filter will substitute the nearest edge pixel for any samples taken from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png) ÀtHƒ5Àwuƒ/// Samples beyond the edge are repeated from the far end of the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated from 1.0 to 2.0, 2.0 to 3.0, and so forth (and for linear gradients, similarly
/// from -1.0 to 0.0, -2.0 to -1.0, etc).
///
/// An image filter will treat its source image as if it were tiled across the enlarged
/// sample space from which it reads, each tile in the same orientation as the base image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png) Àw‚ƒ|ÀzøƒY/// Samples beyond the edge are mirrored back and forth across the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated backwards from 2.0 to 1.0, then forwards from 2.0 to 3.0, then backwards
/// again from 4.0 to 3.0, and so forth (and for linear gradients, similarly in the
/// negative direction).
///
/// An image filter will treat its source image as tiled in an alternating forwards and
/// backwards or upwards and downwards direction across the sample space from which
/// it is reading.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png) À{‚½À}»‚Ÿ/// Samples beyond the edge are treated as transparent black.
///
/// A gradient will render transparency over any region that is outside the circle of a
/// radial gradient or outside the parallel lines that define the inner area of a linear
/// gradient.
///
/// An image filter will substitute transparent black for any sample it must read from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)    ÀÑ½‚ÃÀÒww/// Defines how a list of points is interpreted when drawing a set of triangles.
///
/// Used by [Canvas.drawVertices].  ÀÒ†QÀÒÎE/// Draw each sequence of three points as the vertices of a triangle. ÀÒÜ[ÀÓ*K/// Draw each sliding window of three points as the vertices of a triangle. ÀÓ<AÀÔr)/// Draw the first point and each sliding window of two points as the vertices
/// of a triangle.
///
/// This mode is not natively supported by most backends, and is instead
/// implemented by unrolling the points into the equivalent
/// [VertexMode.triangles], which is generally more efficient.    À Š„-Àa€/// Defines how a list of points is interpreted when drawing a set of points.
///
/// Used by [Canvas.drawPoints] and [Canvas.drawRawPoints].  Ào·À /// Draw each point separately.
///
/// If the [Paint.strokeCap] is [StrokeCap.round], then each point is drawn
/// as a circle with the diameter of the [Paint.strokeWidth], filled as
/// described by the [Paint] (ignoring [Paint.style]).
///
/// Otherwise, each point is drawn as an axis-aligned square with sides of
/// length [Paint.strokeWidth], filled as described by the [Paint] (ignoring
/// [Paint.style]). À+€éÀ€×/// Draw each sequence of two points as a line segment.
///
/// If the number of points is odd, then the last point is ignored.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]). À€›À­€‹/// Draw the entire sequence of points as one line.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]).    À¹À7x/// Defines how a new clip region should be merged with the existing clip
/// region.
///
/// Used by [Canvas.clipRect].  ÀBBÀz5/// Subtract the new region from the existing region. À‰BÀÂ6/// Intersect the new region from the existing region.       „‹o„  „	„£   „üt…  ……   …r€…w  …†…   †€Û†  ††%   †à€†å  †ô†ü   ‡om‡u  ‡‡ˆ  ‡Š‡’   ÀG‰?ÀNò‡‰/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API, and
/// using [ImageDescriptor] directly is preferred since it allows the caller to
/// make better determinations about how and whether to use the `targetWidth`
/// and `targetHeight` parameters.
///
/// The `list` parameter is the binary image data (e.g a PNG or GIF binary data).
/// The data can be for either static or animated images. The following image
/// formats are supported:
/// {@template dart.ui.imageFormats}
/// JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP. Additional
/// formats may be supported by the underlying platform. Flutter will
/// attempt to call platform API to decode unrecognized formats, and if the
/// platform API supports decoding the image Flutter will be able to render it.
/// {@endtemplate}
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true.
///
/// The returned future can complete with an error if the image decoding has
/// failed. ÀOÀO  ÀOÀO%  ÀO3ÀO9  ÀOHÀON  ÀO^ÀP[Š¡ÀX•ˆ+/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API, and
/// using [ImageDescriptor] directly is preferred since it allows the caller to
/// make better determinations about how and whether to use the `targetWidth`
/// and `targetHeight` parameters.
///
/// The [buffer] parameter is the binary image data (e.g a PNG or GIF binary data).
/// The data can be for either static or animated images. The following image
/// formats are supported: {@macro dart.ui.imageFormats}
///
/// The [buffer] will be disposed by this method once the codec has been created,
/// so the caller must relinquish ownership of the [buffer] when they call this
/// method.
///
/// The [targetWidth] and [targetHeight] arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true.
///
/// The returned future can complete with an error if the image decoding has
/// failed.
///
/// ## Compatibility note on the web
///
/// When running Flutter on the web, only the CanvasKit renderer supports image
/// resizing capabilities (not the HTML renderer). So if image resizing is
/// critical to your use case, and you're deploying to the web, you should
/// build using the CanvasKit renderer. ÀX¸ÀXÉ  ÀXÔÀXÚ  ÀXèÀXî  ÀXıÀY  ÀYÀZş‰„Àb‡/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API.
///
/// The [buffer] parameter is the binary image data (e.g a PNG or GIF binary
/// data). The data can be for either static or animated images. The following
/// image formats are supported: {@macro dart.ui.imageFormats}
///
/// The [buffer] will be disposed by this method once the codec has been
/// created, so the caller must relinquish ownership of the [buffer] when they
/// call this method.
///
/// The [getTargetSize] parameter, when specified, will be invoked and passed
/// the image's intrinsic size to determine the size to decode the image to.
/// The width and the height of the size it returns must be positive values
/// greater than or equal to 1, or null. It is valid to return a
/// [TargetImageSize] that specifies only one of `width` and `height` with the
/// other remaining null, in which case the omitted dimension will be scaled to
/// maintain the aspect ratio of the original dimensions. When both are null or
/// omitted, the image will be decoded at its native resolution (as will be the
/// case if the [getTargetSize] parameter is omitted).
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform.
///
/// The returned future can complete with an error if the image decoding has
/// failed.
///
/// ## Compatibility note on the web
///
/// When running Flutter on the web, only the CanvasKit renderer supports image
/// resizing capabilities (not the HTML renderer). So if image resizing is
/// critical to your use case, and you're deploying to the web, you should
/// build using the CanvasKit renderer. Àb6ÀbG  ÀbR&Àbl   Àd„sÀd”  Àd©Àd®  Àd½ÀdÂ   ÀlË©Àn0/// Loads a single image frame from a byte array into an [Image] object.
///
/// This is a convenience wrapper around [instantiateImageCodec]. Prefer using
/// [instantiateImageCodec] which also supports multi frame images and offers
/// better error handling. This function swallows asynchronous errors. ÀnÀn   Àn%Àn;   Ànv€ïÀnƒ  ÀnÀn¨  Àn­ÀnÃ   Àog‹Àu
…/// Convert an array of pixel values into an [Image] object.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `format`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true. 	Àu#Àu.  Àu7	Àu<  ÀuD
ÀuI  ÀuRÀu_  ÀuhÀu~  Àu‹Àu‘  ÀuœÀu¢  Àu°Àu¶  ÀuÅÀuË  ÀuÛÀ}Å€ëÀ}Ï  À}àÀ}í   À~²›À~¾  À~ÏÀ~İ   À€O$À€[  À€lÀ€t  À€{À€ƒ   ÀF
‚¼ÀF ÀFÀFÀF!ÀF1    ÀËdÀÿ+/// Signature for [Image] lifecycle events.  À"À)   À1ÓmÀ21/// Callback signature for [decodeImageFromList].  À22À29   ÀdùdÀeú€ø/// Signature for a callback that determines the size to which an image should
/// be decoded given its intrinsic size.
///
/// See also:
///
///  * [instantiateImageCodecWithSize], which used this signature for its
///    `getTargetSize` argument.  Àf0Àf5  ÀfFÀfK   ÀäÜlÀå-/// Signature for [Picture] lifecycle events.  Àå7Àå@   ÀAEdÀA‚4/// Generic callback signature, used by [_futurize].ÀAŒÀAŒ ÀAŸÀA¢   ÀA«€ÕÀBF€’/// Signature for a method that receives a [_Callback].
///
/// Return value should be null on success, and a string error message on
/// failure.ÀBRÀBR ÀBhÀBw       ›N <€†€¤€µ€¶€Î€ï-Fz­®û‚E‚•‚æƒ6ƒ„ƒÕ„„„d„Š„‹„ª„ê„ù„û„ü……`…o…q…r…—…ñ† †††/†p†Î†İ†ß†à‡‡]‡l‡n‡o‡›‡Û‡İ‡Şˆˆˆfˆ¶‰‰-‰1‰a‰e‰q‰™‰ÖŠŠFŠNŠRŠ£Šò‹B‹n‹r‹~‹ËŒŒŒŒ-Œ1Œ„ŒÊŒØEKs™Àåë;‰·½Pu¬­íó@PuœÂÈ‘‘‘\‘i‘‘À‘â’’2’3’ˆ’’³’Ú“ “M“}“ƒ“Æ“Ì””R”ˆ”¾”ô•6•7•e•k•“•™•Á•ç––3–F–G–€–†–Õ–÷—&—'—Z—`—±—Ó—ù—ú˜1˜^˜_˜˜˜Æ˜Ç˜ÿ™,™-™v™¬™²™êšš5š9š:šƒšËšÑ›	›/›]››’›“›ãœœœNœgœ™œœœç#[v¦ª«ü)/g²¶·õŸ2ŸRŸrŸxŸ¹Ÿ½Ÿ¾ 	  c  ‡ Å ã¡#¡^¡›¡×¢¢¢¢<¢B¢Š¢Í¢Ó££j£©£ï£õ¤B¤Œ¤×¥#¥q¥Á¦¦_¦Œ¦’¦á§§6§K§b§w§†§®§¶§Ã§Ú§ü¨¨*¨n¨®¨ò©4©?©G©M©Q©R©•©Û©áª-ªtª¿««Y«™«Á¬ ¬¬¬F¬l¬£¬À¬Î­­^­¦­¯­Ì­ş®,®L®i®{®Æ¯¯b¯k¯q¯u¯v¯Ã¯É¯ô°'°b°f°g°s°–°¸°Ë°Ñ°ı±±±1±R±V±W±c±‰±Š±–±ä±æ±ç²²²k²µ²Ô²Ø³)³v³Å´´c´®´ò´öµFµ‘µâ¶.¶|¶É··[·ª·ğ¸¸¸]¸ª¸ô¹F¹“¹äº%º)ºPºTº¢ºã»4»»Ò¼!¼p¼‹¼¼¼¡¼ì¼ı½½]½p½¶½·½û¾¾=¾C¾ ¾©¾ª¾é¾ï¿>¿M¿S¿¿”¿ï¿ö¿÷À @6À @<À @‡À @˜À @À @àÀ @æÀ AAÀ AHÀ AIÀ A†À AŒÀ AÚÀ B+À BHÀ BNÀ BœÀ BÉÀ BÏÀ C.À C9À C:À CxÀ C~À C§À C­À CûÀ DÀ D`À DfÀ DµÀ DàÀ DëÀ DìÀ E4À EÀ EÎÀ EÜÀ EâÀ F!À F'À FtÀ F¼À FÌÀ FÒÀ GÀ G$À GÀ GŠÀ G‹À GØÀ H&À HpÀ HvÀ H°À H¶À IÀ IUÀ I[À I§À I­À J
À JÀ JÀ JcÀ J¶À KÀ KÀ KKÀ KQÀ KÀ KïÀ KõÀ LBÀ LHÀ L¦À L°À L±À MÀ MSÀ MÀ M£À MŞÀ MäÀ N6À N‚À NˆÀ NÕÀ NÛÀ O9À OCÀ ODÀ O“À O³À O¹À PÀ PÀ P]À P©À PİÀ PãÀ Q.À Q?À QEÀ Q¤À Q¯À Q°À QÿÀ RÀ R À RnÀ RtÀ RÄÀ SÀ S?À SEÀ SÀ S¡À S§À TÀ TÀ TÀ TbÀ T–À TœÀ TéÀ TïÀ UJÀ UQÀ URÀ U‘À U—À UæÀ V2À VXÀ V^À V¬À V²À WÀ WQÀ W¢À WñÀ X;À XAÀ XÀ X¥À X¦À XğÀ XöÀ YEÀ Y”À YšÀ YëÀ ZÀ ZÀ ZkÀ ZqÀ ZÑÀ Z×À ZçÀ ZíÀ [/À [wÀ [“À [İÀ [ôÀ \ À \À \IÀ \JÀ \•À \»À \ÁÀ ]À ]ZÀ ]‰À ]À ]àÀ ^,À ^RÀ ^XÀ ^¨À ^÷À _HÀ _NÀ _À _¿À _ÅÀ `#À `)À `9À `?À `À ` À `èÀ aÀ aNÀ aeÀ aˆÀ a‰À aÒÀ bÀ bÀ bXÀ b¦À b÷À cÀ cÀ chÀ cµÀ cäÀ cêÀ dIÀ dOÀ d_À deÀ dÀ dåÀ e5À e`À ekÀ elÀ eºÀ eÙÀ eßÀ f(À f9À f?À fÀ f§À f¨À f÷À gÀ gÀ geÀ gvÀ g|À gÛÀ gæÀ gçÀ h"À h(À htÀ hÁÀ hğÀ höÀ iXÀ ifÀ igÀ iºÀ iÀÀ jÀ jYÀ jˆÀ jÀ jïÀ jüÀ jıÀ kFÀ kpÀ kvÀ kÆÀ lÀ l]À lŠÀ lÀ lÜÀ m)À mXÀ m^À m¿À mÅÀ mÕÀ mÛÀ nÀ n[À nªÀ nÖÀ nãÀ näÀ o2À oJÀ oPÀ o’À o˜À oùÀ oÿÀ pÀ pÀ pNÀ p[À p\À p¥À p«À púÀ qÀ qÀ q`À qqÀ qwÀ q¯À qµÀ rÀ r%À r&À rrÀ r€À r†À rÕÀ rìÀ ròÀ s;À sLÀ sRÀ sŠÀ sÀ sñÀ sşÀ sÿÀ tMÀ tfÀ tlÀ t»À u
À uÀ u\À u©À uñÀ u÷À vFÀ vjÀ vpÀ vĞÀ vùÀ vúÀ wKÀ wdÀ wjÀ w³À w¹À xÀ xRÀ xxÀ x~À xÙÀ xßÀ xïÀ xõÀ yEÀ ynÀ y½À yîÀ yõÀ yöÀ zGÀ z`À zfÀ z¯À zÿÀ {,À {2À {À {“À {£À {©À {ëÀ |:À |PÀ |^À |_À |°À |ÉÀ |ÏÀ }À }À }gÀ }·À }ìÀ }òÀ ~OÀ ~UÀ ~eÀ ~kÀ ~¡À ~ïÀ =À FÀ GÀ ˜À ±À ·À € À €PÀ €}À €ƒÀ €åÀ €ëÀ €ûÀ À PÀ fÀ ±À ÊÀ ØÀ ÚÀ ÛÀ ‚3À ‚nÀ ‚rÀ ‚ÏÀ ƒÀ ƒÀ ƒoÀ ƒÃÀ „À „mÀ „qÀ „¿À „úÀ „şÀ …WÀ …[À …¨À …ğÀ †À †À †!À †%À †pÀ †©À †¿À †ÜÀ †÷À ‡À ‡5À ‡PÀ ‡eÀ ‡»À ‡ãÀ ‡äÀ ˆ(À ˆ.À ˆtÀ ˆ¹À ˆÁÀ ˆÂÀ ˆúÀ ‰ À ‰BÀ ‰qÀ ‰xÀ ‰yÀ ‰ÃÀ ‰ëÀ ‰ñÀ Š<À Š‰À ŠÒÀ ‹À ‹#À ‹SÀ ‹cÀ ‹iÀ ‹¸À ‹ìÀ ŒÀ ŒÀ ŒÀ Œ\À ŒiÀ ŒoÀ Œ½À ŒúÀ  À 'À -À À ÏÀ À  À MÀ UÀ WÀ XÀ |À €À À ’À ÇÀ 
À FÀ WÀ —À À îÀ RÀ XÀ ¦À ØÀ àÀ áÀ ‘À ‘"À ‘lÀ ‘¼À ’,À ’2À ’‚À ’§À ’°À ’±À ’ôÀ “9À “^À “dÀ “³À ”$À ”*À ”zÀ ”ŸÀ ”¥À ”óÀ •À •À •À • À •JÀ •NÀ •›À •ßÀ •ãÀ •ñÀ •õÀ –AÀ –MÀ –ˆÀ –ÅÀ –×À —À —À —|À —‚À —ÊÀ ˜À ˜&À ˜,À ˜<À ˜BÀ ˜À ˜¡À ˜òÀ ™+À ™4À ™5À ™jÀ ™pÀ ™×À ™İÀ š%À šuÀ šÀ š‡À š—À šÀ šëÀ šüÀ ›À ›À ›TÀ ›†À ›ŒÀ ›óÀ ›ùÀ œAÀ œ‘À œÀ œ£À œ³À œ¹À À À !À #À $À ^À bÀ yÀ µÀ ÊÀ À #À $À jÀ °À ×À ßÀ àÀ Ÿ$À ŸjÀ Ÿ±À ŸïÀ ŸùÀ ŸûÀ ŸüÀ  +À  7À  MÀ  SÀ  À  ïÀ  õÀ ¡AÀ ¡WÀ ¡¤À ¡ıÀ ¢RÀ ¢kÀ ¢sÀ ¢tÀ ¢ À ¢¦À ¢ÿÀ £0À £6À £vÀ £|À £ÔÀ ¤/À ¤5À ¤EÀ ¤KÀ ¤§À ¤ËÀ ¤×À ¤ØÀ ¤÷À ¤ıÀ ¥IÀ ¥OÀ ¥¢À ¥¨À ¥ïÀ ¥õÀ ¦JÀ ¦iÀ ¦ÀÀ ¦ÆÀ ¦ÖÀ ¦ÜÀ §$À §oÀ § À §ıÀ ¨
À ¨À ¨WÀ ¨]À ¨°À ©À ©+À ©1À ©ƒÀ ©ĞÀ ª"À ªtÀ ªzÀ ªÊÀ «À «hÀ «¸À «şÀ ¬À ¬À ¬À ¬hÀ ¬‚À ¬„À ¬…À ¬ÇÀ ¬ËÀ ­À ­0À ­>À ­†À ­œÀ ­¨À ­ÃÀ ­ÙÀ ­ßÀ ­ãÀ ­äÀ ®À ®À ®cÀ ®®À ®ıÀ ¯KÀ ¯šÀ ¯ŸÀ ¯ïÀ °@À °QÀ °VÀ °À °ŸÀ °ÀÀ °ÜÀ ±À ±À ±<À ±aÀ ±ŠÀ ±¯À ±ÚÀ ²À ²-À ²]À ²ŠÀ ²´À ²èÀ ³À ³DÀ ³kÀ ³lÀ ³®À ³äÀ ´"À ´XÀ ´šÀ ´ØÀ µÀ µdÀ µªÀ µêÀ ¶<À ¶†À ¶ÈÀ · À ·AÀ ·jÀ ·kÀ ·¯À ·ĞÀ ·ìÀ ¸À ¸À ¸6À ¸yÀ ¸}À ¸~À ¸¤À ¸ÏÀ ¸úÀ ¹NÀ ¹OÀ ¹•À ¹£À ¹©À ¹ÁÀ ¹ÚÀ º!À º%À ºEÀ º•À º¿À ºæÀ »*À ».À »/À »gÀ »—À »˜À »ÑÀ »×À »÷À »ıÀ ¼À ¼À ¼YÀ ¼ŠÀ ¼ÒÀ ¼ØÀ ½ À ½5À ½IÀ ½’À ½¾À ½ÂÀ ½İÀ ¾À ¾QÀ ¾UÀ ¾VÀ ¾À ¾ÏÀ ¾ĞÀ ¿À ¿"À ¿dÀ ¿µÀ ÀÀ À'À À-À ÀzÀ À›À À¡À ÀÈÀ ÀÎÀ ÀŞÀ ÀäÀ Á3À ÁgÀ Á±À ÁÇÀ ÁãÀ Â0À ÂkÀ ÂoÀ Â’À ÂÌÀ ÃÀ ÃÀ ÃÀ ÃWÀ Ã]À Ã…À Ã¡À ÃóÀ Ã÷À ÄÀ Ä?À Ä}À ÄÀ Ä‚À Ä¼À ÅÀ ÅHÀ ÅNÀ Å‹À Å¦À ÅêÀ ÅîÀ ÆÀ Æ2À ÆxÀ Æ|À Æ}À Æ¾À ÆîÀ ÆôÀ Ç&À ÇBÀ Ç”À Ç˜À Ç»À ÇàÀ È"À È&À È'À ÈhÀ ÈnÀ È¿À É
À ÉÀ ÉJÀ ÉPÀ ÉnÀ ÉtÀ ÉİÀ ÉãÀ ÊJÀ ÊPÀ Ê·À Ê½À Ë	À ËZÀ ËfÀ ËlÀ Ë|À Ë‚À ËÑÀ ËıÀ ÌFÀ Ì…À Ì£À Ì÷À ÌûÀ Í À ÍEÀ ÍˆÀ ÍŒÀ ÍÀ ÍÅÀ ÍüÀ ÍıÀ ÎHÀ Î–À ÎáÀ Ï.À Ï|À Ï‚À ÏÇÀ ÏÍÀ ĞÀ Ğ?À ĞEÀ Ğ®À Ğ´À ÑÀ Ñ#À ÑŒÀ Ñ’À ÑŞÀ Ò/À Ò;À ÒAÀ ÒQÀ ÒWÀ Ò¡À Ò¼À ÓÀ Ó%À ÓnÀ ÓrÀ Ó™À Ó×À Ô"À Ô&À Ô'À ÔwÀ ÔµÀ Ô»À ÔßÀ ÔşÀ ÕBÀ ÕcÀ ÕxÀ Õ™À Õ¹À ÖÀ Ö[À ÖfÀ ÖlÀ Ö}À ÖÀ Ö§À ÖÀÀ ×À ×ZÀ ×¢À ×¯À ×üÀ Ø.À Ø€À ØÙÀ Ù*À Ù0À Ù4À Ù5À Ù‡À ÙÛÀ Ú'À Ú-À ÚUÀ Ú¢À ÚÆÀ Û À Û$À ÛOÀ ÛtÀ ÛºÀ Û¾À Û¿À ÛùÀ ÛÿÀ Ü5À Ü;À ÜKÀ ÜQÀ ÜÀ ÜÅÀ Ü÷À İ?À İVÀ İ†À İŠÀ İ¨À İ¸À İÆÀ İõÀ Ş,À Ş5À ŞHÀ ŞRÀ ŞbÀ Ş‡À Ş±À ßÀ ßÀ ß#À ß6À ß@À ßxÀ ß|À ß}À ßÄÀ ßÖÀ ßÜÀ àÀ àÀ àXÀ àyÀ àĞÀ àòÀ àöÀ áÀ ádÀ á„À á¢À áĞÀ áØÀ áåÀ â+À â1À â5À â6À âqÀ âwÀ â¾À âØÀ âŞÀ âìÀ ãÀ ã3À ãEÀ ã_À ã¯À ãºÀ ãÂÀ ãÌÀ ãÒÀ ãâÀ ãèÀ ä#À äDÀ ä›À ä½À äÁÀ äéÀ åÀ å À åNÀ åVÀ åcÀ å¤À åúÀ æ%À æiÀ æqÀ æwÀ æ{À æ|À æ»À æÁÀ çÀ çWÀ çˆÀ ç¢À çéÀ çíÀ èÀ èXÀ è\À è]À èrÀ è´À è¸À èÔÀ éÀ éÀ éÀ éoÀ éuÀ éÆÀ êÀ êKÀ êZÀ êªÀ ê÷À ë&À ë^À ë–À ëšÀ ëÀÀ ëÁÀ ëÍÀ ëãÀ ìÀ ì;À ìAÀ ìqÀ ìŒÀ ì¨À ìÑÀ ìïÀ íÀ íKÀ íZÀ í}À í…À í®À íÓÀ íÛÀ îÀ îDÀ î™À î£À î²À îØÀ îàÀ îøÀ îşÀ ïÀ ïNÀ ïfÀ ïlÀ ïœÀ ïÄÀ ïÜÀ ïâÀ ğÀ ğ?À ğWÀ ğ]À ğ|À ğ¹À ğÑÀ ğ×À ğõÀ ñ0À ñHÀ ñNÀ ñ}À ñ¾À ñÖÀ ñÜÀ ñöÀ ò)À òAÀ òGÀ òfÀ ò£À ò»À òÁÀ òÙÀ óÀ óÀ ó+À ó_À óeÀ ó|À óšÀ óÀ ó À ó¡À óìÀ óğÀ ô3À ô}À ôÈÀ ôúÀ ôşÀ õ1À õ5À õmÀ õÀ õ›À õ¡À õîÀ öÀ ö À öSÀ ö[À ö¨À ööÀ ÷.À ÷gÀ ÷wÀ ÷yÀ ÷zÀ ÷¼À ÷ÔÀ ø"À øoÀ ø·À ùÀ ùÀ ù/À ù5À ù“À ùÀ ùŸÀ ù¿À ùÅÀ úÀ ú1À ú2À úOÀ úUÀ ú¥À úàÀ úñÀ úòÀ ûÀ ûÀ ûjÀ û—À ûÀ û²À û¸À ûÆÀ ûäÀ üÀ ü
À üRÀ üpÀ üÆÀ ıÀ ı)À ıCÀ ı]À ıwÀ ı‘À ıœÀ ı¤À ı®À ıÄÀ ıÅÀ ı×À ıİÀ ş-À ş{À şÇÀ ÿÀ ÿ]À ÿcÀ ÿ´À ÿÀÀ ÿÆÀ ÿÖÀ ÿÜÀ ;À €À ‡À ‰À ŠÀ ÉÀ ÜÀ*ÀzÀ­À¹ÀºÀ	ÀXÀ‹À—À˜ÀèÀ/À~À¹ÀÈÀÊÀËÀ÷À0À1ÀgÀkÀ«À¯ÀıÀÀÀhÀ·ÀşÀFÀ”À¢À¦ÀòÀAÀˆÀŒÀšÀÀÀ[ÀÀĞÀŞÀ	À	 À	HÀ	[À	eÀ	„À	À	¢À	£À	ÄÀ	àÀ	÷À	øÀ
6À
<À
‡À
ÉÀ
êÀÀÀQÀWÀ¢ÀåÀÀ.À/ÀJÀKÀÀ¢À£ÀåÀùÀúÀÀaÀ’À˜ÀéÀÀ
ÀUÀ ÀïÀÀ"À=ÀjÀ–À¬ÀãÀøÀÀ3À9À=À>À‚ÀˆÀÖÀìÀÀÀ+ÀGÀZÀdÀÒÀÖÀ×ÀÀÀ^ÀnÀtÀ¹ÀÀOÀUÀ¢À»ÀÀZÀ¤ÀğÀEÀrÀ À¤À¥ÀáÀçÀ3À‚À®À´ÀÀQÀ„ÀĞÀıÀÀNÀmÀ{À›À©ÀÑÀàÀ.À4À8À9ÀŠÀ¬À²ÀòÀ(ÀFÀVÀªÀ½ÀÇÀÚÀŞÀßÀÀÀeÀ´ÀÀQÀÀëÀ7ÀUÀ[À©ÀÒÀØÀ ÀqÀ‡ÀÀÃÀÉÀ×ÀòÀÀ*À0ÀhÀ§ÀÆÀ À !À 3À SÀ £À ñÀ!À!MÀ!XÀ!yÀ!À!‡À!©À!İÀ"(À"SÀ"–À"ÚÀ#À#0À#6À#rÀ#¢À#¨À#ÅÀ#ßÀ#åÀ$À$%À$@À$HÀ$NÀ$jÀ$À$“À$®À$´À$×À%À%À% À%KÀ%SÀ%]À%cÀ%¨À%öÀ&À&,À&AÀ&YÀ&„À&ÕÀ'#À'eÀ'nÀ'tÀ'“À'¾À'ÂÀ'ÃÀ(À(UÀ([À(¨À(òÀ)BÀ)‘À)ÛÀ*(À*aÀ*bÀ*nÀ*˜À*šÀ*›À*µÀ*êÀ+3À+NÀ+SÀ+¡À+ÃÀ+ßÀ+íÀ+îÀ,=À,WÀ,XÀ,¨À,ÃÀ,ÄÀ-À-OÀ-À-½À-ÇÀ-ÏÀ-ÓÀ-ÔÀ.À.fÀ.²À.³À.ÍÀ.àÀ.øÀ/À/À/iÀ/À/ËÀ0À0
À0 À00À04À05À0€À0¥À0çÀ1À1À1-À1.À1tÀ1“À1”À1 À1ĞÀ1ÒÀ1ÓÀ2À2AÀ2BÀ2vÀ2zÀ2¶À2ĞÀ2ÔÀ3À3gÀ3µÀ3ûÀ4FÀ4oÀ4sÀ4¬À4°À4¼À4ÈÀ5À5CÀ5aÀ5®À5ùÀ6À6bÀ6À6¢À6¨À6°À6´À6ÊÀ6ÎÀ6ÚÀ6çÀ7!À7bÀ7¢À7áÀ8-À8GÀ8–À8ŞÀ8ÿÀ9À9À9À9iÀ9…À9‹À9ÉÀ9åÀ:#À:$À:SÀ:YÀ:¦À:ÁÀ:ÂÀ:ëÀ:ñÀ;9À;?À;‹À; À;¢À;£À;ÃÀ;ÇÀ<À<)À<-À<eÀ<‚À<™À<¿À<ÕÀ<ÖÀ=À=À=?À=dÀ=À=€À=¨À=®À=òÀ=øÀ>IÀ>OÀ>À>ÀÀ>äÀ>åÀ?5À?XÀ?^À?©À?ÎÀ?àÀ?âÀ?ãÀ@/À@4À@}À@˜À@À@ÖÀ@ôÀAÀA	ÀA#ÀA$ÀA0ÀAkÀAlÀAÀÀAàÀAáÀB ÀBÀBÀBWÀBXÀB±ÀBÖÀB×ÀBãÀCÀCVÀC¾ÀCÙÀCüÀD]ÀDgÀD ÀD¯ÀD×ÀEÀEUÀEaÀEiÀEqÀEŠÀE¨ÀE®ÀEËÀEÏÀEĞÀFÀF]ÀF­ÀF®ÀFºÀFüÀGÀGÀGÀG=ÀGAÀGÀGàÀH.ÀHQÀHUÀH§ÀHõÀIÀIPÀIuÀIÆÀJÀJXÀJ¨ÀJ»ÀJ¿ÀK
ÀKTÀK¤ÀKóÀL?ÀLÀLßÀM'ÀMcÀMgÀM±ÀMûÀNKÀN‡ÀN‹ÀNØÀNäÀO	ÀOÀO1ÀOFÀOdÀOoÀO»ÀOåÀOñÀPÀP/ÀPSÀPXÀPZÀP[ÀP~ÀP‚ÀPÑÀQ!ÀQoÀQ’ÀQ–ÀQêÀR8ÀRqÀRuÀRÇÀSÀS#ÀS'ÀSrÀS¼ÀTÀT[ÀT§ÀTøÀUGÀUÀUËÀUÏÀVÀVcÀV³ÀVïÀVóÀW@ÀWLÀWPÀWuÀWyÀWÉÀXÀX_ÀX‡ÀX¶ÀXÒÀXæÀXûÀYÀYÀYFÀYRÀY‘ÀY®ÀYòÀZÀZ$ÀZkÀZ•ÀZŸÀZ§ÀZïÀZöÀZûÀZıÀZşÀ[!À[%À[pÀ[tÀ[ÁÀ\À\OÀ\SÀ\œÀ\ëÀ]À]À]SÀ] À]ìÀ^-À^|À^ÌÀ_À_lÀ_£À_§À_ñÀ`;À`oÀ`sÀ`ÀÀ`ÌÀ`ĞÀ`õÀ`ùÀaIÀa”ÀaßÀbÀb4ÀbPÀbzÀb…Àb¯ÀbûÀcÀc^ÀcÀcŞÀdÀd+ÀdRÀdYÀdgÀd}ÀdÀdƒÀd„ÀdÔÀdöÀdøÀdùÀeHÀeqÀeuÀeƒÀe‡ÀeÑÀeòÀf.ÀfDÀf[Àf^Àf_Àf¤Àf¨Àf¶ÀfºÀgÀgDÀglÀg„Àg°Àg¶ÀhÀhÀhPÀh|ÀhªÀh«ÀhÙÀhßÀi.Ài~ÀiÌÀjÀjDÀjJÀj€Àj”Àj•ÀjÄÀjÊÀkÀkiÀk¶ÀlÀl.Àl4ÀljÀlÀl€ÀlŒÀlÈÀlÊÀlËÀmÀmÀmgÀmµÀmüÀnFÀnsÀnuÀnvÀnÔÀoÀoGÀodÀofÀogÀo¤Ào¨ÀoöÀpAÀpYÀp]Àp©ÀpúÀq9Àq=ÀqˆÀqÒÀr"ÀrqÀr½ÀsÀs]Às¥ÀsáÀsåÀt/ÀtyÀtÉÀuÀu!Àu5ÀuBÀuPÀufÀu‰ÀušÀu®ÀuÃÀuáÀuæÀvÀv7Àv;ÀvYÀvÀv“Àv”Àv¼ÀváÀwÀw/ÀwEÀw]ÀwyÀw–ÀwŸÀw Àw½ÀxÀx-Àx7Àx€Àx¬Àx¶Àx¾Àx¿ÀxĞÀxëÀyÀy5Ày?Ày]Ày¡Ày¼ÀyØÀyãÀz	Àz%ÀzEÀzFÀzrÀz~Àz„Àz†Àz‡ÀzÔÀzäÀzèÀ{À{3À{}À{ƒÀ{ÔÀ|#À|rÀ|À|£À|ÛÀ|æÀ|çÀ})À}/À}€À}ÑÀ}×À~À~À~À~À~BÀ~FÀ~TÀ~XÀ~§À~ÍÀ~âÀÀÀjÀµÀöÀüÀ€À€À€aÀ€{À€‰À€ØÀ€şÀÀRÀ ÀºÀÀÀĞÀ‚À‚À‚_À‚eÀ‚³À‚şÀƒ3Àƒ<Àƒ‡ÀƒÀÀƒÆÀ„À„hÀ„nÀ„~À„»À„ÂÀ„öÀ„üÀ…JÀ…•À…ÖÀ…ÜÀ…ìÀ…òÀ†;À†TÀ†iÀ†kÀ†lÀ†½À†ÚÀ‡*À‡MÀ‡SÀ‡£À‡ìÀˆ=Àˆ†Àˆ Àˆ¦ÀˆõÀ‰AÀ‰{À‰À‰ÌÀ‰ñÀŠÀŠÀŠÀŠ^ÀŠ¨ÀŠÄÀŠŞÀŠßÀŠëÀ‹3À‹NÀ‹PÀ‹QÀ‹ƒÀ‹‡À‹ÌÀ‹ĞÀŒÀŒRÀŒfÀŒjÀŒ°ÀŒÛÀŒßÀÀaÀ‰ÀÀÑÀ
À À@ÀAÀiÀoÀ¼ÀÀ.ÀbÀ’À©À­À®ÀìÀòÀ7ÀTÀxÀyÀ®ÀÑÀÒÀ‘À‘GÀ‘HÀ‘À‘œÀ‘¿À‘ÀÀ’À’9À’fÀ’gÀ’ªÀ’êÀ’ùÀ’ÿÀ“pÀ“åÀ”+À”,À”oÀ”¶À”ûÀ•À•VÀ•WÀ•œÀ•ãÀ•òÀ•øÀ–eÀ–ÖÀ—(À—)À—nÀ—µÀ—úÀ˜À˜iÀ˜jÀ˜°À˜ôÀ™9À™€À™¥À™«ÀšÀš‰ÀšÏÀšĞÀ›À›ZÀ›ŸÀ›æÀœ,ÀœTÀœ¢Àœ£ÀœæÀÀÀQÀuÀ{ÀÂÀÀIÀÀÔÀŸÀŸFÀŸLÀŸ‘ÀŸÇÀ À À hÀ ­À ³À¡À¡KÀ¡À¡¶À¡¼À¢À¢PÀ¢œÀ¢¢À¢ÅÀ¢æÀ£À£À£7À£=À£>À£À£ÒÀ£ØÀ¤À¤À¤aÀ¤¯À¤òÀ¥<À¥BÀ¥…À¥ÓÀ¦ À¦7À¦RÀ¦lÀ¦À¦¨À¦ÃÀ¦ŞÀ¦äÀ¦åÀ§,À§CÀ§^À§_À§¡À§ÏÀ§ÕÀ¨'À¨uÀ¨À¨‘À¨ÙÀ©À©UÀ©–À©ÜÀª ÀªdÀªpÀªvÀªâÀ«RÀ«XÀ«ÈÀ¬<À¬|À¬}À¬ÏÀ¬İÀ¬ãÀ­2À­WÀ­]À­¤À­ØÀ­ÙÀ®À®^À®nÀ®ŒÀ®À®ÓÀ®ÙÀ¯&À¯tÀ¯ŸÀ¯áÀ¯âÀ°(À°gÀ°¤À°ªÀ°÷À±HÀ±sÀ±¼À±½À²À²CÀ²SÀ²TÀ²™À²İÀ²øÀ³À³	À³YÀ³¦À³ÅÀ³ËÀ´À´À´^À´}À´~À´¾À´íÀµ
ÀµÀµKÀµ{Àµ¢Àµ£ÀµØÀµŞÀ¶.À¶{À¶ÆÀ·À·À·\À·«À·ıÀ¸JÀ¸”À¸âÀ¸ğÀ¹5À¹IÀ¹JÀ¹–À¹©À¹¯À¹ÿÀºMÀº‡ÀºĞÀºüÀ»MÀ»`À»fÀ»İÀ»áÀ»âÀ¼1À¼bÀ¼hÀ¼´À¼üÀ½KÀ½šÀ½äÀ¾À¾"À¾mÀ¾ºÀ¿À¿7À¿=À¿À¿ÚÀÀ*ÀÀmÀÀºÀÁÀÁVÀÁ¦ÀÁõÀÁûÀÂIÀÂ˜ÀÂÌÀÂÒÀÃ#ÀÃnÀÃ¨ÀÃªÀÃ«ÀÃõÀÄÀÄAÀÄBÀÄÀÄÕÀÄèÀÄéÀÅ"ÀÅBÀÅCÀÅŠÀÅ°ÀÅ±ÀÅ½ÀÆÀÆÀÆNÀÆOÀÆ£ÀÆÂÀÆÃÀÇÀÇIÀÇJÀÇVÀÇ´ÀÇàÀÇáÀÇíÀÈSÀÈ‰ÀÈŠÀÈ–ÀÈôÀÉ ÀÉ!ÀÉ-ÀÉ“ÀÉÉÀÉÊÀÉÖÀÊOÀÊÀÊŸÀÊ«ÀË,ÀËWÀËŠÀË‹ÀË—ÀÌÀÌqÀÌrÀÌ~ÀÍÀÍhÀÍiÀÍuÀÍìÀÎ;ÀÎ<ÀÎHÀÎÇÀÏÀÏÀÏ+ÀÏ}ÀÏÀÏüÀĞ ÀĞÀĞ„ÀÑ
ÀÑÀÑÀÑ:ÀÑ[ÀÑvÀÑ‘ÀÑ¬ÀÑ³ÀÑ×ÀÑûÀÒUÀÒYÀÒZÀÒàÀÓmÀÓnÀÓzÀÓ•ÀÓ¯ÀÓĞÀÓëÀÔÀÔ!ÀÔ(ÀÔQÀÔuÀÔáÀÔåÀÔæÀÕtÀÕ™ÀÕ¯ÀÕÅÀÕÛÀÕñÀÖÀÖÀÖ4ÀÖ5ÀÖAÀÖ]ÀÖ}ÀÖ¹ÀÖ½ÀÖ¾À×-À×}À×~À×ŠÀ×¦À×ÆÀØÀØÀØÀØvÀØÆÀØÇÀØÓÀÙÀÙ4ÀÙ‡ÀÙ‹ÀÙŒÀÚ
ÀÚÀÚ€ÀÚŒÀÚÁÀÚóÀÚ÷ÀÚøÀÛJÀÛ‡ÀÛˆÀÛ”ÀÛ³ÀÛÕÀÛùÀÛıÀÛşÀÜHÀÜvÀÜwÀÜƒÀÜÆÀÜêÀİÀİ-Àİ{ÀİˆÀİÃÀİÉÀİÍÀİÎÀŞ.ÀŞpÀŞqÀŞãÀßCÀßDÀßPÀßšÀß¾ÀßÙÀàÀàUÀàbÀà¤ÀàªÀà®Àà¯ÀáÀá_Àá`ÀáØÀâ>Àâ?ÀâKÀâ˜Àâ±Àâ²Àâ¾ÀãÀã$Àã%Àã1ÀãQÀãtÀãÀã¢Àã£ÀäÀä2Àä3Àä?Àä]ÀäÀä¯Àä×ÀäèÀäìÀäíÀåDÀå€ÀåÀåÀåµÀåÛÀæ	Àæ(Àæ9Àæ=Àæ>Àæ‘ÀæĞÀæÑÀæİÀæòÀçÀç[Àç_Àç`Àç¥ÀçÊÀçËÀè,ÀèvÀèwÀèƒÀè¾ÀèëÀèïÀèñÀèòÀé4Àé8ÀéFÀé¤Àé´ÀéåÀéëÀêÀê>Àê?Àê„ÀêŠÀêßÀëÀëHÀëÀë”Àë•Àë´ÀëºÀìÀìQÀìjÀìkÀì˜ÀìÀìïÀíAÀí]ÀítÀíuÀí¥Àí«ÀíûÀîJÀîfÀîlÀîºÀï	ÀïXÀï¦Àï·ÀïüÀğ5Àğ7Àğ8Àğ€Àğ„ÀğÕÀñ!ÀñgÀñkÀñ±ÀñµÀòÀòPÀònÀòrÀò¼ÀóÀó-ÀómÀóœÀóòÀóóÀôÀôÀô(ÀôZÀô\Àô]Àô¬ÀôÆÀõÀõ,Àõ-ÀõHÀõkÀõlÀõxÀõ“ÀõÆÀõçÀõÿÀöbÀö¾À÷2À÷;À÷AÀ÷[À÷_À÷`À÷lÀ÷€À÷§À÷×À÷êÀ÷ğÀøÀøÀøÀø Àø!Àø`ÀødÀø¬Àø÷ÀùEÀùiÀùmÀù»Àú
ÀúVÀú¦ÀúôÀûÀûÀû3ÀûqÀû³ÀûæÀûçÀüÀü#ÀülÀü¶ÀüÿÀıÀıÀı<ÀıBÀıÀıÖÀş&ÀşEÀş\Àş]ÀşˆÀşÀşŞÀÿ%ÀÿsÀÿÂÀÿûÀ À OÀ ŸÀ îÀ'ÀAÀBÀaÀbÀ²ÀÙÀßÀ.À{À“À™ÀÎÀÔÀÀLÀÀ‘À’ÀÛÀáÀ#ÀgÀµÀÀÀÀ#À‹ÀÀÀÉÀşÀ#À'À(À}À¿ÀÀÀäÀZÀ|À€ÀÀâÀÀÀTÀ„ÀÒÀ	À	PÀ	lÀ	À	ŒÀ	¢À	ÈÀ	íÀ	öÀ	üÀ
 À
À
\À
¢À
£À
âÀ	ÀÀ­ÀğÀÀÀÀvÀäÀåÀ	ÀÀ£À§À¨ÀÀ3À4À_ÀdÀ¹ÀãÀûÀ'À7ÀTÀZÀkÀoÀpÀÊÀğÀñÀ=ÀCÀ„À¤À¦À§ÀÜÀÀ)ÀaÀbÀ¯ÀòÀüÀıÀKÀ—ÀÅÀÎÀÏÀÀmÀ°À¹ÀºÀ
ÀÀ!À#À$ÀqÀÁÀÓÀ×À(À;À†ÀŒÀÀÀÆÀÀÀlÀºÀ
ÀÀ!ÀpÀvÀœÀ¢À²À¸ÀÀÀ/À@ÀEÀFÀ`ÀwÀxÀ¾À	À3ÀiÀjÀvÀ™À¸ÀÚÀıÀÀÀÀAÀBÀNÀŸÀ¡À¢ÀóÀBÀÀÜÀÀÀZÀgÀ’ÀßÀ0ÀtÀzÀËÀÀFÀÀ™À¹ÀÑÀíÀîÀ8ÀÀ”ÀšÀçÀ À À HÀ {À ®À áÀ!À!À!iÀ!µÀ!»À!ÉÀ"	À" À"7À"NÀ"eÀ"oÀ"yÀ"À"‘À"—À"¸À"¾À"ÌÀ#
À#&À#BÀ#^À#zÀ#„À#À#”À$À$!À$/À$lÀ$À$²À$ÕÀ$øÀ%À%À%À%›À%¡À%¯À%ğÀ&À&<À&bÀ&ˆÀ&’À&œÀ&ÌÀ&ãÀ&şÀ'À'6À'7À'ƒÀ'“À'»À'ÒÀ'íÀ(À(.À(/À(}À(˜À(ÀÀ(×À(òÀ)
À)3À)4À)KÀ)jÀ)‰À)œÀ)À)ÍÀ*À*FÀ*À*ØÀ*ÙÀ*ñÀ*ıÀ+JÀ+KÀ+tÀ+‰À+ À+ÔÀ+ëÀ+õÀ,À,6À,dÀ,‚À,™À,£À,îÀ-À-<À-qÀ-•À-ÊÀ-ÙÀ.À.!À.%À.&À.2À.UÀ.À.•À.›À.»À.ÛÀ/À/4À/_À/cÀ/dÀ/pÀ/…À/¯À0À0À0À0#À0DÀ0YÀ0pÀ0©À0ÂÀ0ñÀ1À1GÀ1kÀ1À1¬À1ÑÀ1×À1ÛÀ1ÜÀ1èÀ1şÀ2À2*À2cÀ2|À2«À2ÏÀ3À3%À3WÀ3fÀ4À4À4À4À4À4MÀ4QÀ4¡À4ìÀ5>À5TÀ5À5±À5éÀ5ıÀ6>À6BÀ6CÀ6gÀ6¡À6µÀ6îÀ6òÀ7!À7fÀ7zÀ7˜À7œÀ7À7ÌÀ8À8%À8CÀ8GÀ8HÀ8–À8¼À8ÙÀ8ÚÀ9À9:À9;À9 À9ÕÀ9ÖÀ:)À:ZÀ:[À:¿À:éÀ:êÀ;NÀ;xÀ;zÀ;{À;®À;²À;ÀÀ;ÄÀ<À<`À<¯À<×À=#À=NÀ=kÀ=½À=êÀ=ëÀ>'À>–À>ïÀ>óÀ>ôÀ?AÀ?‡À?ÖÀ@À@À@À@bÀ@´ÀAÀADÀAHÀAIÀAÀA“ÀAáÀB+ÀB]ÀB©ÀBÉÀCÀCÀCoÀCsÀCtÀC¾ÀCÄÀDÀDJÀDoÀDËÀEÀEÀEÀEiÀE¶ÀEİÀEŞÀF'ÀF_ÀFÀFÀF‚ÀF´ÀFÿÀG ÀGÀG?ÀG@ÀGaÀG¥ÀG±ÀGèÀGéÀGõÀH8ÀH9ÀHEÀH‰ÀHŠÀH–ÀH¹ÀHåÀHùÀHÿÀI&ÀIVÀIˆÀIŒÀIÀI™ÀIáÀIãÀIäÀJÀJ€ÀJÀJ˜ÀJ¯ÀJÊÀJËÀJßÀK!ÀK-ÀKdÀKeÀK€ÀK˜ÀKÃÀKğÀL!ÀLLÀLRÀLVÀLWÀLcÀL­ÀL®ÀLºÀMÀMÀMÀM5ÀMaÀMuÀM{ÀM¨ÀMÊÀMìÀNÀNÀNÀN$ÀNWÀNYÀNZÀNŒÀNÔÀNÕÀNíÀOÀOÀOJÀOVÀOÀOÀOšÀOÚÀOÛÀOçÀP(ÀP)ÀP5ÀPXÀP„ÀP˜ÀPÀPÅÀPéÀQÀQÀQÀQÀQTÀQVÀQWÀQˆÀQÏÀQĞÀQèÀR ÀRÀRDÀRPÀR‡ÀRˆÀR”ÀRÓÀRÔÀRàÀS ÀS!ÀS-ÀSPÀS|ÀSÀS–ÀS¼ÀSàÀTÀT	ÀT
ÀTÀTKÀTMÀTNÀTÀTÒÀTÓÀTôÀUÀUÀU0ÀUvÀU‚ÀU¹ÀUºÀUÆÀV0ÀV1ÀV=ÀV“ÀV”ÀV ÀVÃÀVïÀWÀW	ÀW1ÀW]ÀWŠÀWÀWÀW›ÀWØÀWÚÀWÛÀXÀXÀXnÀXÁÀYÀY@ÀY|ÀY±ÀYÊÀYŞÀZ"ÀZ&ÀZ'ÀZtÀZºÀZëÀ[À[À[IÀ[MÀ[NÀ[’À[äÀ\À\,À\@À\pÀ\tÀ\uÀ\¹À\¿À]À]WÀ]ˆÀ]¡À]ÅÀ^À^	À^À^WÀ^[À^\À^À^ÁÀ^ÚÀ^îÀ_4À_XÀ_\À_]À_À_ÄÀ_İÀ_ñÀ`GÀ`À`ÖÀ`ÚÀ`ÛÀaÀa;Àa<ÀaªÀañÀaòÀb[Àb˜Àb™ÀcÀc=Àc>Àc˜ÀcİÀcŞÀd=ÀdzÀd{ÀdëÀe>Àe?ÀeÀe³ÀeĞÀeÒÀeÓÀfÀfNÀfƒÀfÍÀféÀgÀgÀgÀg3Àg4Àg]ÀgcÀg´ÀgÏÀgçÀg÷ÀhÀh+Àh5ÀhJÀhNÀhOÀhŸÀhÂÀhÈÀiÀi_Ài¨ÀiòÀiøÀj=ÀjPÀj`ÀjÀjœÀj¯Àj¹Àj½Àj¿ÀjÀÀkÀk.Àk2ÀkÀkÍÀlÀljÀlnÀlÃÀmÀmpÀmÈÀnÀnDÀnHÀn¢ÀnÇÀnËÀnÙÀnİÀo!ÀokÀo»ÀoåÀp/ÀpwÀpÀpëÀq9ÀqSÀqÀqÀqøÀqşÀrJÀrÀr–ÀrîÀsÀsÀswÀsÚÀt<ÀtEÀtFÀt—ÀtÀtõÀuSÀuÀu…ÀußÀv<ÀvBÀv¨ÀwÀwsÀwÀw€ÀwÓÀwÙÀx1Àx‰ÀxßÀxúÀy ÀyZÀy°ÀyÅÀyËÀz/Àz“ÀzöÀ{ À{À{AÀ{GÀ{¡À{üÀ|À|À|kÀ|‹À|‘À|ôÀ}WÀ}¹À}ÂÀ}ÄÀ}ÅÀ}öÀ~À~PÀ~yÀ~šÀ~À~¯À~±À~²À~æÀÀHÀqÀÀ²ÀÖÀùÀ€À€7À€;À€LÀ€NÀ€OÀ€ŒÀ€®À€ĞÀ€ıÀÀ/ÀHÀaÀrÀtÀuÀ½ÀÁÀ‚À‚&À‚*À‚8À‚<À‚²À‚¶À‚ÛÀƒÀƒÀƒeÀƒ¶À„ À„OÀ„ À„ñÀ…AÀ…cÀ…iÀ…¸À…îÀ…ôÀ†WÀ†ºÀ‡À‡„À‡ŠÀ‡ÕÀˆÀˆ6Àˆ<Àˆ‰ÀˆÜÀ‰À‰/À‰@À‰OÀ‰iÀ‰‡À‰¯À‰ÉÀ‰îÀŠÀŠMÀŠ`ÀŠÀŠÑÀ‹À‹vÀ‹ŠÀ‹åÀ‹éÀ‹êÀŒ5ÀŒUÀŒ[ÀŒªÀŒûÀEÀ”ÀåÀ6À†À¨À®ÀüÀ2À8À›ÀşÀbÀÈÀÎÀ‘À‘eÀ‘€À‘†À‘ÓÀ’&À’fÀ’lÀ’¸À“À“PÀ“À“íÀ”À”%À”8À”KÀ”eÀ”ƒÀ”«À”ÅÀ”ØÀ”õÀ•À•XÀ•kÀ•˜À•ÕÀ–=À–>À–£À–ÿÀ—CÀ—YÀ—ÃÀ—ĞÀ˜9À˜OÀ˜ÛÀ˜áÀ˜åÀ˜æÀ™6À™TÀ™ZÀ™¥À™óÀš.Àš4ÀšƒÀšÔÀ›À›mÀ›¾ÀœÀœ_ÀœÀœ‡Àœ×ÀÀÀ€ÀâÀEÀªÀ°ÀÿÀŸOÀŸrÀŸxÀŸÅÀ À XÀ jÀ }À —À µÀ İÀ úÀ¡À¡7À¡^À¡„À¡ÀÀ¡ÓÀ¢ À¢=À¢¥À¢¹À£.À£2À£3À£pÀ£À£‘À¤ À¤ƒÀ¤„À¥À¥ À¥6À¥LÀ¥aÀ¥yÀ¥˜À¥¬À¥ÉÀ¥ÊÀ¦jÀ¦ˆÀ¦À¦²À¦ÌÀ¦ßÀ¦òÀ§
À§"À§AÀ§UÀ§rÀ§sÀ§ùÀ¨À¨+À¨AÀ¨YÀ¨xÀ¨ŒÀ¨¥À¨¼À¨ØÀ¨ÙÀ¨üÀ©2À©PÀ©pÀ©ÈÀ©ĞÀ©İÀªÀªiÀªqÀªwÀª{Àª}Àª~Àª¼ÀªäÀ«
À«À«LÀ«›À«áÀ¬À¬À¬iÀ¬¸À¬ÆÀ¬ÌÀ­À­YÀ­†À­ŒÀ­ÒÀ®"À®oÀ®ŒÀ®¨À®öÀ¯À¯À¯AÀ¯QÀ¯qÀ¯¯À¯µÀ¯ÉÀ°<À°UÀ°sÀ°yÀ°}À°~À°ŠÀ°À°²À°ÂÀ°ÆÀ°ÇÀ±À±'À±(À±¤À²À²À²`À²…À²ÍÀ²éÀ²ëÀ²ìÀ³6À³KÀ³OÀ³yÀ³ÉÀ´À´#À´SÀ´gÀ´›À´¸À´×À´İÀ´íÀµ
ÀµÀµ'Àµ+Àµ,ÀµBÀµCÀµˆÀµÀµ×À¶À¶iÀ¶À¶½À·À·KÀ·•À·ÂÀ¸
À¸TÀ¸oÀ¸¤À¸ªÀ¸ÜÀ¹*À¹wÀ¹À¹•À¹™À¹šÀ¹ÓÀº$ÀºrÀºÂÀºÎÀ»À»MÀ»NÀ»ƒÀ»ÎÀ¼À¼HÀ¼šÀ¼¸À¼ÆÀ¼ÌÀ¼ÍÀ½À½ À½.À½4À½5À½qÀ½À½¿À½ÅÀ½ÉÀ½ÊÀ½æÀ¾À¾À¾"À¾<À¾=À¾À¾¡À¾¢À¾şÀ¿1À¿2À¿fÀ¿ºÀ¿¼À¿½À¿ğÀ¿ôÀÀ)ÀÀqÀÀÁÀÁÀÁ5ÀÁ9ÀÁ†ÀÁÓÀÂ!ÀÂjÀÂ£ÀÂÎÀÃ7ÀÃSÀÃbÀÃ„ÀÃ¡ÀÃ¨ÀÃ¬ÀÃ­ÀÃÉÀÃÊÀÄ
ÀÄ6ÀÄ7ÀÄkÀÄqÀÄ¿ÀÅÀÅXÀÅ¦ÀÅöÀÆ ÀÆ&ÀÆmÀÆsÀÆÀÆÀÆ¿ÀÆŞÀÆùÀÇÀÇ	ÀÇWÀÇaÀÇgÀÇuÀÇÆÀÇñÀÈ"ÀÈSÀÈYÀÈŒÀÈ×ÀÉ"ÀÉmÀÉ¸ÀÉ¾ÀÉåÀÊÀÊÀÊ!ÀÊ'ÀÊtÀÊÉÀÊÚÀÊàÀË*ÀËUÀËªÀËÆÀËÊÀËËÀÌÀÌÀÌ_ÀÌ¢ÀÌ¨ÀÌõÀÍÀÍGÀÍ›ÀÍÆÀÍÊÀÍËÀÎÀÎÀÎbÀÎ®ÀÎéÀÎõÀÏÀÏÀÏ?ÀÏOÀÏSÀÏTÀÏ¹ÀĞÀĞ ÀĞ‹ÀĞÈÀĞÉÀÑ%ÀÑJÀÑKÀÑÀÑºÀÑ¼ÀÑ½ÀÒÀÒÀÒ5ÀÒrÀÒ„ÀÒÌÀÒÙÀÒÚÀÓ(ÀÓ9ÀÓ:ÀÓ‹ÀÓ ÀÓ¦ÀÓñÀÔ/ÀÔpÀÔÀÔÀÔ‚ÀÔºÀÔ¾ÀÕÀÕSÀÕÀÕêÀÖ:ÀÖ`ÀÖdÀÖ±ÀÖÿÀ×NÀ×^À×bÀ×®À×ıÀØLÀØ™ÀØæÀÙ6ÀÙ…ÀÙÒÀÙíÀÙñÀÚ>ÀÚˆÀÚÕÀÚ÷ÀÚûÀÛJÀÛÀÛÜÀÜ-ÀÜ~ÀÜÎÀÜñÀİ(ÀİoÀİuÀİÃÀŞÀŞ^ÀŞ©ÀŞØÀŞŞÀß+ÀßTÀßZÀß«ÀßùÀàHÀà…Àà£Àà©ÀàøÀáGÀáMÀáŸÀáÈÀáÎÀâÀâoÀâÀÀãÀãZÀã¥ÀãğÀä ÀäÀäTÀä~Àä„ÀäÂÀäÈÀåÀåeÀå¶ÀæÀæ)Àæ5ÀæJÀæhÀæÀæ§Àæ¿ÀæÆÀçÀçPÀçVÀç­ÀèÀè
Àè%ÀèeÀè—Àè¶ÀéÀéIÀé”Àé¡Àé«Àé³Àé¹ÀéÿÀêOÀê|ÀêŠÀê¾ÀêßÀêíÀë$ÀëIÀëWÀëXÀëÈÀì
ÀìÀìÀìÀìfÀì•Àì›ÀìéÀí6Àí„ÀíÏÀíşÀîÀîQÀî›ÀîçÀï6ÀïIÀïOÀï ÀïïÀğ6Àğ‡ÀğØÀñ'Àñ^ÀñdÀñ³ÀòÀòSÀòœÀòÕÀòÛÀó+Àó|ÀóÍÀôÀôgÀô³ÀõÀõ1Àõ7Àõ…ÀõÕÀö$ÀöRÀöXÀö–Àö¦Àö»ÀöØÀöïÀ÷À÷-À÷4À÷YÀ÷ÉÀ÷ÏÀøÀø]ÀøcÀøºÀùÀùÀù2ÀùrÀù¨ÀùÇÀúÀú_ÀúªÀú·ÀúÁÀúÉÀúÏÀû#ÀûeÀûkÀûoÀûpÀûÒÀüÀü,Àü`ÀüÀüÎÀıÀıÀıRÀıuÀıˆÀı Àı°ÀıÈÀıÛÀıåÀıõÀıùÀıúÀşEÀşjÀş¯ÀşËÀşÌÀşæÀÿ0Àÿ6Àÿ„ÀÿšÀÿµÀÿÉÀÿÙÀÿõÀ À À ƒÀ ‡À ‰À ŠÀ ØÀ ÜÀÀ\ÀmÀÀ•ÀãÀ-ÀfÀlÀ¹ÀÀÀ(À)ÀcÀiÀ¯ÀµÀ÷ÀÀÀÀMÀSÀ•À«À¶À¸À¹ÀÀÀÀ2À@ÀxÀ†À‡ÀÀÀÍÀÏÀĞÀÀ	ÀPÀ”ÀÕÀÙÀ"ÀrÀ»ÀØÀÜÀ,ÀuÀªÀ®ÀûÀ	:À	RÀ	•À	³À	¹À
À
JÀ
šÀ
éÀ6ÀyÀÀÆÀÜÀ,À-ÀuÀ{À§À­À½ÀÃÀÀIÀXÀYÀªÀûÀJÀ“À¢À¨ÀôÀEÀ“ÀÛÀ)ÀsÀyÀÆÀÌÀğÀöÀDÀÀàÀ0ÀUÀ[À©ÀòÀCÀ‘ÀßÀ/ÀwÀ¤ÀªÀôÀÀÀ!ÀNÀvÀÀÍÀöÀ-ÀfÀ€ÀšÀ¢À¬À²ÀÀOÀÀ»ÀÁÀÏÀüÀ?ÀgÀ~À¾ÀõÀ.ÀHÀPÀZÀ`À±À÷ÀAÀGÀUÀ‚À™ÀíÀ&À@ÀWÀ¸ÀñÀÀÀÀ#ÀnÀ·ÀÀ@ÀFÀjÀpÀ¯ÀµÀÀQÀ¢ÀíÀ<ÀŠÀÕÀ  À qÀ ÂÀ İÀ ãÀ óÀ ùÀ!IÀ!kÀ!³À!ÉÀ!öÀ!÷À"7À"VÀ"\À"›À"¡À"êÀ#.À#@À#AÀ#À#êÀ$<À$BÀ$À$‡À$ÕÀ%%À%GÀ%iÀ%jÀ%­À%òÀ&9À&nÀ&tÀ&™À&¯À&°À' À'PÀ'xÀ'yÀ'ÈÀ(À(#À()À(oÀ(À(¨À(©À(şÀ)À)À)oÀ)»À*
À*3À*VÀ*WÀ*§À*âÀ+	À+
À+]À+³À+ÏÀ+ÕÀ,'À,uÀ,ÅÀ,òÀ-À-À-_À-vÀ-|À-ÒÀ-ØÀ.À."À.tÀ.¼À.åÀ.ëÀ/5À/IÀ/¤À/¥À/óÀ0À0À0oÀ0uÀ0¹À0¿À1À1YÀ1©À1ãÀ1äÀ22À2FÀ2LÀ2¢À2¨À2ìÀ2òÀ3DÀ3ŒÀ3µÀ3ìÀ3íÀ4>À4À4ãÀ4ôÀ4úÀ5NÀ5¡À5óÀ6BÀ6‘À6äÀ77À7†À7×À7óÀ7ùÀ81À8ƒÀ8×À9&À9hÀ9nÀ9¼À9ãÀ9éÀ9÷À:À:7À:pÀ:­À:ÌÀ;À;BÀ;QÀ;YÀ;cÀ;iÀ;ºÀ<À<aÀ<µÀ<ÅÀ<ËÀ=À=^À=’À=˜À=èÀ>7À>ƒÀ>›À>°À>ÍÀ>ÎÀ?À?qÀ?ÄÀ?ÊÀ@À@lÀ@¼ÀAÀA^ÀA²ÀBÀBÀBÀBMÀBpÀBqÀB´ÀC ÀCÀCQÀCRÀC¡ÀCéÀCïÀD=ÀDCÀD®ÀEÀEQÀERÀEÀE‡ÀEÌÀEçÀFÀFÀFWÀF’ÀF˜ÀGÀGrÀG›ÀGœÀGíÀH/ÀH5ÀH¡ÀIÀI=ÀI>ÀIÀIŞÀJÀJ
ÀJOÀJ‰ÀJŠÀJ×ÀK(ÀKKÀKQÀK¼ÀL+ÀLTÀLUÀL ÀLòÀMAÀMdÀMjÀM×ÀNHÀNÀN‚ÀN¾ÀNÄÀOÀOQÀO›ÀOïÀP@ÀPÀP¼ÀPÂÀQ1ÀQ¤ÀQªÀRÀR`ÀRaÀR–ÀRœÀRåÀS.ÀSZÀSƒÀS„ÀSÒÀT)ÀTdÀTeÀT´ÀU ÀUÀUUÀUnÀUtÀUÀÀV	ÀVÀV`ÀVaÀV¨ÀV®ÀVüÀWJÀW—ÀWäÀX'ÀX-ÀX{ÀXÈÀYÀY]ÀYnÀYµÀY¶ÀYıÀZÀZ;ÀZ<ÀZˆÀZ˜ÀZÀZéÀZöÀZüÀ[HÀ[•À[ÓÀ[ÙÀ\(À\tÀ\zÀ\ËÀ]À]eÀ]kÀ]µÀ^À^NÀ^ˆÀ^‰À^ÎÀ^ÔÀ_À_!À_gÀ_±À_·À_ÇÀ_ÍÀ`À`6À`€À`À`ÆÀ`ÌÀaÀaiÀaoÀaµÀaÿÀbÀbÀbÀbiÀb‡ÀbÓÀbÔÀcÀc$ÀcpÀcÀc‡ÀcĞÀd!Àd8Àd>Àd‡ÀdÕÀe!ÀeiÀe¹ÀfÀfOÀfÀfëÀg5ÀgoÀguÀgœÀg¢Àg²ÀhÀhOÀhvÀhÈÀiÀiÀiWÀi]Ài®ÀjÀjZÀj®ÀjæÀjìÀk<ÀkÀkÜÀl.Àl~ÀlÒÀmÀm$ÀmuÀmÅÀnÀnqÀn¡ÀnõÀoCÀo‡ÀoÀoàÀp/ÀpzÀpÈÀqÀq#ÀqwÀqÈÀrÀrÀrhÀrƒÀr‰Àr—Àr¬ÀrÕÀrèÀrÿÀsÀsÀs;ÀsqÀswÀsĞÀsîÀtÀtÀt'ÀtVÀtwÀt®ÀtâÀuÀu+ÀuGÀu„Àu¢ÀuÀÀvÀv4ÀvbÀvsÀvˆÀv¼ÀvÿÀw&Àw0Àw6ÀwEÀwMÀwWÀw]Àw¶Àw¼ÀwÊÀwßÀx#Àx6ÀxMÀx`ÀxyÀxÀx‡ÀxµÀxëÀxñÀyJÀyhÀy‰ÀyÀy¡ÀyĞÀyñÀz(Àz\Àz†Àz±ÀzÍÀ{
À{(À{FÀ{ŒÀ{ºÀ{èÀ{ùÀ|À|BÀ|…À|›À|ÏÀ}À}/À}9À}?À}NÀ}VÀ}`À}fÀ}¯À}úÀ~-À~3À~CÀ~IÀ~—À~®À~ÌÀ~ûÀÀDÀkÀŒÀ«À¬ÀğÀöÀ€GÀ€ À€óÀGÀ™ÀëÀ‚"À‚(À‚xÀ‚ÀÀ‚ÆÀƒÀƒWÀƒ‚ÀƒˆÀƒÖÀ„ À„&À„rÀ„¿À…À…À…pÀ…À…‡À…•À…ªÀ…ÓÀ…æÀ…ıÀ†À†À†9À†oÀ†uÀ†ÎÀ†ìÀ‡À‡À‡%À‡TÀ‡¤À‡óÀˆDÀˆ`Àˆ¥ÀˆïÀ‰'À‰RÀ‰ˆÀ‰±À‰ØÀŠÀŠ0ÀŠ6ÀŠÀŠêÀ‹DÀ‹†À‹²À‹ŞÀŒÀŒ\ÀŒhÀŒ‰ÀŒçÀŒñÀŒ÷ÀÀÀÀÀwÀ}À‹À ÀäÀ÷ÀÀ!À:ÀBÀHÀvÀ¬À²ÀÀ)ÀJÀPÀbÀ‘ÀáÀ0ÀÀÀâÀ‘,À‘jÀ‘¢À‘ÍÀ’À’,À’SÀ’ƒÀ’«À’±À“À“cÀ“¾À”À”fÀ”¬À”ÕÀ”ïÀ•*À•FÀ•bÀ•¦À•ÒÀ•şÀ–À–DÀ–{À–°À–åÀ–ëÀ—EÀ—ŸÀ—÷À˜>À˜mÀ˜yÀ˜šÀ™À™À™À™'À™/À™9À™?À™OÀ™UÀ™¢À™·À™ØÀšÀš.ÀšUÀšÀš£ÀšÅÀšÆÀ›À›À›iÀ›~À›„À›ªÀœÀœÀœÀœRÀœ“Àœ³ÀÀÀJÀiÀˆÀäÀèÀéÀSÀÈÀÉÀŸ%ÀŸÀŸÆÀŸëÀŸìÀŸøÀ FÀ ^À _À kÀ ™À ³À ïÀ üÀ¡ À¡…À¡‹À¡À¡À¡òÀ¢LÀ¢MÀ¢ÂÀ£EÀ£FÀ£RÀ££À£¾À£¿À£ËÀ¤*À¤UÀ¤VÀ¤bÀ¤¹À¤ØÀ¤ÙÀ¤åÀ¥HÀ¥yÀ¥zÀ¥†À¥ÅÀ¥ÆÀ¦%À¦SÀ¦TÀ¦`À¦¸À¦àÀ¦áÀ¦íÀ§KÀ§wÀ§xÀ§„À§¬À§ÌÀ¨
À¨À¨)À¨-À¨.À¨{À¨¬À¨­À¨¹À¨ØÀ©	À©%À©9À©=À©>À©À©ÂÀ©ÃÀ©ÏÀª+ÀªKÀª£Àª§Àª¨À«'À«–À«—À«£À«ŞÀ¬ À¬2À¬6À¬7À¬ŠÀ¬ËÀ¬ÌÀ¬ØÀ­À­AÀ­EÀ­FÀ­ŸÀ­ŞÀ­ßÀ­ëÀ®	À®8À®YÀ®ŸÀ®£À®¤À®úÀ¯3À¯4À¯@À¯dÀ¯“À¯ºÀ° À°À°À°aÀ° À°¡À°­À°âÀ±À±À±À±wÀ±­À±®À±ºÀ±ïÀ²À²/À²wÀ²{À²|À²ğÀ³hÀ³iÀ³uÀ³•À³ÂÀ³ÆÀ³ÇÀ´À´iÀ´jÀ´vÀ´ À´ÀÀµÀµÀµÀµ“À¶À¶À¶"À¶OÀ¶qÀ¶³À¶·À¶¸À·À·uÀ·vÀ·‚À·½À·ßÀ¸À¸YÀ¸]À¸^À¸ÄÀ¹8À¹9À¹EÀ¹oÀ¹À¹éÀ¹íÀ¹îÀºbÀºäÀºåÀºñÀ»+À»JÀ»ŒÀ»À»‘À»ÿÀ¼pÀ¼qÀ¼}À¼ÜÀ¼üÀ½xÀ½|À½}À¾À¾ À¾3À¾EÀ¾YÀ¾nÀ¾‡À¾ À¾¶À¾ÙÀ¾ôÀ¾õÀ¿À¿+À¿lÀ¿pÀ¿qÀ¿ÔÀÀ2ÀÀ3ÀÀ?ÀÀ{ÀÀÀÀÁÀÁCÀÁ\ÀÁªÀÁ°ÀÁ´ÀÁµÀÂ2ÀÂ¼ÀÂ½ÀÂÉÀÃÀÃ0ÀÃOÀÃnÀÃ¥ÀÃØÀÄ
ÀÄ>ÀÄsÀÄ¦ÀÄØÀÅÀÅAÀÅzÀÅ°ÀÅõÀÆÀÆ\ÀÆbÀÆfÀÆgÀÇÀÇ;ÀÇOÀÇeÀÇzÀÇ‘ÀÇ©ÀÇ¿ÀÇÔÀÇëÀÈÀÈ&ÀÈ@ÀÈ_ÀÈ`ÀÈlÀÈ´ÀÈÖÀÈøÀÉÀÉNÀÉ„ÀÉ¹ÀÉğÀÊ(ÀÊ[ÀÊÀÊÁÀÊöÀË/ÀËeÀËªÀËÃÀÌÀÌÀÌÀÌÀÌÍÀÌğÀÍÀÍÀÍ5ÀÍOÀÍjÀÍ€ÀÍ•ÀÍ¬ÀÍÄÀÍçÀÎÀÎ ÀÎ!ÀÎ-ÀÎSÀÎwÀÎ¤ÀÎ¨ÀÎ©ÀÎÿÀÏ5ÀÏ6ÀÏBÀÏ}ÀÏÉÀÏõÀĞÀĞDÀĞ|ÀĞ€ÀĞÀĞÀĞØÀÑ1ÀÑ5ÀÑ6ÀÑBÀÑÀÑ±ÀÑüÀÒÀÒIÀÒMÀÒNÀÒ³ÀÓ$ÀÓ%ÀÓ1ÀÓ|ÀÓ¡ÀÓìÀÓğÀÓñÀÔ_ÀÔÑÀÔÒÀÔŞÀÔüÀÕ+ÀÕNÀÕtÀÕ›ÀÕ¼ÀÕÜÀÕşÀÖAÀÖBÀÖjÀÖ”ÀÖßÀÖåÀ×2À×šÀ× À×¡À×èÀØ'ÀØ(ÀØRÀØrÀØ—ÀØ¼ÀØáÀÙÀÙ9ÀÙ[ÀÙ‘ÀÙÇÀÙûÀÚ/ÀÚUÀÚzÀÚ¡ÀÚÉÀÚÏÀÚĞÀÛ9ÀÛzÀÛ²ÀÛ³ÀÛÙÀÜ8ÀÜ~ÀÜ…ÀÜ†ÀÜŸÀÜíÀÜóÀÜ÷ÀÜøÀİÀİ%ÀİTÀİ{Àİ¢ÀİÌÀİğÀŞÀŞDÀŞEÀŞmÀŞšÀŞèÀŞîÀßÀßjÀßpÀß¬Àà%Àà+ÀàcÀàdÀàŠÀàßÀá)Àá0Àá1ÀáJÀá˜ÀáÀá¢Àá£Àâ7ÀâVÀâyÀâ“Àâ±ÀâÅÀâæÀâÿÀãÀã-ÀãKÀãLÀãXÀã°ÀäÀäÀäÀäsÀäÙÀäÛÀäÜÀå
ÀåIÀåJÀå’Àå–ÀåÊÀåÎÀæÀæWÀæ™Àæ²ÀæñÀæ÷ÀçBÀç„Àç¥ÀçÎÀçÏÀèÀèÀèaÀè¤ÀèÅÀèïÀèğÀéÀé ÀéoÀé¾ÀêÀê7Àê8ÀêzÀê€Àê·ÀëÀëUÀëÀë¤ÀëôÀìBÀìoÀìuÀìÅÀíÀí'Àí-Àí|Àí‘Àí½Àí¾ÀîÀî1ÀîCÀîDÀîŠÀîÀîŞÀîôÀïÀïÀïXÀï^Àï¯ÀïáÀğÀğÀğÀğTÀğÀğºÀğÀÀğöÀñÀñÀñÀñJÀñbÀñ‡Àñ»ÀñÁÀñ×Àò'ÀòDÀò^ÀòoÀò®Àò¸ÀòÂÀòÉÀòÍÀòÎÀó,ÀóÀó‚ÀóÀó»ÀóÓÀóøÀô,Àô2Àô3ÀôXÀô€Àô¶ÀôºÀô»ÀõÀõaÀõbÀõnÀõÀõ™Àõ©ÀõÁÀõÔÀõŞÀöÀöÀöÀöÀöaÀö†ÀöÊÀöæÀöçÀ÷À÷À÷À÷)À÷=À÷MÀ÷iÀ÷|À÷†À÷öÀ÷úÀ÷ûÀøÀøeÀøÀøÀø‘ÀøØÀøÜÀù!ÀùfÀù‡ÀùÈÀúÀú+ÀúaÀúbÀúÀú£ÀúçÀû.ÀûeÀûªÀûæÀûşÀûÿÀü.Àü4ÀüÀüÏÀıÀı.Àı0Àı1Àı‘ÀıÀÀıÁÀşÀş%Àş&Àş2Àş]Àş^ÀşjÀş…Àş ÀşäÀşêÀÿ!Àÿ=Àÿ\ÀÿpÀÿÃÀ 
À /À CÀ GÀ HÀ ¡À ÛÀ ÜÀ öÀ øÀ ùÀÀÀNÀ]ÀwÀ}ÀÈÀÀ-À3ÀtÀzÀÉÀâÀóÀ!À@À[À°À±ÀáÀÀ/ÀZÀÀ¨ÀÒÀÓÀÀ	À[À~À“À”ÀÓÀÙÀ'ÀsÀµÀÌÀÍÀÀ:À;ÀmÀsÀ¦À¬ÀÙÀLÀ‚À¶ÀºÀ»À÷ÀıÀ	0À	lÀ	mÀ	ºÀ	ÀÀ	ıÀ
LÀ
sÀ
yÀ
½ÀÀUÀwÀ‹ÀÀ´À÷ÀûÀüÀNÀ\À|ÀÀ£ÀÂÀéÀğÀôÀõÀ%À+ÀtÀ¹ÀİÀãÀ	ÀVÀ ÀëÀ7À…ÀÕÀ"ÀfÀlÀ»ÀÛÀğÀ(À=ÀTÀiÀxÀ™À¡À®ÀÅÀàÀïÀÀ9ÀpÀ²À½ÀÅÀËÀÏÀĞÀ	ÀÀWÀ]À€ÀÎÀğÀÀ	ÀÀ5ÀaÀœÀÌÀûÀÀ8À_ÀeÀœÀ½ÀÃÀÖÀÚÀÛÀçÀ
À,À?ÀEÀ`À€À¢ÀÍÀÑÀÒÀŞÀÀÀiÀ»À×ÀÀ,ÀFÀLÀMÀŠÀÀÀÁÀÛÀ(ÀZÀÀÀÉÀÀÀHÀuÀvÀ­ÀÚÀÛÀ*ÀdÀŠÀÀ‘À©À­À®ÀºÀıÀÿÀ ÀGÀKÀšÀ°ÀîÀÀÀ`ÀuÀ¶ÀûÀ-ÀZÀxÀ|À}À·À½ÀöÀ4ÀyÀÂÀ À 9À À ¼À íÀ!)À!DÀ!^À!ŠÀ!’À!»À!ÃÀ!ÇÀ!ÈÀ!ùÀ!ÿÀ"8À"uÀ"°À"áÀ#À#1À#KÀ#…À#À#¶À#¾À#ÂÀ#ÃÀ$À$[À$\À$¹À%À%À%cÀ%¯À%°À%äÀ&À&À&À&0À&1À&ZÀ&`À&±À&ÌÀ&äÀ&ôÀ'À'(À'2À'GÀ'KÀ'LÀ'œÀ'¿À'ÅÀ(À(\À(©À(öÀ)DÀ)bÀ)uÀ)…À)¤À)ÁÀ)ÔÀ)ŞÀ)îÀ)òÀ)óÀ*>À*cÀ*¯À*ËÀ*ÍÀ*ÎÀ+À+À+lÀ+„À+¥À+ŞÀ+äÀ,4À,†À, À,¦À,ôÀ-GÀ-ˆÀ-ÅÀ-äÀ.À.À.3À.FÀ.lÀ.À.À.ÛÀ/À/hÀ/šÀ/ÒÀ/òÀ/öÀ/÷À0!À0'À0bÀ0sÀ0tÀ0ŸÀ0¥À0àÀ0òÀ0óÀ1%À1+À1bÀ1{À1|À1ÌÀ1ïÀ1õÀ2@À2eÀ2wÀ2xÀ2ÆÀ2âÀ2èÀ33À3€À3‘À3—À3åÀ4À4VÀ4XÀ4YÀ4¹À4×À4ØÀ5À5À5gÀ5¹À5ÓÀ5ÙÀ6'À6zÀ6»À6øÀ7À74À7LÀ7eÀ7xÀ7À7¥À7¹À7ÏÀ8À8,À8zÀ8~À8À8áÀ94À95À9À:,À:-À:<À:=À:–À:²À:³À:¿À:êÀ:ëÀ:ûÀ:üÀ;VÀ;sÀ;tÀ;€À;®À;¯À;ÆÀ;ÇÀ<(À<LÀ<MÀ<YÀ<œÀ<À<©À<õÀ=À=À=À=mÀ= À=ºÀ=ÀÀ=õÀ>À>À>À>NÀ>iÀ>†À>ÄÀ?À?&À?dÀ?…À?»À?ÁÀ?âÀ@À@À@/À@jÀ@|À@€À@À@ìÀABÀADÀAEÀAzÀAªÀA«ÀAãÀAçÀB1ÀB>ÀBÀB‚ÀBÑÀBæÀBéÀC6ÀCSÀCVÀC¢ÀC¥ÀC·ÀCºÀCÅÀCùÀCüÀD7ÀDtÀDyÀD|ÀD›ÀDËÀDĞÀD×ÀDÚÀE/ÀE…ÀE±ÀE´ÀF
ÀF>ÀFtÀF»ÀFÿÀG<ÀGRÀG~ÀG“ÀG§ÀGÔÀGãÀH#ÀH+ÀH8ÀHUÀH[ÀHaÀHsÀHŠÀH¦ÀHªÀHÅÀHÇÀHÈÀIÀIeÀIiÀI¹ÀJ	ÀJ>ÀJyÀJ¾ÀJ¿ÀJôÀKÀKÀK_ÀKzÀK{ÀK‡ÀKÀK÷ÀLÀL(ÀLoÀL˜ÀLÀL¼ÀLÀÀLÂ  dart.ui€¬ M_rectIsValid_rrectIsValid_offsetIsValid_matrix4IsValid_radiusIsValid_scaleAlphaColor	BlendModeFilterQuality	StrokeCap
StrokeJoinPaintingStyleClipPaint
ColorSpaceImageByteFormatPixelFormatImage_Image	FrameInfoCodec_NativeCodecinstantiateImageCodecinstantiateImageCodecFromBufferinstantiateImageCodecWithSize_getDefaultImageSizeTargetImageSizedecodeImageFromList_decodeImageFromListAsyncdecodeImageFromPixelsPathFillTypePathOperationEngineLayer_NativeEngineLayerPath_NativePathTangentPathMetricsPathMetricIterator
PathMetric_PathMeasure	BlurStyle
MaskFilterColorFilter_ColorFilterImageFilter_MatrixImageFilter_GaussianBlurImageFilter_DilateImageFilter_ErodeImageFilter_ComposeImageFilter_ImageFilterShaderTileMode_encodeColorList_encodePointList_encodeTwoPointsGradientImageShaderFragmentProgramFragmentShader
VertexModeVertices	PointModeClipOpCanvas_NativeCanvasPicture_NativePicturePictureRecorder_NativePictureRecorderShadowImmutableBufferImageDescriptor_NativeImageDescriptor	_futurizePictureRasterizationException q}